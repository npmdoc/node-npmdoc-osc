<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/colinbdclark/osc.js">osc (v2.2.0)</a>
</h1>
<h4>A JavaScript Open Sound Control (OSC) library that works in Node.js and the browser.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc">module osc</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">osc.</span>isBufferEnv</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">osc.</span>isCommonJS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">osc.</span>isElectron</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">osc.</span>isNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Gruntfile">
            function <span class="apidocSignatureSpan">osc.</span>Gruntfile
            <span class="apidocSignatureSpan">(grunt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port">
            function <span class="apidocSignatureSpan">osc.</span>Port
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port.prototype.decodeOSC">
            function <span class="apidocSignatureSpan">osc.</span>Port.prototype.decodeOSC
            <span class="apidocSignatureSpan">(data, packetInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port.prototype.encodeOSC">
            function <span class="apidocSignatureSpan">osc.</span>Port.prototype.encodeOSC
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port.prototype.send">
            function <span class="apidocSignatureSpan">osc.</span>Port.prototype.send
            <span class="apidocSignatureSpan">(oscPacket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay">
            function <span class="apidocSignatureSpan">osc.</span>Relay
            <span class="apidocSignatureSpan">(port1, port2, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay.prototype.close">
            function <span class="apidocSignatureSpan">osc.</span>Relay.prototype.close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay.prototype.listen">
            function <span class="apidocSignatureSpan">osc.</span>Relay.prototype.listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay.prototype.open">
            function <span class="apidocSignatureSpan">osc.</span>Relay.prototype.open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SLIPPort">
            function <span class="apidocSignatureSpan">osc.</span>SLIPPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SLIPPort.prototype.decodeSLIPData">
            function <span class="apidocSignatureSpan">osc.</span>SLIPPort.prototype.decodeSLIPData
            <span class="apidocSignatureSpan">(data, packetInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SLIPPort.prototype.encodeOSC">
            function <span class="apidocSignatureSpan">osc.</span>SLIPPort.prototype.encodeOSC
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort">
            function <span class="apidocSignatureSpan">osc.</span>SerialPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.close">
            function <span class="apidocSignatureSpan">osc.</span>SerialPort.prototype.close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.listen">
            function <span class="apidocSignatureSpan">osc.</span>SerialPort.prototype.listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.open">
            function <span class="apidocSignatureSpan">osc.</span>SerialPort.prototype.open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.sendRaw">
            function <span class="apidocSignatureSpan">osc.</span>SerialPort.prototype.sendRaw
            <span class="apidocSignatureSpan">(encoded)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort">
            function <span class="apidocSignatureSpan">osc.</span>TCPSocketPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.close">
            function <span class="apidocSignatureSpan">osc.</span>TCPSocketPort.prototype.close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.listen">
            function <span class="apidocSignatureSpan">osc.</span>TCPSocketPort.prototype.listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.open">
            function <span class="apidocSignatureSpan">osc.</span>TCPSocketPort.prototype.open
            <span class="apidocSignatureSpan">(address, port)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.sendRaw">
            function <span class="apidocSignatureSpan">osc.</span>TCPSocketPort.prototype.sendRaw
            <span class="apidocSignatureSpan">(encoded)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort">
            function <span class="apidocSignatureSpan">osc.</span>UDPPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.close">
            function <span class="apidocSignatureSpan">osc.</span>UDPPort.prototype.close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.listen">
            function <span class="apidocSignatureSpan">osc.</span>UDPPort.prototype.listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.open">
            function <span class="apidocSignatureSpan">osc.</span>UDPPort.prototype.open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.sendRaw">
            function <span class="apidocSignatureSpan">osc.</span>UDPPort.prototype.sendRaw
            <span class="apidocSignatureSpan">(encoded, address, port)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.setupMulticast">
            function <span class="apidocSignatureSpan">osc.</span>UDPPort.setupMulticast
            <span class="apidocSignatureSpan">(that)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket
            <span class="apidocSignatureSpan">(address, protocols, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver
            <span class="apidocSignatureSpan">(extensions, maxPayload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.add">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.add
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.allocateFromPool">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.allocateFromPool
            <span class="apidocSignatureSpan">(length, isFragmented)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.applyExtensions">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.applyExtensions
            <span class="apidocSignatureSpan">(messageBuffer, fin, compressed, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.cleanup">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.cleanup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.endPacket">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.endPacket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.error">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.error
            <span class="apidocSignatureSpan">(reason, protocolErrorCode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.expectData">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.expectData
            <span class="apidocSignatureSpan">(length, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.expectHeader">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.expectHeader
            <span class="apidocSignatureSpan">(length, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.flush">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.maxPayloadExceeded">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.maxPayloadExceeded
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.processPacket">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.processPacket
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.reset">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.unmask">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.unmask
            <span class="apidocSignatureSpan">(mask, buf, binary)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender
            <span class="apidocSignatureSpan">(socket, extensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.applyExtensions">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender.prototype.applyExtensions
            <span class="apidocSignatureSpan">(data, fin, compress, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.close">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender.prototype.close
            <span class="apidocSignatureSpan">(code, data, mask, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.flush">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender.prototype.flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.frameAndSend">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender.prototype.frameAndSend
            <span class="apidocSignatureSpan">(opcode, data, finalFragment, maskData, compressed, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.ping">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender.prototype.ping
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.pong">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender.prototype.pong
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.send">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender.prototype.send
            <span class="apidocSignatureSpan">(data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Server">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Server
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Server.prototype.close">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Server.prototype.close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Server.prototype.handleUpgrade">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Server.prototype.handleUpgrade
            <span class="apidocSignatureSpan">(req, socket, upgradeHead, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.buildHostHeader">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.buildHostHeader
            <span class="apidocSignatureSpan">(isSecure, hostname, port)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.createConnection">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.createConnection
            <span class="apidocSignatureSpan">(address, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.createServer">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.createServer
            <span class="apidocSignatureSpan">(options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.addEventListener">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.addEventListener
            <span class="apidocSignatureSpan">(method, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.close">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.close
            <span class="apidocSignatureSpan">(code, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.pause">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.ping">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.ping
            <span class="apidocSignatureSpan">(data, options, dontFailWhenClosed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.pong">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.pong
            <span class="apidocSignatureSpan">(data, options, dontFailWhenClosed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.resume">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.send">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.send
            <span class="apidocSignatureSpan">(data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.stream">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.stream
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.terminate">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.terminate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort">
            function <span class="apidocSignatureSpan">osc.</span>WebSocketPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.close">
            function <span class="apidocSignatureSpan">osc.</span>WebSocketPort.prototype.close
            <span class="apidocSignatureSpan">(code, reason)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.listen">
            function <span class="apidocSignatureSpan">osc.</span>WebSocketPort.prototype.listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.open">
            function <span class="apidocSignatureSpan">osc.</span>WebSocketPort.prototype.open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.sendRaw">
            function <span class="apidocSignatureSpan">osc.</span>WebSocketPort.prototype.sendRaw
            <span class="apidocSignatureSpan">(encoded)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.setupSocketForBinary">
            function <span class="apidocSignatureSpan">osc.</span>WebSocketPort.setupSocketForBinary
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.addDataPart">
            function <span class="apidocSignatureSpan">osc.</span>addDataPart
            <span class="apidocSignatureSpan">(dataPart, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.annotateArguments">
            function <span class="apidocSignatureSpan">osc.</span>annotateArguments
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.byteArray">
            function <span class="apidocSignatureSpan">osc.</span>byteArray
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.collectArguments">
            function <span class="apidocSignatureSpan">osc.</span>collectArguments
            <span class="apidocSignatureSpan">(args, options, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.collectBundlePackets">
            function <span class="apidocSignatureSpan">osc.</span>collectBundlePackets
            <span class="apidocSignatureSpan">(bundle, options, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.collectMessageParts">
            function <span class="apidocSignatureSpan">osc.</span>collectMessageParts
            <span class="apidocSignatureSpan">(msg, options, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.copyByteArray">
            function <span class="apidocSignatureSpan">osc.</span>copyByteArray
            <span class="apidocSignatureSpan">(source, target, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.dataView">
            function <span class="apidocSignatureSpan">osc.</span>dataView
            <span class="apidocSignatureSpan">(obj, offset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.fireBundleEvents">
            function <span class="apidocSignatureSpan">osc.</span>fireBundleEvents
            <span class="apidocSignatureSpan">(port, bundle, timeTag, packetInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.fireClosedPortSendError">
            function <span class="apidocSignatureSpan">osc.</span>fireClosedPortSendError
            <span class="apidocSignatureSpan">(port, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.firePacketEvents">
            function <span class="apidocSignatureSpan">osc.</span>firePacketEvents
            <span class="apidocSignatureSpan">(port, packet, timeTag, packetInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.inferTypeForArgument">
            function <span class="apidocSignatureSpan">osc.</span>inferTypeForArgument
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.isArray">
            function <span class="apidocSignatureSpan">osc.</span>isArray
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.isBuffer">
            function <span class="apidocSignatureSpan">osc.</span>isBuffer
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.isTypedArrayView">
            function <span class="apidocSignatureSpan">osc.</span>isTypedArrayView
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.isValidBundle">
            function <span class="apidocSignatureSpan">osc.</span>isValidBundle
            <span class="apidocSignatureSpan">(bundle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.isValidMessage">
            function <span class="apidocSignatureSpan">osc.</span>isValidMessage
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.joinParts">
            function <span class="apidocSignatureSpan">osc.</span>joinParts
            <span class="apidocSignatureSpan">(dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.jsToNTPTime">
            function <span class="apidocSignatureSpan">osc.</span>jsToNTPTime
            <span class="apidocSignatureSpan">(jsTime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.nativeBuffer">
            function <span class="apidocSignatureSpan">osc.</span>nativeBuffer
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.ntpToJSTime">
            function <span class="apidocSignatureSpan">osc.</span>ntpToJSTime
            <span class="apidocSignatureSpan">(secs1900, frac)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readArgument">
            function <span class="apidocSignatureSpan">osc.</span>readArgument
            <span class="apidocSignatureSpan">(argType, typeTagString, dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readArguments">
            function <span class="apidocSignatureSpan">osc.</span>readArguments
            <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readArgumentsIntoArray">
            function <span class="apidocSignatureSpan">osc.</span>readArgumentsIntoArray
            <span class="apidocSignatureSpan">(arr, argTypes, typeTagString, dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readBlob">
            function <span class="apidocSignatureSpan">osc.</span>readBlob
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readBundle">
            function <span class="apidocSignatureSpan">osc.</span>readBundle
            <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readBundleContents">
            function <span class="apidocSignatureSpan">osc.</span>readBundleContents
            <span class="apidocSignatureSpan">(dv, options, offsetState, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readChar32">
            function <span class="apidocSignatureSpan">osc.</span>readChar32
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readColor">
            function <span class="apidocSignatureSpan">osc.</span>readColor
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readFalse">
            function <span class="apidocSignatureSpan">osc.</span>readFalse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readFloat32">
            function <span class="apidocSignatureSpan">osc.</span>readFloat32
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readFloat64">
            function <span class="apidocSignatureSpan">osc.</span>readFloat64
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readImpulse">
            function <span class="apidocSignatureSpan">osc.</span>readImpulse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readInt32">
            function <span class="apidocSignatureSpan">osc.</span>readInt32
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readInt64">
            function <span class="apidocSignatureSpan">osc.</span>readInt64
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readMIDIBytes">
            function <span class="apidocSignatureSpan">osc.</span>readMIDIBytes
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readMessage">
            function <span class="apidocSignatureSpan">osc.</span>readMessage
            <span class="apidocSignatureSpan">(data, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readMessageContents">
            function <span class="apidocSignatureSpan">osc.</span>readMessageContents
            <span class="apidocSignatureSpan">(address, dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readNull">
            function <span class="apidocSignatureSpan">osc.</span>readNull
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readPacket">
            function <span class="apidocSignatureSpan">osc.</span>readPacket
            <span class="apidocSignatureSpan">(data, options, offsetState, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readPrimitive">
            function <span class="apidocSignatureSpan">osc.</span>readPrimitive
            <span class="apidocSignatureSpan">(dv, readerName, numBytes, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readString">
            function <span class="apidocSignatureSpan">osc.</span>readString
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readTimeTag">
            function <span class="apidocSignatureSpan">osc.</span>readTimeTag
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readTrue">
            function <span class="apidocSignatureSpan">osc.</span>readTrue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.relay">
            function <span class="apidocSignatureSpan">osc.</span>relay
            <span class="apidocSignatureSpan">(from, to, eventName, sendFnName, transformFn, sendArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.relayPorts">
            function <span class="apidocSignatureSpan">osc.</span>relayPorts
            <span class="apidocSignatureSpan">(from, to, o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.stopRelaying">
            function <span class="apidocSignatureSpan">osc.</span>stopRelaying
            <span class="apidocSignatureSpan">(from, relaySpec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.timeTag">
            function <span class="apidocSignatureSpan">osc.</span>timeTag
            <span class="apidocSignatureSpan">(secs, now)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeArgument">
            function <span class="apidocSignatureSpan">osc.</span>writeArgument
            <span class="apidocSignatureSpan">(arg, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeArguments">
            function <span class="apidocSignatureSpan">osc.</span>writeArguments
            <span class="apidocSignatureSpan">(args, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeArrayArguments">
            function <span class="apidocSignatureSpan">osc.</span>writeArrayArguments
            <span class="apidocSignatureSpan">(args, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeBlob">
            function <span class="apidocSignatureSpan">osc.</span>writeBlob
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeBundle">
            function <span class="apidocSignatureSpan">osc.</span>writeBundle
            <span class="apidocSignatureSpan">(bundle, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeChar32">
            function <span class="apidocSignatureSpan">osc.</span>writeChar32
            <span class="apidocSignatureSpan">(str, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeColor">
            function <span class="apidocSignatureSpan">osc.</span>writeColor
            <span class="apidocSignatureSpan">(color)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeFloat32">
            function <span class="apidocSignatureSpan">osc.</span>writeFloat32
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeFloat64">
            function <span class="apidocSignatureSpan">osc.</span>writeFloat64
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeInt32">
            function <span class="apidocSignatureSpan">osc.</span>writeInt32
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeInt64">
            function <span class="apidocSignatureSpan">osc.</span>writeInt64
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeMIDIBytes">
            function <span class="apidocSignatureSpan">osc.</span>writeMIDIBytes
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeMessage">
            function <span class="apidocSignatureSpan">osc.</span>writeMessage
            <span class="apidocSignatureSpan">(msg, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writePacket">
            function <span class="apidocSignatureSpan">osc.</span>writePacket
            <span class="apidocSignatureSpan">(packet, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writePrimitive">
            function <span class="apidocSignatureSpan">osc.</span>writePrimitive
            <span class="apidocSignatureSpan">(val, dv, writerName, numBytes, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeString">
            function <span class="apidocSignatureSpan">osc.</span>writeString
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeTimeTag">
            function <span class="apidocSignatureSpan">osc.</span>writeTimeTag
            <span class="apidocSignatureSpan">(timeTag)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.</span>SECS_70YRS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.</span>TWO_32</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>Port.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>Relay.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>SLIPPort.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>SerialPort.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>TCPSocketPort.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>UDPPort.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>WebSocket.Server.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>WebSocketPort.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>argumentTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>osc_transports</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.Gruntfile">module osc.Gruntfile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Gruntfile.Gruntfile">
            function <span class="apidocSignatureSpan">osc.</span>Gruntfile
            <span class="apidocSignatureSpan">(grunt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.Port">module osc.Port</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port.Port">
            function <span class="apidocSignatureSpan">osc.</span>Port
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.Port.prototype">module osc.Port.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port.prototype.constructor">
            function <span class="apidocSignatureSpan">osc.Port.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port.prototype.decodeOSC">
            function <span class="apidocSignatureSpan">osc.Port.prototype.</span>decodeOSC
            <span class="apidocSignatureSpan">(data, packetInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port.prototype.encodeOSC">
            function <span class="apidocSignatureSpan">osc.Port.prototype.</span>encodeOSC
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port.prototype.send">
            function <span class="apidocSignatureSpan">osc.Port.prototype.</span>send
            <span class="apidocSignatureSpan">(oscPacket)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.Port.prototype.decodeOSC">module osc.Port.prototype.decodeOSC</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port.prototype.decodeOSC.decodeOSC">
            function <span class="apidocSignatureSpan">osc.Port.prototype.</span>decodeOSC
            <span class="apidocSignatureSpan">(data, packetInfo)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.Port.prototype.encodeOSC">module osc.Port.prototype.encodeOSC</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port.prototype.encodeOSC.encodeOSC">
            function <span class="apidocSignatureSpan">osc.Port.prototype.</span>encodeOSC
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.Port.prototype.send">module osc.Port.prototype.send</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port.prototype.send.send">
            function <span class="apidocSignatureSpan">osc.Port.prototype.</span>send
            <span class="apidocSignatureSpan">(oscPacket)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.Relay">module osc.Relay</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay.Relay">
            function <span class="apidocSignatureSpan">osc.</span>Relay
            <span class="apidocSignatureSpan">(port1, port2, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.Relay.prototype">module osc.Relay.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay.prototype.close">
            function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay.prototype.constructor">
            function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>constructor
            <span class="apidocSignatureSpan">(port1, port2, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay.prototype.listen">
            function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay.prototype.open">
            function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.Relay.prototype.close">module osc.Relay.prototype.close</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay.prototype.close.close">
            function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.Relay.prototype.listen">module osc.Relay.prototype.listen</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay.prototype.listen.listen">
            function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.Relay.prototype.open">module osc.Relay.prototype.open</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay.prototype.open.open">
            function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.SLIPPort">module osc.SLIPPort</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SLIPPort.SLIPPort">
            function <span class="apidocSignatureSpan">osc.</span>SLIPPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.SLIPPort.prototype">module osc.SLIPPort.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SLIPPort.prototype.constructor">
            function <span class="apidocSignatureSpan">osc.SLIPPort.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SLIPPort.prototype.decodeSLIPData">
            function <span class="apidocSignatureSpan">osc.SLIPPort.prototype.</span>decodeSLIPData
            <span class="apidocSignatureSpan">(data, packetInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SLIPPort.prototype.encodeOSC">
            function <span class="apidocSignatureSpan">osc.SLIPPort.prototype.</span>encodeOSC
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.SLIPPort.prototype.decodeSLIPData">module osc.SLIPPort.prototype.decodeSLIPData</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SLIPPort.prototype.decodeSLIPData.decodeSLIPData">
            function <span class="apidocSignatureSpan">osc.SLIPPort.prototype.</span>decodeSLIPData
            <span class="apidocSignatureSpan">(data, packetInfo)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.SLIPPort.prototype.encodeOSC">module osc.SLIPPort.prototype.encodeOSC</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SLIPPort.prototype.encodeOSC.encodeOSC">
            function <span class="apidocSignatureSpan">osc.SLIPPort.prototype.</span>encodeOSC
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.SerialPort">module osc.SerialPort</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.SerialPort">
            function <span class="apidocSignatureSpan">osc.</span>SerialPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.SerialPort.prototype">module osc.SerialPort.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.close">
            function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.constructor">
            function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.listen">
            function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.open">
            function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.sendRaw">
            function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>sendRaw
            <span class="apidocSignatureSpan">(encoded)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.SerialPort.prototype.close">module osc.SerialPort.prototype.close</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.close.close">
            function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.SerialPort.prototype.listen">module osc.SerialPort.prototype.listen</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.listen.listen">
            function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.SerialPort.prototype.open">module osc.SerialPort.prototype.open</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.open.open">
            function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.SerialPort.prototype.sendRaw">module osc.SerialPort.prototype.sendRaw</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.sendRaw.sendRaw">
            function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>sendRaw
            <span class="apidocSignatureSpan">(encoded)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.TCPSocketPort">module osc.TCPSocketPort</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.TCPSocketPort">
            function <span class="apidocSignatureSpan">osc.</span>TCPSocketPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.TCPSocketPort.prototype">module osc.TCPSocketPort.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.close">
            function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.constructor">
            function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.listen">
            function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.open">
            function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>open
            <span class="apidocSignatureSpan">(address, port)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.sendRaw">
            function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>sendRaw
            <span class="apidocSignatureSpan">(encoded)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.TCPSocketPort.prototype.close">module osc.TCPSocketPort.prototype.close</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.close.close">
            function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.TCPSocketPort.prototype.listen">module osc.TCPSocketPort.prototype.listen</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.listen.listen">
            function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.TCPSocketPort.prototype.open">module osc.TCPSocketPort.prototype.open</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.open.open">
            function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>open
            <span class="apidocSignatureSpan">(address, port)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.TCPSocketPort.prototype.sendRaw">module osc.TCPSocketPort.prototype.sendRaw</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.sendRaw.sendRaw">
            function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>sendRaw
            <span class="apidocSignatureSpan">(encoded)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.UDPPort">module osc.UDPPort</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.UDPPort">
            function <span class="apidocSignatureSpan">osc.</span>UDPPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.setupMulticast">
            function <span class="apidocSignatureSpan">osc.UDPPort.</span>setupMulticast
            <span class="apidocSignatureSpan">(that)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.UDPPort.prototype">module osc.UDPPort.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.close">
            function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.constructor">
            function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.listen">
            function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.open">
            function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.sendRaw">
            function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>sendRaw
            <span class="apidocSignatureSpan">(encoded, address, port)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.UDPPort.prototype.close">module osc.UDPPort.prototype.close</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.close.close">
            function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.UDPPort.prototype.listen">module osc.UDPPort.prototype.listen</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.listen.listen">
            function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.UDPPort.prototype.open">module osc.UDPPort.prototype.open</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.open.open">
            function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.UDPPort.prototype.sendRaw">module osc.UDPPort.prototype.sendRaw</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.sendRaw.sendRaw">
            function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>sendRaw
            <span class="apidocSignatureSpan">(encoded, address, port)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.UDPPort.setupMulticast">module osc.UDPPort.setupMulticast</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.setupMulticast.setupMulticast">
            function <span class="apidocSignatureSpan">osc.UDPPort.</span>setupMulticast
            <span class="apidocSignatureSpan">(that)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket">module osc.WebSocket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.WebSocket">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket
            <span class="apidocSignatureSpan">(address, protocols, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>Receiver
            <span class="apidocSignatureSpan">(extensions, maxPayload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>Sender
            <span class="apidocSignatureSpan">(socket, extensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Server">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>Server
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.buildHostHeader">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>buildHostHeader
            <span class="apidocSignatureSpan">(isSecure, hostname, port)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.connect">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>connect
            <span class="apidocSignatureSpan">(address, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.createConnection">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>createConnection
            <span class="apidocSignatureSpan">(address, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.createServer">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>createServer
            <span class="apidocSignatureSpan">(options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.super_">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.WebSocket.</span>CLOSED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.WebSocket.</span>CLOSING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.WebSocket.</span>CONNECTING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.WebSocket.</span>OPEN</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver">module osc.WebSocket.Receiver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.Receiver">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>Receiver
            <span class="apidocSignatureSpan">(extensions, maxPayload)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver.prototype">module osc.WebSocket.Receiver.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.add">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>add
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.allocateFromPool">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>allocateFromPool
            <span class="apidocSignatureSpan">(length, isFragmented)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.applyExtensions">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>applyExtensions
            <span class="apidocSignatureSpan">(messageBuffer, fin, compressed, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.cleanup">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>cleanup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.endPacket">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>endPacket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.error">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>error
            <span class="apidocSignatureSpan">(reason, protocolErrorCode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.expectData">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>expectData
            <span class="apidocSignatureSpan">(length, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.expectHeader">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>expectHeader
            <span class="apidocSignatureSpan">(length, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.flush">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.maxPayloadExceeded">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>maxPayloadExceeded
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.processPacket">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>processPacket
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.reset">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.unmask">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>unmask
            <span class="apidocSignatureSpan">(mask, buf, binary)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.add">module osc.WebSocket.Receiver.prototype.add</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.add.add">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>add
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.allocateFromPool">module osc.WebSocket.Receiver.prototype.allocateFromPool</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.allocateFromPool.allocateFromPool">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>allocateFromPool
            <span class="apidocSignatureSpan">(length, isFragmented)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.applyExtensions">module osc.WebSocket.Receiver.prototype.applyExtensions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.applyExtensions.applyExtensions">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>applyExtensions
            <span class="apidocSignatureSpan">(messageBuffer, fin, compressed, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.cleanup">module osc.WebSocket.Receiver.prototype.cleanup</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.cleanup.cleanup">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>cleanup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.endPacket">module osc.WebSocket.Receiver.prototype.endPacket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.endPacket.endPacket">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>endPacket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.error">module osc.WebSocket.Receiver.prototype.error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.error.error">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>error
            <span class="apidocSignatureSpan">(reason, protocolErrorCode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.expectData">module osc.WebSocket.Receiver.prototype.expectData</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.expectData.expectData">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>expectData
            <span class="apidocSignatureSpan">(length, handler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.expectHeader">module osc.WebSocket.Receiver.prototype.expectHeader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.expectHeader.expectHeader">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>expectHeader
            <span class="apidocSignatureSpan">(length, handler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.flush">module osc.WebSocket.Receiver.prototype.flush</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.flush.flush">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.maxPayloadExceeded">module osc.WebSocket.Receiver.prototype.maxPayloadExceeded</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.maxPayloadExceeded.maxPayloadExceeded">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>maxPayloadExceeded
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.processPacket">module osc.WebSocket.Receiver.prototype.processPacket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.processPacket.processPacket">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>processPacket
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.reset">module osc.WebSocket.Receiver.prototype.reset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.reset.reset">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.unmask">module osc.WebSocket.Receiver.prototype.unmask</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.unmask.unmask">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>unmask
            <span class="apidocSignatureSpan">(mask, buf, binary)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Sender">module osc.WebSocket.Sender</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.Sender">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>Sender
            <span class="apidocSignatureSpan">(socket, extensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.super_">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Sender.prototype">module osc.WebSocket.Sender.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.applyExtensions">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>applyExtensions
            <span class="apidocSignatureSpan">(data, fin, compress, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.close">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>close
            <span class="apidocSignatureSpan">(code, data, mask, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.flush">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.frameAndSend">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>frameAndSend
            <span class="apidocSignatureSpan">(opcode, data, finalFragment, maskData, compressed, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.ping">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>ping
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.pong">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>pong
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.send">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>send
            <span class="apidocSignatureSpan">(data, options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Sender.prototype.applyExtensions">module osc.WebSocket.Sender.prototype.applyExtensions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.applyExtensions.applyExtensions">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>applyExtensions
            <span class="apidocSignatureSpan">(data, fin, compress, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Sender.prototype.close">module osc.WebSocket.Sender.prototype.close</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.close.close">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>close
            <span class="apidocSignatureSpan">(code, data, mask, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Sender.prototype.flush">module osc.WebSocket.Sender.prototype.flush</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.flush.flush">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Sender.prototype.frameAndSend">module osc.WebSocket.Sender.prototype.frameAndSend</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.frameAndSend.frameAndSend">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>frameAndSend
            <span class="apidocSignatureSpan">(opcode, data, finalFragment, maskData, compressed, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Sender.prototype.ping">module osc.WebSocket.Sender.prototype.ping</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.ping.ping">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>ping
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Sender.prototype.pong">module osc.WebSocket.Sender.prototype.pong</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.pong.pong">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>pong
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Sender.prototype.send">module osc.WebSocket.Sender.prototype.send</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.send.send">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>send
            <span class="apidocSignatureSpan">(data, options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Server">module osc.WebSocket.Server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Server.Server">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>Server
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Server.super_">
            function <span class="apidocSignatureSpan">osc.WebSocket.Server.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Server.prototype">module osc.WebSocket.Server.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Server.prototype.close">
            function <span class="apidocSignatureSpan">osc.WebSocket.Server.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Server.prototype.handleUpgrade">
            function <span class="apidocSignatureSpan">osc.WebSocket.Server.prototype.</span>handleUpgrade
            <span class="apidocSignatureSpan">(req, socket, upgradeHead, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Server.prototype.close">module osc.WebSocket.Server.prototype.close</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Server.prototype.close.close">
            function <span class="apidocSignatureSpan">osc.WebSocket.Server.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Server.prototype.handleUpgrade">module osc.WebSocket.Server.prototype.handleUpgrade</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Server.prototype.handleUpgrade.handleUpgrade">
            function <span class="apidocSignatureSpan">osc.WebSocket.Server.prototype.</span>handleUpgrade
            <span class="apidocSignatureSpan">(req, socket, upgradeHead, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.buildHostHeader">module osc.WebSocket.buildHostHeader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.buildHostHeader.buildHostHeader">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>buildHostHeader
            <span class="apidocSignatureSpan">(isSecure, hostname, port)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.createConnection">module osc.WebSocket.createConnection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.createConnection.createConnection">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>createConnection
            <span class="apidocSignatureSpan">(address, fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.createServer">module osc.WebSocket.createServer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.createServer.createServer">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>createServer
            <span class="apidocSignatureSpan">(options, fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.prototype">module osc.WebSocket.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.addEventListener">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>addEventListener
            <span class="apidocSignatureSpan">(method, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.close">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>close
            <span class="apidocSignatureSpan">(code, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.pause">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.ping">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>ping
            <span class="apidocSignatureSpan">(data, options, dontFailWhenClosed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.pong">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>pong
            <span class="apidocSignatureSpan">(data, options, dontFailWhenClosed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.resume">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.send">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>send
            <span class="apidocSignatureSpan">(data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.stream">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>stream
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.terminate">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>terminate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>CLOSED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>CLOSING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>CONNECTING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>OPEN</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.prototype.addEventListener">module osc.WebSocket.prototype.addEventListener</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.addEventListener.addEventListener">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>addEventListener
            <span class="apidocSignatureSpan">(method, listener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.prototype.close">module osc.WebSocket.prototype.close</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.close.close">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>close
            <span class="apidocSignatureSpan">(code, data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.prototype.pause">module osc.WebSocket.prototype.pause</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.pause.pause">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.prototype.ping">module osc.WebSocket.prototype.ping</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.ping.ping">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>ping
            <span class="apidocSignatureSpan">(data, options, dontFailWhenClosed)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.prototype.pong">module osc.WebSocket.prototype.pong</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.pong.pong">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>pong
            <span class="apidocSignatureSpan">(data, options, dontFailWhenClosed)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.prototype.resume">module osc.WebSocket.prototype.resume</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.resume.resume">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.prototype.send">module osc.WebSocket.prototype.send</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.send.send">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>send
            <span class="apidocSignatureSpan">(data, options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.prototype.stream">module osc.WebSocket.prototype.stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.stream.stream">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>stream
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.prototype.terminate">module osc.WebSocket.prototype.terminate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.terminate.terminate">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>terminate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocketPort">module osc.WebSocketPort</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.WebSocketPort">
            function <span class="apidocSignatureSpan">osc.</span>WebSocketPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.setupSocketForBinary">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.</span>setupSocketForBinary
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocketPort.prototype">module osc.WebSocketPort.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.close">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>close
            <span class="apidocSignatureSpan">(code, reason)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.constructor">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.listen">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.open">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.sendRaw">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>sendRaw
            <span class="apidocSignatureSpan">(encoded)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocketPort.prototype.close">module osc.WebSocketPort.prototype.close</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.close.close">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>close
            <span class="apidocSignatureSpan">(code, reason)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocketPort.prototype.listen">module osc.WebSocketPort.prototype.listen</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.listen.listen">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocketPort.prototype.open">module osc.WebSocketPort.prototype.open</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.open.open">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocketPort.prototype.sendRaw">module osc.WebSocketPort.prototype.sendRaw</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.sendRaw.sendRaw">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>sendRaw
            <span class="apidocSignatureSpan">(encoded)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocketPort.setupSocketForBinary">module osc.WebSocketPort.setupSocketForBinary</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.setupSocketForBinary.setupSocketForBinary">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.</span>setupSocketForBinary
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.addDataPart">module osc.addDataPart</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.addDataPart.addDataPart">
            function <span class="apidocSignatureSpan">osc.</span>addDataPart
            <span class="apidocSignatureSpan">(dataPart, dataCollection)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.annotateArguments">module osc.annotateArguments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.annotateArguments.annotateArguments">
            function <span class="apidocSignatureSpan">osc.</span>annotateArguments
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.byteArray">module osc.byteArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.byteArray.byteArray">
            function <span class="apidocSignatureSpan">osc.</span>byteArray
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.collectArguments">module osc.collectArguments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.collectArguments.collectArguments">
            function <span class="apidocSignatureSpan">osc.</span>collectArguments
            <span class="apidocSignatureSpan">(args, options, dataCollection)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.collectBundlePackets">module osc.collectBundlePackets</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.collectBundlePackets.collectBundlePackets">
            function <span class="apidocSignatureSpan">osc.</span>collectBundlePackets
            <span class="apidocSignatureSpan">(bundle, options, dataCollection)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.collectMessageParts">module osc.collectMessageParts</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.collectMessageParts.collectMessageParts">
            function <span class="apidocSignatureSpan">osc.</span>collectMessageParts
            <span class="apidocSignatureSpan">(msg, options, dataCollection)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.copyByteArray">module osc.copyByteArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.copyByteArray.copyByteArray">
            function <span class="apidocSignatureSpan">osc.</span>copyByteArray
            <span class="apidocSignatureSpan">(source, target, offset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.dataView">module osc.dataView</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.dataView.dataView">
            function <span class="apidocSignatureSpan">osc.</span>dataView
            <span class="apidocSignatureSpan">(obj, offset, length)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.fireBundleEvents">module osc.fireBundleEvents</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.fireBundleEvents.fireBundleEvents">
            function <span class="apidocSignatureSpan">osc.</span>fireBundleEvents
            <span class="apidocSignatureSpan">(port, bundle, timeTag, packetInfo)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.fireClosedPortSendError">module osc.fireClosedPortSendError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.fireClosedPortSendError.fireClosedPortSendError">
            function <span class="apidocSignatureSpan">osc.</span>fireClosedPortSendError
            <span class="apidocSignatureSpan">(port, msg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.firePacketEvents">module osc.firePacketEvents</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.firePacketEvents.firePacketEvents">
            function <span class="apidocSignatureSpan">osc.</span>firePacketEvents
            <span class="apidocSignatureSpan">(port, packet, timeTag, packetInfo)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.inferTypeForArgument">module osc.inferTypeForArgument</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.inferTypeForArgument.inferTypeForArgument">
            function <span class="apidocSignatureSpan">osc.</span>inferTypeForArgument
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.isArray">module osc.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.isArray.isArray">
            function <span class="apidocSignatureSpan">osc.</span>isArray
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.isBuffer">module osc.isBuffer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.isBuffer.isBuffer">
            function <span class="apidocSignatureSpan">osc.</span>isBuffer
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.isTypedArrayView">module osc.isTypedArrayView</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.isTypedArrayView.isTypedArrayView">
            function <span class="apidocSignatureSpan">osc.</span>isTypedArrayView
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.isValidBundle">module osc.isValidBundle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.isValidBundle.isValidBundle">
            function <span class="apidocSignatureSpan">osc.</span>isValidBundle
            <span class="apidocSignatureSpan">(bundle)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.isValidMessage">module osc.isValidMessage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.isValidMessage.isValidMessage">
            function <span class="apidocSignatureSpan">osc.</span>isValidMessage
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.joinParts">module osc.joinParts</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.joinParts.joinParts">
            function <span class="apidocSignatureSpan">osc.</span>joinParts
            <span class="apidocSignatureSpan">(dataCollection)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.jsToNTPTime">module osc.jsToNTPTime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.jsToNTPTime.jsToNTPTime">
            function <span class="apidocSignatureSpan">osc.</span>jsToNTPTime
            <span class="apidocSignatureSpan">(jsTime)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.nativeBuffer">module osc.nativeBuffer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.nativeBuffer.nativeBuffer">
            function <span class="apidocSignatureSpan">osc.</span>nativeBuffer
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.ntpToJSTime">module osc.ntpToJSTime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.ntpToJSTime.ntpToJSTime">
            function <span class="apidocSignatureSpan">osc.</span>ntpToJSTime
            <span class="apidocSignatureSpan">(secs1900, frac)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.osc_transports">module osc.osc_transports</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">osc.osc_transports.</span>isBufferEnv</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">osc.osc_transports.</span>isCommonJS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">osc.osc_transports.</span>isElectron</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">osc.osc_transports.</span>isNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.Port">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>Port
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.Relay">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>Relay
            <span class="apidocSignatureSpan">(port1, port2, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.SLIPPort">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>SLIPPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.WebSocket">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>WebSocket
            <span class="apidocSignatureSpan">(address, protocols, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.WebSocketPort">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>WebSocketPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.addDataPart">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>addDataPart
            <span class="apidocSignatureSpan">(dataPart, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.annotateArguments">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>annotateArguments
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.byteArray">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>byteArray
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.collectArguments">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>collectArguments
            <span class="apidocSignatureSpan">(args, options, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.collectBundlePackets">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>collectBundlePackets
            <span class="apidocSignatureSpan">(bundle, options, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.collectMessageParts">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>collectMessageParts
            <span class="apidocSignatureSpan">(msg, options, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.copyByteArray">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>copyByteArray
            <span class="apidocSignatureSpan">(source, target, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.dataView">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>dataView
            <span class="apidocSignatureSpan">(obj, offset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.fireBundleEvents">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>fireBundleEvents
            <span class="apidocSignatureSpan">(port, bundle, timeTag, packetInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.fireClosedPortSendError">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>fireClosedPortSendError
            <span class="apidocSignatureSpan">(port, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.firePacketEvents">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>firePacketEvents
            <span class="apidocSignatureSpan">(port, packet, timeTag, packetInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.inferTypeForArgument">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>inferTypeForArgument
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.isArray">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>isArray
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.isBuffer">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>isBuffer
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.isTypedArrayView">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>isTypedArrayView
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.isValidBundle">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>isValidBundle
            <span class="apidocSignatureSpan">(bundle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.isValidMessage">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>isValidMessage
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.joinParts">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>joinParts
            <span class="apidocSignatureSpan">(dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.jsToNTPTime">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>jsToNTPTime
            <span class="apidocSignatureSpan">(jsTime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.nativeBuffer">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>nativeBuffer
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.ntpToJSTime">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>ntpToJSTime
            <span class="apidocSignatureSpan">(secs1900, frac)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readArgument">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readArgument
            <span class="apidocSignatureSpan">(argType, typeTagString, dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readArguments">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readArguments
            <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readArgumentsIntoArray">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readArgumentsIntoArray
            <span class="apidocSignatureSpan">(arr, argTypes, typeTagString, dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readBlob">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readBlob
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readBundle">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readBundle
            <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readBundleContents">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readBundleContents
            <span class="apidocSignatureSpan">(dv, options, offsetState, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readChar32">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readChar32
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readColor">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readColor
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readFalse">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readFalse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readFloat32">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readFloat32
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readFloat64">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readFloat64
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readImpulse">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readImpulse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readInt32">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readInt32
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readInt64">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readInt64
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readMIDIBytes">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readMIDIBytes
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readMessage">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readMessage
            <span class="apidocSignatureSpan">(data, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readMessageContents">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readMessageContents
            <span class="apidocSignatureSpan">(address, dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readNull">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readNull
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readPacket">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readPacket
            <span class="apidocSignatureSpan">(data, options, offsetState, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readPrimitive">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readPrimitive
            <span class="apidocSignatureSpan">(dv, readerName, numBytes, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readString">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readString
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readTimeTag">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readTimeTag
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.readTrue">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>readTrue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.relay">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>relay
            <span class="apidocSignatureSpan">(from, to, eventName, sendFnName, transformFn, sendArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.relayPorts">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>relayPorts
            <span class="apidocSignatureSpan">(from, to, o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.stopRelaying">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>stopRelaying
            <span class="apidocSignatureSpan">(from, relaySpec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.timeTag">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>timeTag
            <span class="apidocSignatureSpan">(secs, now)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writeArgument">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeArgument
            <span class="apidocSignatureSpan">(arg, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writeArguments">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeArguments
            <span class="apidocSignatureSpan">(args, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writeArrayArguments">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeArrayArguments
            <span class="apidocSignatureSpan">(args, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writeBlob">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeBlob
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writeBundle">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeBundle
            <span class="apidocSignatureSpan">(bundle, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writeChar32">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeChar32
            <span class="apidocSignatureSpan">(str, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writeColor">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeColor
            <span class="apidocSignatureSpan">(color)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writeFloat32">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeFloat32
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writeFloat64">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeFloat64
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writeInt32">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeInt32
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writeInt64">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeInt64
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writeMIDIBytes">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeMIDIBytes
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writeMessage">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeMessage
            <span class="apidocSignatureSpan">(msg, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writePacket">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writePacket
            <span class="apidocSignatureSpan">(packet, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writePrimitive">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writePrimitive
            <span class="apidocSignatureSpan">(val, dv, writerName, numBytes, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writeString">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeString
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc_transports.writeTimeTag">
            function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeTimeTag
            <span class="apidocSignatureSpan">(timeTag)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.osc_transports.</span>SECS_70YRS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.osc_transports.</span>TWO_32</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.osc_transports.</span>argumentTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.osc_transports.</span>defaults</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readArgument">module osc.readArgument</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readArgument.readArgument">
            function <span class="apidocSignatureSpan">osc.</span>readArgument
            <span class="apidocSignatureSpan">(argType, typeTagString, dv, options, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readArguments">module osc.readArguments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readArguments.readArguments">
            function <span class="apidocSignatureSpan">osc.</span>readArguments
            <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readArgumentsIntoArray">module osc.readArgumentsIntoArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readArgumentsIntoArray.readArgumentsIntoArray">
            function <span class="apidocSignatureSpan">osc.</span>readArgumentsIntoArray
            <span class="apidocSignatureSpan">(arr, argTypes, typeTagString, dv, options, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readBlob">module osc.readBlob</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readBlob.readBlob">
            function <span class="apidocSignatureSpan">osc.</span>readBlob
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readBundle">module osc.readBundle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readBundle.readBundle">
            function <span class="apidocSignatureSpan">osc.</span>readBundle
            <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readBundleContents">module osc.readBundleContents</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readBundleContents.readBundleContents">
            function <span class="apidocSignatureSpan">osc.</span>readBundleContents
            <span class="apidocSignatureSpan">(dv, options, offsetState, len)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readChar32">module osc.readChar32</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readChar32.readChar32">
            function <span class="apidocSignatureSpan">osc.</span>readChar32
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readColor">module osc.readColor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readColor.readColor">
            function <span class="apidocSignatureSpan">osc.</span>readColor
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readFalse">module osc.readFalse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readFalse.readFalse">
            function <span class="apidocSignatureSpan">osc.</span>readFalse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readFloat32">module osc.readFloat32</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readFloat32.readFloat32">
            function <span class="apidocSignatureSpan">osc.</span>readFloat32
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readFloat64">module osc.readFloat64</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readFloat64.readFloat64">
            function <span class="apidocSignatureSpan">osc.</span>readFloat64
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readImpulse">module osc.readImpulse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readImpulse.readImpulse">
            function <span class="apidocSignatureSpan">osc.</span>readImpulse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readInt32">module osc.readInt32</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readInt32.readInt32">
            function <span class="apidocSignatureSpan">osc.</span>readInt32
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readInt64">module osc.readInt64</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readInt64.readInt64">
            function <span class="apidocSignatureSpan">osc.</span>readInt64
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readMIDIBytes">module osc.readMIDIBytes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readMIDIBytes.readMIDIBytes">
            function <span class="apidocSignatureSpan">osc.</span>readMIDIBytes
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readMessage">module osc.readMessage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readMessage.readMessage">
            function <span class="apidocSignatureSpan">osc.</span>readMessage
            <span class="apidocSignatureSpan">(data, options, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readMessageContents">module osc.readMessageContents</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readMessageContents.readMessageContents">
            function <span class="apidocSignatureSpan">osc.</span>readMessageContents
            <span class="apidocSignatureSpan">(address, dv, options, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readNull">module osc.readNull</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readNull.readNull">
            function <span class="apidocSignatureSpan">osc.</span>readNull
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readPacket">module osc.readPacket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readPacket.readPacket">
            function <span class="apidocSignatureSpan">osc.</span>readPacket
            <span class="apidocSignatureSpan">(data, options, offsetState, len)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readPrimitive">module osc.readPrimitive</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readPrimitive.readPrimitive">
            function <span class="apidocSignatureSpan">osc.</span>readPrimitive
            <span class="apidocSignatureSpan">(dv, readerName, numBytes, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readString">module osc.readString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readString.readString">
            function <span class="apidocSignatureSpan">osc.</span>readString
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readTimeTag">module osc.readTimeTag</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readTimeTag.readTimeTag">
            function <span class="apidocSignatureSpan">osc.</span>readTimeTag
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.readTrue">module osc.readTrue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readTrue.readTrue">
            function <span class="apidocSignatureSpan">osc.</span>readTrue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.relay">module osc.relay</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.relay.relay">
            function <span class="apidocSignatureSpan">osc.</span>relay
            <span class="apidocSignatureSpan">(from, to, eventName, sendFnName, transformFn, sendArgs)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.relayPorts">module osc.relayPorts</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.relayPorts.relayPorts">
            function <span class="apidocSignatureSpan">osc.</span>relayPorts
            <span class="apidocSignatureSpan">(from, to, o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.stopRelaying">module osc.stopRelaying</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.stopRelaying.stopRelaying">
            function <span class="apidocSignatureSpan">osc.</span>stopRelaying
            <span class="apidocSignatureSpan">(from, relaySpec)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.timeTag">module osc.timeTag</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.timeTag.timeTag">
            function <span class="apidocSignatureSpan">osc.</span>timeTag
            <span class="apidocSignatureSpan">(secs, now)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writeArgument">module osc.writeArgument</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeArgument.writeArgument">
            function <span class="apidocSignatureSpan">osc.</span>writeArgument
            <span class="apidocSignatureSpan">(arg, dataCollection)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writeArguments">module osc.writeArguments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeArguments.writeArguments">
            function <span class="apidocSignatureSpan">osc.</span>writeArguments
            <span class="apidocSignatureSpan">(args, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writeArrayArguments">module osc.writeArrayArguments</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeArrayArguments.writeArrayArguments">
            function <span class="apidocSignatureSpan">osc.</span>writeArrayArguments
            <span class="apidocSignatureSpan">(args, dataCollection)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writeBlob">module osc.writeBlob</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeBlob.writeBlob">
            function <span class="apidocSignatureSpan">osc.</span>writeBlob
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writeBundle">module osc.writeBundle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeBundle.writeBundle">
            function <span class="apidocSignatureSpan">osc.</span>writeBundle
            <span class="apidocSignatureSpan">(bundle, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writeChar32">module osc.writeChar32</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeChar32.writeChar32">
            function <span class="apidocSignatureSpan">osc.</span>writeChar32
            <span class="apidocSignatureSpan">(str, dv, offset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writeColor">module osc.writeColor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeColor.writeColor">
            function <span class="apidocSignatureSpan">osc.</span>writeColor
            <span class="apidocSignatureSpan">(color)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writeFloat32">module osc.writeFloat32</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeFloat32.writeFloat32">
            function <span class="apidocSignatureSpan">osc.</span>writeFloat32
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writeFloat64">module osc.writeFloat64</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeFloat64.writeFloat64">
            function <span class="apidocSignatureSpan">osc.</span>writeFloat64
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writeInt32">module osc.writeInt32</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeInt32.writeInt32">
            function <span class="apidocSignatureSpan">osc.</span>writeInt32
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writeInt64">module osc.writeInt64</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeInt64.writeInt64">
            function <span class="apidocSignatureSpan">osc.</span>writeInt64
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writeMIDIBytes">module osc.writeMIDIBytes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeMIDIBytes.writeMIDIBytes">
            function <span class="apidocSignatureSpan">osc.</span>writeMIDIBytes
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writeMessage">module osc.writeMessage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeMessage.writeMessage">
            function <span class="apidocSignatureSpan">osc.</span>writeMessage
            <span class="apidocSignatureSpan">(msg, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writePacket">module osc.writePacket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writePacket.writePacket">
            function <span class="apidocSignatureSpan">osc.</span>writePacket
            <span class="apidocSignatureSpan">(packet, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writePrimitive">module osc.writePrimitive</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writePrimitive.writePrimitive">
            function <span class="apidocSignatureSpan">osc.</span>writePrimitive
            <span class="apidocSignatureSpan">(val, dv, writerName, numBytes, offset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writeString">module osc.writeString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeString.writeString">
            function <span class="apidocSignatureSpan">osc.</span>writeString
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.writeTimeTag">module osc.writeTimeTag</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeTimeTag.writeTimeTag">
            function <span class="apidocSignatureSpan">osc.</span>writeTimeTag
            <span class="apidocSignatureSpan">(timeTag)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc" id="apidoc.module.osc">module osc</a></h1>










    <h2>
        <a href="#apidoc.element.osc.Gruntfile" id="apidoc.element.osc.Gruntfile">
        function <span class="apidocSignatureSpan">osc.</span>Gruntfile
        <span class="apidocSignatureSpan">(grunt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Gruntfile = function (grunt) {

    var files = {
        moduleDeps: [
            "node_modules/long/dist/long.js",
            "node_modules/slip/src/slip.js",
            "node_modules/wolfy87-eventemitter/EventEmitter.js"
        ],

        osc: [
            "src/osc.js"
        ],

        oscWeb: [
            "src/osc-transports.js",
            "src/platforms/osc-websocket-client.js"
        ],

        oscChrome: [
            "src/platforms/osc-chromeapp.js"
        ],

        moduleHeader: [
            "build-support/js/module-header.js"
        ],

        moduleFooter: [
            "build-support/js/module-footer.js"
        ]
    };

    grunt.initConfig({
        pkg: grunt.file.readJSON("package.json"),

        jshint: {
            all: ["src/*.js", "tests/**/*.js", "!**/node_modules/**"],
            options: {
                jshintrc: true
            }
        },

        concat: {
            options: {
                separator: ";",
                banner: "&lt;%= oscjs.banners.short %&gt;"
            },

            base: {
                src: [].concat(files.osc),
                dest: "dist/&lt;%= pkg.name %&gt;.js"
            },

            browser: {
                src: [].concat(files.osc, files.moduleDeps, files.oscWeb),
                dest: "dist/&lt;%= pkg.name %&gt;-browser.js"
            },

            chromeapp: {
                src: [].concat(files.osc, files.moduleDeps, files.oscWeb, files.oscChrome),
                dest: "dist/&lt;%= pkg.name %&gt;-chromeapp.js"
            },

            module: {
                src: [].concat(files.moduleHeader, files.osc, files.oscWeb, files.moduleFooter),
                dest: "dist/&lt;%= pkg.name %&gt;-module.js"
            }
        },

        uglify: {
            options: {
                banner: "&lt;%= oscjs.banners.short %&gt;",
                beautify: {
                    ascii_only: true
                }
            },
            all: {
                files: [
                    {
                        expand: true,
                        cwd: "dist/",
                        src: ["*.js"],
                        dest: "dist/",
                        ext: ".min.js",
                    }
                ]
            }
        },

        clean: {
            all: {
                src: ["dist/"]
            }
        },

        oscjs: {
            banners: {
                short: "/*! osc.js &lt;%= pkg.version %&gt;, " +
                    "Copyright &lt;%= grunt.template.today('yyyy') %&gt; Colin Clark | " +
                    "github.com/colinbdclark/osc.js */\n\n"
            }
        }
    });

    // Load relevant Grunt plugins.
    grunt.loadNpmTasks("grunt-contrib-concat");
    grunt.loadNpmTasks("grunt-contrib-uglify");
    grunt.loadNpmTasks("grunt-contrib-clean");
    grunt.loadNpmTasks("grunt-contrib-jshint");

    grunt.registerTask("default", ["clean", "jshint", "concat", "uglify"]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Port" id="apidoc.element.osc.Port">
        function <span class="apidocSignatureSpan">osc.</span>Port
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Port = function (options) {
    this.options = options || {};
    this.on("data", this.decodeOSC.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Port.prototype.decodeOSC" id="apidoc.element.osc.Port.prototype.decodeOSC">
        function <span class="apidocSignatureSpan">osc.</span>Port.prototype.decodeOSC
        <span class="apidocSignatureSpan">(data, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Port.prototype.decodeOSC = function (data, packetInfo) {
    data = osc.byteArray(data);
    this.emit("raw", data, packetInfo);

    try {
        var packet = osc.readPacket(data, this.options);
        this.emit("osc", packet, packetInfo);
        osc.firePacketEvents(this, packet, undefined, packetInfo);
    } catch (err) {
        this.emit("error", err);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Port.prototype.encodeOSC" id="apidoc.element.osc.Port.prototype.encodeOSC">
        function <span class="apidocSignatureSpan">osc.</span>Port.prototype.encodeOSC
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Port.prototype.encodeOSC = function (packet) {
    // TODO gh-39: This is unsafe; we should only access the underlying
    // buffer within the range of its view.
    packet = packet.buffer ? packet.buffer : packet;
    var encoded;

    try {
        encoded = osc.writePacket(packet, this.options);
    } catch (err) {
        this.emit("error", err);
    }

    return encoded;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Port.prototype.send" id="apidoc.element.osc.Port.prototype.send">
        function <span class="apidocSignatureSpan">osc.</span>Port.prototype.send
        <span class="apidocSignatureSpan">(oscPacket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Port.prototype.send = function (oscPacket) {
    var args = Array.prototype.slice.call(arguments),
        encoded = this.encodeOSC(oscPacket),
        buf = osc.nativeBuffer(encoded);

    args[0] = buf;
    this.sendRaw.apply(this, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Relay" id="apidoc.element.osc.Relay">
        function <span class="apidocSignatureSpan">osc.</span>Relay
        <span class="apidocSignatureSpan">(port1, port2, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Relay = function (port1, port2, options) {
    var o = this.options = options || {};
    o.raw = false;

    this.port1 = port1;
    this.port2 = port2;

    this.listen();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Relay.prototype.close" id="apidoc.element.osc.Relay.prototype.close">
        function <span class="apidocSignatureSpan">osc.</span>Relay.prototype.close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Relay.prototype.close = function () {
    osc.stopRelaying(this.port1, this.port1Spec);
    osc.stopRelaying(this.port2, this.port2Spec);
    this.emit("close", this.port1, this.port2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Relay.prototype.listen" id="apidoc.element.osc.Relay.prototype.listen">
        function <span class="apidocSignatureSpan">osc.</span>Relay.prototype.listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Relay.prototype.listen = function () {
    if (this.port1Spec &amp;&amp; this.port2Spec) {
        this.close();
    }

    this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
    this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

    // Bind port close listeners to ensure that the relay
    // will stop forwarding messages if one of its ports close.
    // Users are still responsible for closing the underlying ports
    // if necessary.
    var closeListener = this.close.bind(this);
    this.port1.on("close", closeListener);
    this.port2.on("close", closeListener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Relay.prototype.open" id="apidoc.element.osc.Relay.prototype.open">
        function <span class="apidocSignatureSpan">osc.</span>Relay.prototype.open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Relay.prototype.open = function () {
    this.port1.open();
    this.port2.open();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SLIPPort" id="apidoc.element.osc.SLIPPort">
        function <span class="apidocSignatureSpan">osc.</span>SLIPPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SLIPPort = function (options) {
    var that = this;
    var o = this.options = options || {};
    o.useSLIP = o.useSLIP === undefined ? true : o.useSLIP;

    this.decoder = new slip.Decoder({
        onMessage: this.decodeOSC.bind(this),
        onError: function (err) {
            that.emit("error", err);
        }
    });

    var decodeHandler = o.useSLIP ? this.decodeSLIPData : this.decodeOSC;
    this.on("data", decodeHandler.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SLIPPort.prototype.decodeSLIPData" id="apidoc.element.osc.SLIPPort.prototype.decodeSLIPData">
        function <span class="apidocSignatureSpan">osc.</span>SLIPPort.prototype.decodeSLIPData
        <span class="apidocSignatureSpan">(data, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SLIPPort.prototype.decodeSLIPData = function (data, packetInfo) {
    // TODO: Get packetInfo through SLIP decoder.
    this.decoder.decode(data, packetInfo);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SLIPPort.prototype.encodeOSC" id="apidoc.element.osc.SLIPPort.prototype.encodeOSC">
        function <span class="apidocSignatureSpan">osc.</span>SLIPPort.prototype.encodeOSC
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SLIPPort.prototype.encodeOSC = function (packet) {
    // TODO gh-39: This is unsafe; we should only access the underlying
    // buffer within the range of its view.
    packet = packet.buffer ? packet.buffer : packet;
    var framed;

    try {
        var encoded = osc.writePacket(packet, this.options);
        framed = slip.encode(encoded);
    } catch (err) {
        this.emit("error", err);
    }

    return framed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SerialPort" id="apidoc.element.osc.SerialPort">
        function <span class="apidocSignatureSpan">osc.</span>SerialPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SerialPort = function (options) {
    this.on("open", this.listen.bind(this));
    osc.SLIPPort.call(this, options);
    this.options.bitrate = this.options.bitrate || 9600;

    this.serialPort = options.serialPort;
    if (this.serialPort) {
        this.emit("open", this.serialPort);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
}
```

#### Connecting to the serial port and listening for OSC messages
```javascript
// Instantiate a new OSC Serial Port.
var serialPort = new osc.<span class="apidocCodeKeywordSpan">SerialPort</span>({
    devicePath: "/dev/cu.usbmodem22131"
});

// Listen for the message event and map the OSC message to the synth.
serialPort.on("message", function (oscMsg) {
    console.log("An OSC message was received!", oscMsg);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.close" id="apidoc.element.osc.SerialPort.prototype.close">
        function <span class="apidocSignatureSpan">osc.</span>SerialPort.prototype.close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SerialPort.prototype.close = function () {
    if (this.serialPort) {
        this.serialPort.close();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.listen" id="apidoc.element.osc.SerialPort.prototype.listen">
        function <span class="apidocSignatureSpan">osc.</span>SerialPort.prototype.listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SerialPort.prototype.listen = function () {
    var that = this;

    this.serialPort.on("data", function (data) {
        that.emit("data", data, undefined);
    });

    this.serialPort.on("error", function (err) {
        that.emit("error", err);
    });

    this.serialPort.on("close", function (err) {
        if (err) {
            that.emit("error", err);
        } else {
            that.emit("close");
        }
    });

    that.emit("ready");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.open" id="apidoc.element.osc.SerialPort.prototype.open">
        function <span class="apidocSignatureSpan">osc.</span>SerialPort.prototype.open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SerialPort.prototype.open = function () {
    if (this.serialPort) {
        // If we already have a serial port, close it and open a new one.
        this.once("close", this.open.bind(this));
        this.close();
        return;
    }

    var that = this;

    this.serialPort = new SerialPort(this.options.devicePath, {
        baudrate: this.options.bitrate,
        autoOpen: false
    });

    this.serialPort.open(function() {
        that.emit("open", that.serialPort);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.sendRaw" id="apidoc.element.osc.SerialPort.prototype.sendRaw">
        function <span class="apidocSignatureSpan">osc.</span>SerialPort.prototype.sendRaw
        <span class="apidocSignatureSpan">(encoded)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SerialPort.prototype.sendRaw = function (encoded) {
    if (!this.serialPort || !this.serialPort.isOpen()) {
        osc.fireClosedPortSendError(this);
        return;
    }

    var that = this;
    this.serialPort.write(encoded, function (err) {
        if (err) {
            that.emit("error", err);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort" id="apidoc.element.osc.TCPSocketPort">
        function <span class="apidocSignatureSpan">osc.</span>TCPSocketPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TCPSocketPort = function (options) {
    osc.SLIPPort.call(this, options);

    var o = this.options;
    o.localAddress = o.localAddress || "127.0.0.1";
    o.localPort = o.localPort !== undefined ? o.localPort : 57121;

    this.on("open", this.listen.bind(this));
    this.socket = options.socket;

    if (this.socket) {
        this.emit("open", this.socket);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.close" id="apidoc.element.osc.TCPSocketPort.prototype.close">
        function <span class="apidocSignatureSpan">osc.</span>TCPSocketPort.prototype.close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TCPSocketPort.prototype.close = function () {
    this.socket.end();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.listen" id="apidoc.element.osc.TCPSocketPort.prototype.listen">
        function <span class="apidocSignatureSpan">osc.</span>TCPSocketPort.prototype.listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TCPSocketPort.prototype.listen = function () {
    var that = this;
    this.socket.on("data", function (msg) {
        that.emit("data", msg, undefined);
    });

    this.socket.on("error", function (err) {
        that.emit("error", err);
    });

    this.socket.on("close", function (err) {
        if (err) {
            that.emit("error", err);
        } else {
            that.emit("close");
        }
    });

    this.socket.on("connect", function () {
        that.emit("ready");
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.open" id="apidoc.element.osc.TCPSocketPort.prototype.open">
        function <span class="apidocSignatureSpan">osc.</span>TCPSocketPort.prototype.open
        <span class="apidocSignatureSpan">(address, port)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TCPSocketPort.prototype.open = function (address, port) {
    var o = this.options;
    address = address || o.address;
    port = port !== undefined ? port : o.port;

    if (!this.socket) {
        this.socket = net.connect({
            port: port,
            host: address
        });
    } else {
        this.socket.connect(port, address);
    }

    this.emit("open", this.socket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.sendRaw" id="apidoc.element.osc.TCPSocketPort.prototype.sendRaw">
        function <span class="apidocSignatureSpan">osc.</span>TCPSocketPort.prototype.sendRaw
        <span class="apidocSignatureSpan">(encoded)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TCPSocketPort.prototype.sendRaw = function (encoded) {
    if (!this.socket) {
        return;
    }

    encoded = new Buffer(encoded);

    try {
        this.socket.write(encoded);
    } catch (err) {
        this.emit("error", err);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort" id="apidoc.element.osc.UDPPort">
        function <span class="apidocSignatureSpan">osc.</span>UDPPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UDPPort = function (options) {
    osc.Port.call(this, options);

    this.options.localAddress = this.options.localAddress || "127.0.0.1";
    this.options.localPort = this.options.localPort !== undefined ?
        this.options.localPort : 57121;

    this.options.remoteAddress = this.options.remoteAddress || "127.0.0.1";
    this.options.remotePort = this.options.remotePort !== undefined ?
        this.options.remotePort : 57121;

    this.on("open", this.listen.bind(this));

    this.socket = options.socket;
    if (this.socket) {
        this.emit("open", this.socket);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;/tr&gt;
&lt;/table&gt;

#### Sample Code

```javascript
// Create an osc.js UDP Port listening on port 57121.
var udpPort = new osc.<span class="apidocCodeKeywordSpan">UDPPort</span>({
localAddress: "0.0.0.0",
localPort: 57121
});

// Listen for incoming OSC bundles.
udpPort.on("bundle", function (oscBundle, timeTag, info) {
console.log("An OSC bundle just arrived for time tag", timeTag, ":", oscBundle);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.close" id="apidoc.element.osc.UDPPort.prototype.close">
        function <span class="apidocSignatureSpan">osc.</span>UDPPort.prototype.close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UDPPort.prototype.close = function () {
    if (this.socket) {
        this.socket.close();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.listen" id="apidoc.element.osc.UDPPort.prototype.listen">
        function <span class="apidocSignatureSpan">osc.</span>UDPPort.prototype.listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UDPPort.prototype.listen = function () {
    if (!this.socket) {
        return;
    }

    var that = this;
    this.socket.on("message", function (msg, rinfo) {
        that.emit("data", msg, rinfo);
    });

    this.socket.on("error", function (error) {
        that.emit("error", error);
    });

    this.socket.on("close", function () {
        that.emit("close");
    });

    that.emit("ready");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.open" id="apidoc.element.osc.UDPPort.prototype.open">
        function <span class="apidocSignatureSpan">osc.</span>UDPPort.prototype.open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UDPPort.prototype.open = function () {
    var that = this;

    if (this.socket) {
        return;
    }

    this.socket = dgram.createSocket("udp4");

    function onBound() {
        osc.UDPPort.setupMulticast(that);

        if (that.options.broadcast) {
            that.socket.setBroadcast(that.options.broadcast);
        }

        that.emit("open", that.socket);
    }

    this.socket.bind(this.options.localPort, this.options.localAddress, onBound);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.sendRaw" id="apidoc.element.osc.UDPPort.prototype.sendRaw">
        function <span class="apidocSignatureSpan">osc.</span>UDPPort.prototype.sendRaw
        <span class="apidocSignatureSpan">(encoded, address, port)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UDPPort.prototype.sendRaw = function (encoded, address, port) {
    if (!this.socket) {
        osc.fireClosedPortSendError(this);
        return;
    }

    var length = encoded.byteLength !== undefined ? encoded.byteLength : encoded.length,
        that = this;

    address = address || this.options.remoteAddress;
    port = port !== undefined ? port : this.options.remotePort;

    this.socket.send(encoded, 0, length, port, address, function (err) {
        if (err) {
            that.emit("error", err);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort.setupMulticast" id="apidoc.element.osc.UDPPort.setupMulticast">
        function <span class="apidocSignatureSpan">osc.</span>UDPPort.setupMulticast
        <span class="apidocSignatureSpan">(that)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UDPPort.setupMulticast = function (that) {
    if (that.options.multicastTTL !== undefined) {
        that.socket.setMulticastTTL(that.options.multicastTTL);
    }

    if (that.options.multicastMembership) {
        if (typeof that.options.multicastMembership === "string") {
            that.options.multicastMembership = [that.options.multicastMembership];
        }

        that.options.multicastMembership.forEach(function (addr) {
            if (typeof addr === "string") {
              that.socket.addMembership(addr);
            } else {
              that.socket.addMembership(addr.address, addr.interface);
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket" id="apidoc.element.osc.WebSocket">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket
        <span class="apidocSignatureSpan">(address, protocols, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocket(address, protocols, options) {
  if (this instanceof WebSocket === false) {
    return new WebSocket(address, protocols, options);
  }

  EventEmitter.call(this);

  if (protocols &amp;&amp; !Array.isArray(protocols) &amp;&amp; 'object' === typeof protocols) {
    // accept the "options" Object as the 2nd argument
    options = protocols;
    protocols = null;
  }

  if ('string' === typeof protocols) {
    protocols = [ protocols ];
  }

  if (!Array.isArray(protocols)) {
    protocols = [];
  }

  this._socket = null;
  this._ultron = null;
  this._closeReceived = false;
  this.bytesReceived = 0;
  this.readyState = null;
  this.supports = {};
  this.extensions = {};
  this._binaryType = 'nodebuffer';

  if (Array.isArray(address)) {
    initAsServerClient.apply(this, address.concat(options));
  } else {
    initAsClient.apply(this, [address, protocols, options]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver" id="apidoc.element.osc.WebSocket.Receiver">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver
        <span class="apidocSignatureSpan">(extensions, maxPayload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Receiver(extensions, maxPayload) {
  if (this instanceof Receiver === false) {
    throw new TypeError("Classes can't be function-called");
  }
  if(typeof extensions==='number'){
    maxPayload=extensions;
    extensions={};
  }


  // memory pool for fragmented messages
  var fragmentedPoolPrevUsed = -1;
  this.fragmentedBufferPool = new BufferPool(1024, function(db, length) {
    return db.used + length;
  }, function(db) {
    return fragmentedPoolPrevUsed = fragmentedPoolPrevUsed &gt;= 0 ?
      Math.ceil((fragmentedPoolPrevUsed + db.used) / 2) :
      db.used;
  });

  // memory pool for unfragmented messages
  var unfragmentedPoolPrevUsed = -1;
  this.unfragmentedBufferPool = new BufferPool(1024, function(db, length) {
    return db.used + length;
  }, function(db) {
    return unfragmentedPoolPrevUsed = unfragmentedPoolPrevUsed &gt;= 0 ?
      Math.ceil((unfragmentedPoolPrevUsed + db.used) / 2) :
      db.used;
  });
  this.extensions = extensions || {};
  this.maxPayload = maxPayload || 0;
  this.currentPayloadLength = 0;
  this.state = {
    activeFragmentedOperation: null,
    lastFragment: false,
    masked: false,
    opcode: 0,
    fragmentedOperation: false
  };
  this.overflow = [];
  this.headerBuffer = new Buffer(10);
  this.expectOffset = 0;
  this.expectBuffer = null;
  this.expectHandler = null;
  this.currentMessage = [];
  this.currentMessageLength = 0;
  this.messageHandlers = [];
  this.expectHeader(2, this.processPacket);
  this.dead = false;
  this.processing = false;

  this.onerror = function() {};
  this.ontext = function() {};
  this.onbinary = function() {};
  this.onclose = function() {};
  this.onping = function() {};
  this.onpong = function() {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.add" id="apidoc.element.osc.WebSocket.Receiver.prototype.add">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.add
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Receiver.prototype.add = function (data) {
  if (this.dead) return;
  var dataLength = data.length;
  if (dataLength == 0) return;
  if (this.expectBuffer == null) {
    this.overflow.push(data);
    return;
  }
  var toRead = Math.min(dataLength, this.expectBuffer.length - this.expectOffset);
  fastCopy(toRead, data, this.expectBuffer, this.expectOffset);
  this.expectOffset += toRead;
  if (toRead &lt; dataLength) {
    this.overflow.push(data.slice(toRead));
  }
  while (this.expectBuffer &amp;&amp; this.expectOffset == this.expectBuffer.length) {
    var bufferForHandler = this.expectBuffer;
    this.expectBuffer = null;
    this.expectOffset = 0;
    this.expectHandler.call(this, bufferForHandler);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.allocateFromPool" id="apidoc.element.osc.WebSocket.Receiver.prototype.allocateFromPool">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.allocateFromPool
        <span class="apidocSignatureSpan">(length, isFragmented)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Receiver.prototype.allocateFromPool = function (length, isFragmented) {
  return (isFragmented ? this.fragmentedBufferPool : this.unfragmentedBufferPool).get(length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.applyExtensions" id="apidoc.element.osc.WebSocket.Receiver.prototype.applyExtensions">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.applyExtensions
        <span class="apidocSignatureSpan">(messageBuffer, fin, compressed, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Receiver.prototype.applyExtensions = function (messageBuffer, fin, compressed, callback) {
  var self = this;
  if (compressed) {
    this.extensions[PerMessageDeflate.extensionName].decompress(messageBuffer, fin, function(err, buffer) {
      if (self.dead) return;
      if (err) {
        callback(new Error('invalid compressed data'));
        return;
      }
      callback(null, buffer);
    });
  } else {
    callback(null, messageBuffer);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.cleanup" id="apidoc.element.osc.WebSocket.Receiver.prototype.cleanup">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.cleanup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Receiver.prototype.cleanup = function () {
  this.dead = true;
  this.overflow = null;
  this.headerBuffer = null;
  this.expectBuffer = null;
  this.expectHandler = null;
  this.unfragmentedBufferPool = null;
  this.fragmentedBufferPool = null;
  this.state = null;
  this.currentMessage = null;
  this.onerror = null;
  this.ontext = null;
  this.onbinary = null;
  this.onclose = null;
  this.onping = null;
  this.onpong = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.endPacket" id="apidoc.element.osc.WebSocket.Receiver.prototype.endPacket">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.endPacket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Receiver.prototype.endPacket = function () {
  if (this.dead) return;
  if (!this.state.fragmentedOperation) this.unfragmentedBufferPool.reset(true);
  else if (this.state.lastFragment) this.fragmentedBufferPool.reset(true);
  this.expectOffset = 0;
  this.expectBuffer = null;
  this.expectHandler = null;
  if (this.state.lastFragment &amp;&amp; this.state.opcode === this.state.activeFragmentedOperation) {
    // end current fragmented operation
    this.state.activeFragmentedOperation = null;
  }
  this.currentPayloadLength = 0;
  this.state.lastFragment = false;
  this.state.opcode = this.state.activeFragmentedOperation != null ? this.state.activeFragmentedOperation : 0;
  this.state.masked = false;
  this.expectHeader(2, this.processPacket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.error" id="apidoc.element.osc.WebSocket.Receiver.prototype.error">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.error
        <span class="apidocSignatureSpan">(reason, protocolErrorCode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Receiver.prototype.error = function (reason, protocolErrorCode) {
  if (this.dead) return;
  this.reset();
  if(typeof reason == 'string'){
    this.onerror(new Error(reason), protocolErrorCode);
  }
  else if(reason.constructor == Error){
    this.onerror(reason, protocolErrorCode);
  }
  else{
    this.onerror(new Error("An error occured"),protocolErrorCode);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.expectData" id="apidoc.element.osc.WebSocket.Receiver.prototype.expectData">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.expectData
        <span class="apidocSignatureSpan">(length, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Receiver.prototype.expectData = function (length, handler) {
  if (length == 0) {
    handler(null);
    return;
  }
  this.expectBuffer = this.allocateFromPool(length, this.state.fragmentedOperation);
  this.expectHandler = handler;
  var toRead = length;
  while (toRead &gt; 0 &amp;&amp; this.overflow.length &gt; 0) {
    var fromOverflow = this.overflow.pop();
    if (toRead &lt; fromOverflow.length) this.overflow.push(fromOverflow.slice(toRead));
    var read = Math.min(fromOverflow.length, toRead);
    fastCopy(read, fromOverflow, this.expectBuffer, this.expectOffset);
    this.expectOffset += read;
    toRead -= read;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.expectHeader" id="apidoc.element.osc.WebSocket.Receiver.prototype.expectHeader">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.expectHeader
        <span class="apidocSignatureSpan">(length, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Receiver.prototype.expectHeader = function (length, handler) {
  if (length == 0) {
    handler(null);
    return;
  }
  this.expectBuffer = this.headerBuffer.slice(this.expectOffset, this.expectOffset + length);
  this.expectHandler = handler;
  var toRead = length;
  while (toRead &gt; 0 &amp;&amp; this.overflow.length &gt; 0) {
    var fromOverflow = this.overflow.pop();
    if (toRead &lt; fromOverflow.length) this.overflow.push(fromOverflow.slice(toRead));
    var read = Math.min(fromOverflow.length, toRead);
    fastCopy(read, fromOverflow, this.expectBuffer, this.expectOffset);
    this.expectOffset += read;
    toRead -= read;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.flush" id="apidoc.element.osc.WebSocket.Receiver.prototype.flush">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Receiver.prototype.flush = function () {
  if (this.processing || this.dead) return;

  var handler = this.messageHandlers.shift();
  if (!handler) return;

  this.processing = true;
  var self = this;

  handler(function() {
    self.processing = false;
    self.flush();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.maxPayloadExceeded" id="apidoc.element.osc.WebSocket.Receiver.prototype.maxPayloadExceeded">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.maxPayloadExceeded
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Receiver.prototype.maxPayloadExceeded = function (length) {
  if (this.maxPayload=== undefined || this.maxPayload === null || this.maxPayload &lt; 1) {
    return false;
  }
  var fullLength = this.currentPayloadLength + length;
  if (fullLength &lt; this.maxPayload) {
    this.currentPayloadLength = fullLength;
    return false;
  }
  this.error('payload cannot exceed ' + this.maxPayload + ' bytes', 1009);
  this.messageBuffer=[];
  this.cleanup();

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.processPacket" id="apidoc.element.osc.WebSocket.Receiver.prototype.processPacket">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.processPacket
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Receiver.prototype.processPacket = function (data) {
  if (this.extensions[PerMessageDeflate.extensionName]) {
    if ((data[0] &amp; 0x30) != 0) {
      this.error('reserved fields (2, 3) must be empty', 1002);
      return;
    }
  } else {
    if ((data[0] &amp; 0x70) != 0) {
      this.error('reserved fields must be empty', 1002);
      return;
    }
  }
  this.state.lastFragment = (data[0] &amp; 0x80) == 0x80;
  this.state.masked = (data[1] &amp; 0x80) == 0x80;
  var compressed = (data[0] &amp; 0x40) == 0x40;
  var opcode = data[0] &amp; 0xf;
  if (opcode === 0) {
    if (compressed) {
      this.error('continuation frame cannot have the Per-message Compressed bits', 1002);
      return;
    }
    // continuation frame
    this.state.fragmentedOperation = true;
    this.state.opcode = this.state.activeFragmentedOperation;
    if (!(this.state.opcode == 1 || this.state.opcode == 2)) {
      this.error('continuation frame cannot follow current opcode', 1002);
      return;
    }
  }
  else {
    if (opcode &lt; 3 &amp;&amp; this.state.activeFragmentedOperation != null) {
      this.error('data frames after the initial data frame must have opcode 0', 1002);
      return;
    }
    if (opcode &gt;= 8 &amp;&amp; compressed) {
      this.error('control frames cannot have the Per-message Compressed bits', 1002);
      return;
    }
    this.state.compressed = compressed;
    this.state.opcode = opcode;
    if (this.state.lastFragment === false) {
      this.state.fragmentedOperation = true;
      this.state.activeFragmentedOperation = opcode;
    }
    else this.state.fragmentedOperation = false;
  }
  var handler = opcodes[this.state.opcode];
  if (typeof handler == 'undefined') this.error('no handler for opcode ' + this.state.opcode, 1002);
  else {
    handler.start.call(this, data);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.reset" id="apidoc.element.osc.WebSocket.Receiver.prototype.reset">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Receiver.prototype.reset = function () {
  if (this.dead) return;
  this.state = {
    activeFragmentedOperation: null,
    lastFragment: false,
    masked: false,
    opcode: 0,
    fragmentedOperation: false
  };
  this.fragmentedBufferPool.reset(true);
  this.unfragmentedBufferPool.reset(true);
  this.expectOffset = 0;
  this.expectBuffer = null;
  this.expectHandler = null;
  this.overflow = [];
  this.currentMessage = [];
  this.currentMessageLength = 0;
  this.messageHandlers = [];
  this.currentPayloadLength = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.unmask" id="apidoc.element.osc.WebSocket.Receiver.prototype.unmask">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype.unmask
        <span class="apidocSignatureSpan">(mask, buf, binary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Receiver.prototype.unmask = function (mask, buf, binary) {
  if (mask != null &amp;&amp; buf != null) bufferUtil.unmask(buf, mask);
  if (binary) return buf;
  return buf != null ? buf.toString('utf8') : '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender" id="apidoc.element.osc.WebSocket.Sender">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender
        <span class="apidocSignatureSpan">(socket, extensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Sender(socket, extensions) {
  if (this instanceof Sender === false) {
    throw new TypeError("Classes can't be function-called");
  }

  events.EventEmitter.call(this);

  this._socket = socket;
  this.extensions = extensions || {};
  this.firstFragment = true;
  this.compress = false;
  this.messageHandlers = [];
  this.processing = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.applyExtensions" id="apidoc.element.osc.WebSocket.Sender.prototype.applyExtensions">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender.prototype.applyExtensions
        <span class="apidocSignatureSpan">(data, fin, compress, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Sender.prototype.applyExtensions = function (data, fin, compress, callback) {
  if (compress &amp;&amp; data) {
    if ((data.buffer || data) instanceof ArrayBuffer) {
      data = getArrayBuffer(data);
    }
    this.extensions[PerMessageDeflate.extensionName].compress(data, fin, callback);
  } else {
    callback(null, data);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.close" id="apidoc.element.osc.WebSocket.Sender.prototype.close">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender.prototype.close
        <span class="apidocSignatureSpan">(code, data, mask, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Sender.prototype.close = function (code, data, mask, cb) {
  if (typeof code !== 'undefined') {
    if (typeof code !== 'number' ||
      !ErrorCodes.isValidErrorCode(code)) throw new Error('first argument must be a valid error code number');
  }
  code = code || 1000;
  var dataBuffer = new Buffer(2 + (data ? Buffer.byteLength(data) : 0));
  writeUInt16BE.call(dataBuffer, code, 0);
  if (dataBuffer.length &gt; 2) dataBuffer.write(data, 2);

  var self = this;
  this.messageHandlers.push(function(callback) {
    self.frameAndSend(0x8, dataBuffer, true, mask);
    callback();
    if (typeof cb == 'function') cb();
  });
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.flush" id="apidoc.element.osc.WebSocket.Sender.prototype.flush">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender.prototype.flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Sender.prototype.flush = function () {
  if (this.processing) return;

  var handler = this.messageHandlers.shift();
  if (!handler) return;

  this.processing = true;

  var self = this;

  handler(function() {
    self.processing = false;
    self.flush();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.frameAndSend" id="apidoc.element.osc.WebSocket.Sender.prototype.frameAndSend">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender.prototype.frameAndSend
        <span class="apidocSignatureSpan">(opcode, data, finalFragment, maskData, compressed, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Sender.prototype.frameAndSend = function (opcode, data, finalFragment, maskData, compressed, cb) {
  var canModifyData = false;

  if (!data) {
    try {
      this._socket.write(new Buffer([opcode | (finalFragment ? 0x80 : 0), 0 | (maskData ? 0x80 : 0)].concat(maskData ? [0, 0, 0,
0] : [])), 'binary', cb);
    }
    catch (e) {
      if (typeof cb == 'function') cb(e);
      else this.emit('error', e);
    }
    return;
  }

  if (!Buffer.isBuffer(data)) {
    canModifyData = true;
    if (data &amp;&amp; (typeof data.byteLength !== 'undefined' || typeof data.buffer !== 'undefined')) {
      data = getArrayBuffer(data);
    } else {
      //
      // If people want to send a number, this would allocate the number in
      // bytes as memory size instead of storing the number as buffer value. So
      // we need to transform it to string in order to prevent possible
      // vulnerabilities / memory attacks.
      //
      if (typeof data === 'number') data = data.toString();

      data = new Buffer(data);
    }
  }

  var dataLength = data.length
    , dataOffset = maskData ? 6 : 2
    , secondByte = dataLength;

  if (dataLength &gt;= 65536) {
    dataOffset += 8;
    secondByte = 127;
  }
  else if (dataLength &gt; 125) {
    dataOffset += 2;
    secondByte = 126;
  }

  var mergeBuffers = dataLength &lt; 32768 || (maskData &amp;&amp; !canModifyData);
  var totalLength = mergeBuffers ? dataLength + dataOffset : dataOffset;
  var outputBuffer = new Buffer(totalLength);
  outputBuffer[0] = finalFragment ? opcode | 0x80 : opcode;
  if (compressed) outputBuffer[0] |= 0x40;

  switch (secondByte) {
    case 126:
      writeUInt16BE.call(outputBuffer, dataLength, 2);
      break;
    case 127:
      writeUInt32BE.call(outputBuffer, 0, 2);
      writeUInt32BE.call(outputBuffer, dataLength, 6);
  }

  if (maskData) {
    outputBuffer[1] = secondByte | 0x80;
    var mask = getRandomMask();
    outputBuffer[dataOffset - 4] = mask[0];
    outputBuffer[dataOffset - 3] = mask[1];
    outputBuffer[dataOffset - 2] = mask[2];
    outputBuffer[dataOffset - 1] = mask[3];
    if (mergeBuffers) {
      bufferUtil.mask(data, mask, outputBuffer, dataOffset, dataLength);
      try {
        this._socket.write(outputBuffer, 'binary', cb);
      }
      catch (e) {
        if (typeof cb == 'function') cb(e);
        else this.emit('error', e);
      }
    }
    else {
      bufferUtil.mask(data, mask, data, 0, dataLength);
      try {
        this._socket.write(outputBuffer, 'binary');
        this._socket.write(data, 'binary', cb);
      }
      catch (e) {
        if (typeof cb == 'function') cb(e);
        else this.emit('error', e);
      }
    }
  }
  else {
    outputBuffer[1] = secondByte;
    if (mergeBuffers) {
      data.copy(outputBuffer, dataOffset);
      try {
        this._socket.write(outputBuffer, 'binary', cb);
      }
      catch (e) {
        if (typeof cb == 'function') cb(e);
        else this.emit('error', e);
      }
    }
    else {
      try {
        this._socket.write(outputBuffer, 'binary');
        this._socket.write(data, 'binary', cb);
      }
      catch (e) {
        if (typeof cb == 'function') cb(e);
        else this.emit('error', e);
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.ping" id="apidoc.element.osc.WebSocket.Sender.prototype.ping">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender.prototype.ping
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Sender.prototype.ping = function (data, options) {
  var mask = options &amp;&amp; options.mask;
  var self = this;
  this.messageHandlers.push(function(callback) {
    self.frameAndSend(0x9, data || '', true, mask);
    callback();
  });
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.pong" id="apidoc.element.osc.WebSocket.Sender.prototype.pong">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender.prototype.pong
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Sender.prototype.pong = function (data, options) {
  var mask = options &amp;&amp; options.mask;
  var self = this;
  this.messageHandlers.push(function(callback) {
    self.frameAndSend(0xa, data || '', true, mask);
    callback();
  });
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.send" id="apidoc.element.osc.WebSocket.Sender.prototype.send">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender.prototype.send
        <span class="apidocSignatureSpan">(data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Sender.prototype.send = function (data, options, cb) {
  var finalFragment = options &amp;&amp; options.fin === false ? false : true;
  var mask = options &amp;&amp; options.mask;
  var compress = options &amp;&amp; options.compress;
  var opcode = options &amp;&amp; options.binary ? 2 : 1;
  if (this.firstFragment === false) {
    opcode = 0;
    compress = false;
  } else {
    this.firstFragment = false;
    this.compress = compress;
  }
  if (finalFragment) this.firstFragment = true

  var compressFragment = this.compress;

  var self = this;
  this.messageHandlers.push(function(callback) {
    self.applyExtensions(data, finalFragment, compressFragment, function(err, data) {
      if (err) {
        if (typeof cb == 'function') cb(err);
        else self.emit('error', err);
        return;
      }
      self.frameAndSend(opcode, data, finalFragment, mask, compress, cb);
      callback();
    });
  });
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Server" id="apidoc.element.osc.WebSocket.Server">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Server
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketServer(options, callback) {
  if (this instanceof WebSocketServer === false) {
    return new WebSocketServer(options, callback);
  }

  events.EventEmitter.call(this);

  options = new Options({
    host: '0.0.0.0',
    port: null,
    server: null,
    verifyClient: null,
    handleProtocols: null,
    path: null,
    noServer: false,
    disableHixie: false,
    clientTracking: true,
    perMessageDeflate: true,
    maxPayload: 100 * 1024 * 1024
  }).merge(options);

  if (!options.isDefinedAndNonNull('port') &amp;&amp; !options.isDefinedAndNonNull('server') &amp;&amp; !options.value.noServer) {
    throw new TypeError('`port` or a `server` must be provided');
  }

  var self = this;

  if (options.isDefinedAndNonNull('port')) {
    this._server = http.createServer(function (req, res) {
      var body = http.STATUS_CODES[426];
      res.writeHead(426, {
        'Content-Length': body.length,
        'Content-Type': 'text/plain'
      });
      res.end(body);
    });
    this._server.allowHalfOpen = false;
    this._server.listen(options.value.port, options.value.host, callback);
    this._closeServer = function() { if (self._server) self._server.close(); };
  }
  else if (options.value.server) {
    this._server = options.value.server;
    if (options.value.path) {
      // take note of the path, to avoid collisions when multiple websocket servers are
      // listening on the same http server
      if (this._server._webSocketPaths &amp;&amp; options.value.server._webSocketPaths[options.value.path]) {
        throw new Error('two instances of WebSocketServer cannot listen on the same http server path');
      }
      if (typeof this._server._webSocketPaths !== 'object') {
        this._server._webSocketPaths = {};
      }
      this._server._webSocketPaths[options.value.path] = 1;
    }
  }
  if (this._server) {
    this._onceServerListening = function() { self.emit('listening'); };
    this._server.once('listening', this._onceServerListening);
  }

  if (typeof this._server != 'undefined') {
    this._onServerError = function(error) { self.emit('error', error) };
    this._server.on('error', this._onServerError);
    this._onServerUpgrade = function(req, socket, upgradeHead) {
      //copy upgradeHead to avoid retention of large slab buffers used in node core
      var head = new Buffer(upgradeHead.length);
      upgradeHead.copy(head);

      self.handleUpgrade(req, socket, head, function(client) {
        self.emit('connection'+req.url, client);
        self.emit('connection', client);
      });
    };
    this._server.on('upgrade', this._onServerUpgrade);
  }

  this.options = options.value;
  this.path = options.value.path;
  this.clients = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Server.prototype.close" id="apidoc.element.osc.WebSocket.Server.prototype.close">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Server.prototype.close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Server.prototype.close = function (callback) {
  // terminate all associated clients
  var error = null;
  try {
    for (var i = 0, l = this.clients.length; i &lt; l; ++i) {
      this.clients[i].terminate();
    }
  }
  catch (e) {
    error = e;
  }

  // remove path descriptor, if any
  if (this.path &amp;&amp; this._server._webSocketPaths) {
    delete this._server._webSocketPaths[this.path];
    if (Object.keys(this._server._webSocketPaths).length == 0) {
      delete this._server._webSocketPaths;
    }
  }

  // close the http server if it was internally created
  try {
    if (typeof this._closeServer !== 'undefined') {
      this._closeServer();
    }
  }
  finally {
    if (this._server) {
      this._server.removeListener('listening', this._onceServerListening);
      this._server.removeListener('error', this._onServerError);
      this._server.removeListener('upgrade', this._onServerUpgrade);
    }
    delete this._server;
  }
  if(callback)
    callback(error);
  else if(error)
    throw error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Server.prototype.handleUpgrade" id="apidoc.element.osc.WebSocket.Server.prototype.handleUpgrade">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Server.prototype.handleUpgrade
        <span class="apidocSignatureSpan">(req, socket, upgradeHead, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.Server.prototype.handleUpgrade = function (req, socket, upgradeHead, cb) {
  // check for wrong path
  if (this.options.path) {
    var u = url.parse(req.url);
    if (u &amp;&amp; u.pathname !== this.options.path) return;
  }

  if (typeof req.headers.upgrade === 'undefined' || req.headers.upgrade.toLowerCase() !== 'websocket') {
    abortConnection(socket, 400, 'Bad Request');
    return;
  }

  if (req.headers['sec-websocket-key1']) handleHixieUpgrade.apply(this, arguments);
  else handleHybiUpgrade.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.buildHostHeader" id="apidoc.element.osc.WebSocket.buildHostHeader">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.buildHostHeader
        <span class="apidocSignatureSpan">(isSecure, hostname, port)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildHostHeader(isSecure, hostname, port) {
  var headerHost = hostname;
  if (hostname) {
    if ((isSecure &amp;&amp; (port != 443)) || (!isSecure &amp;&amp; (port != 80))){
      headerHost = headerHost + ':' + port;
    }
  }
  return headerHost;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.createConnection" id="apidoc.element.osc.WebSocket.createConnection">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.createConnection
        <span class="apidocSignatureSpan">(address, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function connect(address, fn) {
  var client = new WS(address);

  if (typeof fn === 'function') {
    client.on('open', fn);
  }

  return client;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.createServer" id="apidoc.element.osc.WebSocket.createServer">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.createServer
        <span class="apidocSignatureSpan">(options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createServer(options, fn) {
  var server = new WS.Server(options);

  if (typeof fn === 'function') {
    server.on('connection', fn);
  }

  return server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.addEventListener" id="apidoc.element.osc.WebSocket.prototype.addEventListener">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.addEventListener
        <span class="apidocSignatureSpan">(method, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.prototype.addEventListener = function (method, listener) {
  var target = this;

  function onMessage (data, flags) {
    if (flags.binary &amp;&amp; this.binaryType === 'arraybuffer')
        data = new Uint8Array(data).buffer;
    listener.call(target, new MessageEvent(data, !!flags.binary, target));
  }

  function onClose (code, message) {
    listener.call(target, new CloseEvent(code, message, target));
  }

  function onError (event) {
    event.type = 'error';
    event.target = target;
    listener.call(target, event);
  }

  function onOpen () {
    listener.call(target, new OpenEvent(target));
  }

  if (typeof listener === 'function') {
    if (method === 'message') {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onMessage._listener = listener;
      this.on(method, onMessage);
    } else if (method === 'close') {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onClose._listener = listener;
      this.on(method, onClose);
    } else if (method === 'error') {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onError._listener = listener;
      this.on(method, onError);
    } else if (method === 'open') {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onOpen._listener = listener;
      this.on(method, onOpen);
    } else {
      this.on(method, listener);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.close" id="apidoc.element.osc.WebSocket.prototype.close">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.close
        <span class="apidocSignatureSpan">(code, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function close(code, data) {
  if (this.readyState === WebSocket.CLOSED) return;

  if (this.readyState === WebSocket.CONNECTING) {
    this.readyState = WebSocket.CLOSED;
    return;
  }

  if (this.readyState === WebSocket.CLOSING) {
    if (this._closeReceived &amp;&amp; this._isServer) {
      this.terminate();
    }
    return;
  }

  var self = this;
  try {
    this.readyState = WebSocket.CLOSING;
    this._closeCode = code;
    this._closeMessage = data;
    var mask = !this._isServer;
    this._sender.close(code, data, mask, function(err) {
      if (err) self.emit('error', err);

      if (self._closeReceived &amp;&amp; self._isServer) {
        self.terminate();
      } else {
        // ensure that the connection is cleaned up even when no response of closing handshake.
        clearTimeout(self._closeTimer);
        self._closeTimer = setTimeout(cleanupWebsocketResources.bind(self, true), closeTimeout);
      }
    });
  } catch (e) {
    this.emit('error', e);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.pause" id="apidoc.element.osc.WebSocket.prototype.pause">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pauser() {
  if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');

  return this._socket.pause();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.ping" id="apidoc.element.osc.WebSocket.prototype.ping">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.ping
        <span class="apidocSignatureSpan">(data, options, dontFailWhenClosed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ping(data, options, dontFailWhenClosed) {
  if (this.readyState !== WebSocket.OPEN) {
    if (dontFailWhenClosed === true) return;
    throw new Error('not opened');
  }

  options = options || {};

  if (typeof options.mask === 'undefined') options.mask = !this._isServer;

  this._sender.ping(data, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.pong" id="apidoc.element.osc.WebSocket.prototype.pong">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.pong
        <span class="apidocSignatureSpan">(data, options, dontFailWhenClosed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocket.prototype.pong = function (data, options, dontFailWhenClosed) {
  if (this.readyState !== WebSocket.OPEN) {
    if (dontFailWhenClosed === true) return;
    throw new Error('not opened');
  }

  options = options || {};

  if (typeof options.mask === 'undefined') options.mask = !this._isServer;

  this._sender.pong(data, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.resume" id="apidoc.element.osc.WebSocket.prototype.resume">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resume() {
  if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');

  return this._socket.resume();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.send" id="apidoc.element.osc.WebSocket.prototype.send">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.send
        <span class="apidocSignatureSpan">(data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function send(data, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  if (this.readyState !== WebSocket.OPEN) {
    if (typeof cb === 'function') cb(new Error('not opened'));
    else throw new Error('not opened');
    return;
  }

  if (!data) data = '';
  if (this._queue) {
    var self = this;
    this._queue.push(function() { self.send(data, options, cb); });
    return;
  }

  options = options || {};
  options.fin = true;

  if (typeof options.binary === 'undefined') {
    options.binary = (data instanceof ArrayBuffer || data instanceof Buffer ||
      data instanceof Uint8Array ||
      data instanceof Uint16Array ||
      data instanceof Uint32Array ||
      data instanceof Int8Array ||
      data instanceof Int16Array ||
      data instanceof Int32Array ||
      data instanceof Float32Array ||
      data instanceof Float64Array);
  }

  if (typeof options.mask === 'undefined') options.mask = !this._isServer;
  if (typeof options.compress === 'undefined') options.compress = true;
  if (!this.extensions[PerMessageDeflate.extensionName]) {
    options.compress = false;
  }

  var readable = typeof stream.Readable === 'function'
    ? stream.Readable
    : stream.Stream;

  if (data instanceof readable) {
    startQueue(this);
    var self = this;

    sendStream(this, data, options, function send(error) {
      process.nextTick(function tock() {
        executeQueueSends(self);
      });

      if (typeof cb === 'function') cb(error);
    });
  } else {
    this._sender.send(data, options, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.stream" id="apidoc.element.osc.WebSocket.prototype.stream">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.stream
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stream(options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  var self = this;

  if (typeof cb !== 'function') throw new Error('callback must be provided');

  if (this.readyState !== WebSocket.OPEN) {
    if (typeof cb === 'function') cb(new Error('not opened'));
    else throw new Error('not opened');
    return;
  }

  if (this._queue) {
    this._queue.push(function () { self.stream(options, cb); });
    return;
  }

  options = options || {};

  if (typeof options.mask === 'undefined') options.mask = !this._isServer;
  if (typeof options.compress === 'undefined') options.compress = true;
  if (!this.extensions[PerMessageDeflate.extensionName]) {
    options.compress = false;
  }

  startQueue(this);

  function send(data, final) {
    try {
      if (self.readyState !== WebSocket.OPEN) throw new Error('not opened');
      options.fin = final === true;
      self._sender.send(data, options);
      if (!final) process.nextTick(cb.bind(null, null, send));
      else executeQueueSends(self);
    } catch (e) {
      if (typeof cb === 'function') cb(e);
      else {
        delete self._queue;
        self.emit('error', e);
      }
    }
  }

  process.nextTick(cb.bind(null, null, send));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.terminate" id="apidoc.element.osc.WebSocket.prototype.terminate">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype.terminate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function terminate() {
  if (this.readyState === WebSocket.CLOSED) return;

  if (this._socket) {
    this.readyState = WebSocket.CLOSING;

    // End the connection
    try { this._socket.end(); }
    catch (e) {
      // Socket error during end() call, so just destroy it right now
      cleanupWebsocketResources.call(this, true);
      return;
    }

    // Add a timeout to ensure that the connection is completely
    // cleaned up within 30 seconds, even if the clean close procedure
    // fails for whatever reason
    // First cleanup any pre-existing timeout from an earlier "terminate" call,
    // if one exists.  Otherwise terminate calls in quick succession will leak timeouts
    // and hold the program open for `closeTimout` time.
    if (this._closeTimer) { clearTimeout(this._closeTimer); }
    this._closeTimer = setTimeout(cleanupWebsocketResources.bind(this, true), closeTimeout);
  } else if (this.readyState === WebSocket.CONNECTING) {
    cleanupWebsocketResources.call(this, true);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort" id="apidoc.element.osc.WebSocketPort">
        function <span class="apidocSignatureSpan">osc.</span>WebSocketPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocketPort = function (options) {
    osc.Port.call(this, options);
    this.on("open", this.listen.bind(this));

    this.socket = options.socket;
    if (this.socket) {
        if (this.socket.readyState === 1) {
            osc.WebSocketPort.setupSocketForBinary(this.socket);
            this.emit("open", this.socket);
        } else {
            this.open();
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &lt;/head&gt;
    &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
```

##### Creating an OSC Web Socket Port object:
```javascript
var oscPort = new osc.<span class="apidocCodeKeywordSpan">WebSocketPort</span>({
    url: "ws://localhost:8081" // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.open();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.close" id="apidoc.element.osc.WebSocketPort.prototype.close">
        function <span class="apidocSignatureSpan">osc.</span>WebSocketPort.prototype.close
        <span class="apidocSignatureSpan">(code, reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocketPort.prototype.close = function (code, reason) {
    this.socket.close(code, reason);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.listen" id="apidoc.element.osc.WebSocketPort.prototype.listen">
        function <span class="apidocSignatureSpan">osc.</span>WebSocketPort.prototype.listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocketPort.prototype.listen = function () {
    var that = this;
    this.socket.onmessage = function (e) {
        that.emit("data", e.data, e);
    };

    this.socket.onerror = function (err) {
        that.emit("error", err);
    };

    this.socket.onclose = function (e) {
        that.emit("close", e);
    };

    that.emit("ready");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.open" id="apidoc.element.osc.WebSocketPort.prototype.open">
        function <span class="apidocSignatureSpan">osc.</span>WebSocketPort.prototype.open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocketPort.prototype.open = function () {
    if (!this.socket || this.socket.readyState &gt; 1) {
        this.socket = new osc.WebSocket(this.options.url);
    }

    osc.WebSocketPort.setupSocketForBinary(this.socket);

    var that = this;
    this.socket.onopen = function () {
        that.emit("open", that.socket);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.sendRaw" id="apidoc.element.osc.WebSocketPort.prototype.sendRaw">
        function <span class="apidocSignatureSpan">osc.</span>WebSocketPort.prototype.sendRaw
        <span class="apidocSignatureSpan">(encoded)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocketPort.prototype.sendRaw = function (encoded) {
    if (!this.socket || this.socket.readyState !== 1) {
        osc.fireClosedPortSendError(this);
        return;
    }

    this.socket.send(encoded);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.setupSocketForBinary" id="apidoc.element.osc.WebSocketPort.setupSocketForBinary">
        function <span class="apidocSignatureSpan">osc.</span>WebSocketPort.setupSocketForBinary
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocketPort.setupSocketForBinary = function (socket) {
    socket.binaryType = osc.isNode ? "nodebuffer" : "arraybuffer";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.addDataPart" id="apidoc.element.osc.addDataPart">
        function <span class="apidocSignatureSpan">osc.</span>addDataPart
        <span class="apidocSignatureSpan">(dataPart, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addDataPart = function (dataPart, dataCollection) {
    dataCollection.parts.push(dataPart);
    dataCollection.byteLength += dataPart.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    var type = arg.type,
        writer = osc.argumentTypes[type].writer;

    if (writer) {
        var data = osc[writer](arg.value);
        osc.<span class="apidocCodeKeywordSpan">addDataPart</span>(data, dataCollection);
    }

    return arg.type;
};

// Unsupported, non-API function.
osc.collectArguments = function (args, options, dataCollection) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.annotateArguments" id="apidoc.element.osc.annotateArguments">
        function <span class="apidocSignatureSpan">osc.</span>annotateArguments
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">annotateArguments = function (args) {
    var annotated = [];

    for (var i = 0; i &lt; args.length; i++) {
        var arg = args[i],
            msgArg;

        if (typeof (arg) === "object" &amp;&amp; arg.type &amp;&amp; arg.value !== undefined) {
            // We've got an explicitly typed argument.
            msgArg = arg;
        } else if (osc.isArray(arg)) {
            // We've got an array of arguments,
            // so they each need to be inferred and expanded.
            msgArg = osc.annotateArguments(arg);
        } else {
            var oscType = osc.inferTypeForArgument(arg);
            msgArg = {
                type: oscType,
                value: arg
            };
        }

        annotated.push(msgArg);
    }

    return annotated;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

dataCollection = dataCollection || {
    byteLength: 0,
    parts: []
};

if (!options.metadata) {
    args = osc.<span class="apidocCodeKeywordSpan">annotateArguments</span>(args);
}

var typeTagString = ",",
    currPartIdx = dataCollection.parts.length;

for (var i = 0; i &lt; args.length; i++) {
    var arg = args[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.byteArray" id="apidoc.element.osc.byteArray">
        function <span class="apidocSignatureSpan">osc.</span>byteArray
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">byteArray = function (obj) {
    if (obj instanceof Uint8Array) {
        return obj;
    }

    var buf = obj.buffer ? obj.buffer : obj;

    if (!(buf instanceof ArrayBuffer) &amp;&amp; (typeof buf.length === "undefined" || typeof buf === "string")) {
        throw new Error("Can't wrap a non-array-like object as Uint8Array. Object was: " +
            JSON.stringify(obj, null, 2));
    }


    // TODO gh-39: This is a potentially unsafe algorithm;
    // if we're getting anything other than a TypedArrayView (such as a DataView),
    // we really need to determine the range of the view it is viewing.
    return new Uint8Array(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.emit("error", err);
}

return encoded;
    };

    p.decodeOSC = function (data, packetInfo) {
data = osc.<span class="apidocCodeKeywordSpan">byteArray</span>(data);
this.emit("raw", data, packetInfo);

try {
    var packet = osc.readPacket(data, this.options);
    this.emit("osc", packet, packetInfo);
    osc.firePacketEvents(this, packet, undefined, packetInfo);
} catch (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.collectArguments" id="apidoc.element.osc.collectArguments">
        function <span class="apidocSignatureSpan">osc.</span>collectArguments
        <span class="apidocSignatureSpan">(args, options, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectArguments = function (args, options, dataCollection) {
    if (!osc.isArray(args)) {
        args = typeof args === "undefined" ? [] : [args];
    }

    dataCollection = dataCollection || {
        byteLength: 0,
        parts: []
    };

    if (!options.metadata) {
        args = osc.annotateArguments(args);
    }

    var typeTagString = ",",
        currPartIdx = dataCollection.parts.length;

    for (var i = 0; i &lt; args.length; i++) {
        var arg = args[i];
        typeTagString += osc.writeArgument(arg, dataCollection);
    }

    var typeData = osc.writeString(typeTagString);
    dataCollection.byteLength += typeData.byteLength;
    dataCollection.parts.splice(currPartIdx, 0, typeData);

    return dataCollection;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Writes the specified arguments.
 *
 * @param {Array} args an array of arguments
 * @param {Object} options options for writing
 * @return {Uint8Array} a buffer containing the OSC-formatted argument type tag and values
 */
osc.writeArguments = function (args, options) {
    var argCollection = osc.<span class="apidocCodeKeywordSpan">collectArguments</span>(args, options);
    return osc.joinParts(argCollection);
};

// Unsupported, non-API function.
osc.joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.collectBundlePackets" id="apidoc.element.osc.collectBundlePackets">
        function <span class="apidocSignatureSpan">osc.</span>collectBundlePackets
        <span class="apidocSignatureSpan">(bundle, options, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectBundlePackets = function (bundle, options, dataCollection) {
    dataCollection = dataCollection || {
        byteLength: 0,
        parts: []
    };

    osc.addDataPart(osc.writeString("#bundle"), dataCollection);
    osc.addDataPart(osc.writeTimeTag(bundle.timeTag), dataCollection);

    for (var i = 0; i &lt; bundle.packets.length; i++) {
        var packet = bundle.packets[i],
            collector = packet.address ? osc.collectMessageParts : osc.collectBundlePackets,
            packetCollection = collector(packet, options);

        dataCollection.byteLength += packetCollection.byteLength;
        osc.addDataPart(osc.writeInt32(packetCollection.byteLength), dataCollection);
        dataCollection.parts = dataCollection.parts.concat(packetCollection.parts);
    }

    return dataCollection;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
osc.writeBundle = function (bundle, options) {
    if (!osc.isValidBundle(bundle)) {
        throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. " +
            "Bundle was: " + JSON.stringify(bundle, null, 2));
    }

    options = options || osc.defaults;
    var bundleCollection = osc.<span class="apidocCodeKeywordSpan">collectBundlePackets</span>(bundle, options);

    return osc.joinParts(bundleCollection);
};

osc.isValidBundle = function (bundle) {
    return bundle.timeTag !== undefined &amp;&amp; bundle.packets !== undefined;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.collectMessageParts" id="apidoc.element.osc.collectMessageParts">
        function <span class="apidocSignatureSpan">osc.</span>collectMessageParts
        <span class="apidocSignatureSpan">(msg, options, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectMessageParts = function (msg, options, dataCollection) {
    dataCollection = dataCollection || {
        byteLength: 0,
        parts: []
    };

    osc.addDataPart(osc.writeString(msg.address), dataCollection);
    return osc.collectArguments(msg.args, options, dataCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    options = options || osc.defaults;

    if (!osc.isValidMessage(msg)) {
        throw new Error("An OSC message must contain a valid address. Message was: " +
            JSON.stringify(msg, null, 2));
    }

    var msgCollection = osc.<span class="apidocCodeKeywordSpan">collectMessageParts</span>(msg, options);
    return osc.joinParts(msgCollection);
};

osc.isValidMessage = function (msg) {
    return msg.address &amp;&amp; msg.address.indexOf("/") === 0;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.copyByteArray" id="apidoc.element.osc.copyByteArray">
        function <span class="apidocSignatureSpan">osc.</span>copyByteArray
        <span class="apidocSignatureSpan">(source, target, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copyByteArray = function (source, target, offset) {
    if (osc.isTypedArrayView(source) &amp;&amp; osc.isTypedArrayView(target)) {
        target.set(source, offset);
    } else {
        var start = offset === undefined ? 0 : offset,
            len = Math.min(target.length - offset, source.length);

        for (var i = 0, j = start; i &lt; len; i++, j++) {
            target[j] = source[i];
        }
    }

    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
osc.joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
        offset = 0;

    for (var i = 0; i &lt; parts.length; i++) {
        var part = parts[i];
        osc.<span class="apidocCodeKeywordSpan">copyByteArray</span>(part, buf, offset);
        offset += part.length;
    }

    return buf;
};

// Unsupported, non-API function.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.dataView" id="apidoc.element.osc.dataView">
        function <span class="apidocSignatureSpan">osc.</span>dataView
        <span class="apidocSignatureSpan">(obj, offset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dataView = function (obj, offset, length) {
    if (obj.buffer) {
        return new DataView(obj.buffer, offset, length);
    }

    if (obj instanceof ArrayBuffer) {
        return new DataView(obj, offset, length);
    }

    return new DataView(new Uint8Array(obj), offset, length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} [options] read options
 * @param {Object} [offsetState] an offsetState object that stores the current offset into dv
 * @return {Object} the OSC message, formatted as a JavaScript object containing "address" and "args" properties
 */
osc.readMessage = function (data, options, offsetState) {
    options = options || osc.defaults;

    var dv = osc.<span class="apidocCodeKeywordSpan">dataView</span>(data, data.byteOffset, data.byteLength);
    offsetState = offsetState || {
        idx: 0
    };

    var address = osc.readString(dv, offsetState);
    return osc.readMessageContents(address, dv, options, offsetState);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.fireBundleEvents" id="apidoc.element.osc.fireBundleEvents">
        function <span class="apidocSignatureSpan">osc.</span>fireBundleEvents
        <span class="apidocSignatureSpan">(port, bundle, timeTag, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fireBundleEvents = function (port, bundle, timeTag, packetInfo) {
    port.emit("bundle", bundle, timeTag, packetInfo);
    for (var i = 0; i &lt; bundle.packets.length; i++) {
        var packet = bundle.packets[i];
        osc.firePacketEvents(port, packet, bundle.timeTag, packetInfo);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
"use strict";

// Unsupported, non-API function.
osc.firePacketEvents = function (port, packet, timeTag, packetInfo) {
    if (packet.address) {
        port.emit("message", packet, timeTag, packetInfo);
    } else {
        osc.<span class="apidocCodeKeywordSpan">fireBundleEvents</span>(port, packet, timeTag, packetInfo);
    }
};

// Unsupported, non-API function.
osc.fireBundleEvents = function (port, bundle, timeTag, packetInfo) {
    port.emit("bundle", bundle, timeTag, packetInfo);
    for (var i = 0; i &lt; bundle.packets.length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.fireClosedPortSendError" id="apidoc.element.osc.fireClosedPortSendError">
        function <span class="apidocSignatureSpan">osc.</span>fireClosedPortSendError
        <span class="apidocSignatureSpan">(port, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fireClosedPortSendError = function (port, msg) {
    msg = msg || "Can't send packets on a closed osc.Port object. Please open (or reopen) this Port by calling open().";

    port.emit("error", msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.firePacketEvents" id="apidoc.element.osc.firePacketEvents">
        function <span class="apidocSignatureSpan">osc.</span>firePacketEvents
        <span class="apidocSignatureSpan">(port, packet, timeTag, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">firePacketEvents = function (port, packet, timeTag, packetInfo) {
    if (packet.address) {
        port.emit("message", packet, timeTag, packetInfo);
    } else {
        osc.fireBundleEvents(port, packet, timeTag, packetInfo);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };

    // Unsupported, non-API function.
    osc.fireBundleEvents = function (port, bundle, timeTag, packetInfo) {
port.emit("bundle", bundle, timeTag, packetInfo);
for (var i = 0; i &lt; bundle.packets.length; i++) {
    var packet = bundle.packets[i];
    osc.<span class="apidocCodeKeywordSpan">firePacketEvents</span>(port, packet, bundle.timeTag, packetInfo);
}
    };

    osc.fireClosedPortSendError = function (port, msg) {
msg = msg || "Can't send packets on a closed osc.Port object. Please open (or reopen) this Port by calling open()."
;;

port.emit("error", msg);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.inferTypeForArgument" id="apidoc.element.osc.inferTypeForArgument">
        function <span class="apidocSignatureSpan">osc.</span>inferTypeForArgument
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inferTypeForArgument = function (arg) {
    var type = typeof arg;

    // TODO: This is freaking hideous.
    switch (type) {
        case "boolean":
            return arg ? "T" : "F";
        case "string":
            return "s";
        case "number":
            return "f";
        case "undefined":
            return "N";
        case "object":
            if (arg === null) {
                return "N";
            } else if (arg instanceof Uint8Array ||
                arg instanceof ArrayBuffer) {
                return "b";
            } else if (typeof arg.high === "number" &amp;&amp; typeof arg.low === "number") {
                return "h";
            }
            break;
    }

    throw new Error("Can't infer OSC argument type for value: " +
        JSON.stringify(arg, null, 2));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // We've got an explicitly typed argument.
    msgArg = arg;
} else if (osc.isArray(arg)) {
    // We've got an array of arguments,
    // so they each need to be inferred and expanded.
    msgArg = osc.annotateArguments(arg);
} else {
    var oscType = osc.<span class="apidocCodeKeywordSpan">inferTypeForArgument</span>(arg);
    msgArg = {
        type: oscType,
        value: arg
    };
}

annotated.push(msgArg);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.isArray" id="apidoc.element.osc.isArray">
        function <span class="apidocSignatureSpan">osc.</span>isArray
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (obj) {
    return obj &amp;&amp; Object.prototype.toString.call(obj) === "[object Array]";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

typeTag += "]";

return typeTag;
    };

    osc.writeArgument = function (arg, dataCollection) {
if (osc.<span class="apidocCodeKeywordSpan">isArray</span>(arg)) {
    return osc.writeArrayArguments(arg, dataCollection);
}

var type = arg.type,
    writer = osc.argumentTypes[type].writer;

if (writer) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.isBuffer" id="apidoc.element.osc.isBuffer">
        function <span class="apidocSignatureSpan">osc.</span>isBuffer
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBuffer = function (obj) {
    return osc.isBufferEnv &amp;&amp; obj instanceof Buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Array-like or Array-wrapping} obj an array-like or array-wrapping object
 * @returns {Buffer|Uint8Array} a buffer object
 */
// Unsupported, non-API function.
osc.nativeBuffer = function (obj) {
    if (osc.isBufferEnv) {
        return osc.<span class="apidocCodeKeywordSpan">isBuffer</span>(obj) ? obj :
            new Buffer(obj.buffer ? obj : new Uint8Array(obj));
    }

    return osc.isTypedArrayView(obj) ? obj : new Uint8Array(obj);
};

// Unsupported, non-API function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.isTypedArrayView" id="apidoc.element.osc.isTypedArrayView">
        function <span class="apidocSignatureSpan">osc.</span>isTypedArrayView
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isTypedArrayView = function (obj) {
    return obj.buffer &amp;&amp; obj.buffer instanceof ArrayBuffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Unsupported, non-API function.
osc.nativeBuffer = function (obj) {
    if (osc.isBufferEnv) {
        return osc.isBuffer(obj) ? obj :
            new Buffer(obj.buffer ? obj : new Uint8Array(obj));
    }

    return osc.<span class="apidocCodeKeywordSpan">isTypedArrayView</span>(obj) ? obj : new Uint8Array(obj);
};

// Unsupported, non-API function
osc.copyByteArray = function (source, target, offset) {
    if (osc.isTypedArrayView(source) &amp;&amp; osc.isTypedArrayView(target)) {
        target.set(source, offset);
    } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.isValidBundle" id="apidoc.element.osc.isValidBundle">
        function <span class="apidocSignatureSpan">osc.</span>isValidBundle
        <span class="apidocSignatureSpan">(bundle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidBundle = function (bundle) {
    return bundle.timeTag !== undefined &amp;&amp; bundle.packets !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * Writes an OSC bundle.
     *
     * @param {Object} a bundle object containing "timeTag" and "packets" properties
     * @param {object} [options] write options
     * @return {Uint8Array} an array of bytes containing the message
     */
    osc.writeBundle = function (bundle, options) {
if (!osc.<span class="apidocCodeKeywordSpan">isValidBundle</span>(bundle)) {
    throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. " +
        "Bundle was: " + JSON.stringify(bundle, null, 2));
}

options = options || osc.defaults;
var bundleCollection = osc.collectBundlePackets(bundle, options);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.isValidMessage" id="apidoc.element.osc.isValidMessage">
        function <span class="apidocSignatureSpan">osc.</span>isValidMessage
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidMessage = function (msg) {
    return msg.address &amp;&amp; msg.address.indexOf("/") === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} msg a message object containing "address" and "args" properties
 * @param {Object} [options] write options
 * @return {Uint8Array} an array of bytes containing the OSC message
 */
osc.writeMessage = function (msg, options) {
    options = options || osc.defaults;

    if (!osc.<span class="apidocCodeKeywordSpan">isValidMessage</span>(msg)) {
        throw new Error("An OSC message must contain a valid address. Message was: " +
            JSON.stringify(msg, null, 2));
    }

    var msgCollection = osc.collectMessageParts(msg, options);
    return osc.joinParts(msgCollection);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.joinParts" id="apidoc.element.osc.joinParts">
        function <span class="apidocSignatureSpan">osc.</span>joinParts
        <span class="apidocSignatureSpan">(dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
        offset = 0;

    for (var i = 0; i &lt; parts.length; i++) {
        var part = parts[i];
        osc.copyByteArray(part, buf, offset);
        offset += part.length;
    }

    return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Array} args an array of arguments
 * @param {Object} options options for writing
 * @return {Uint8Array} a buffer containing the OSC-formatted argument type tag and values
 */
osc.writeArguments = function (args, options) {
    var argCollection = osc.collectArguments(args, options);
    return osc.<span class="apidocCodeKeywordSpan">joinParts</span>(argCollection);
};

// Unsupported, non-API function.
osc.joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
        offset = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.jsToNTPTime" id="apidoc.element.osc.jsToNTPTime">
        function <span class="apidocSignatureSpan">osc.</span>jsToNTPTime
        <span class="apidocSignatureSpan">(jsTime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsToNTPTime = function (jsTime) {
    var secs = jsTime / 1000,
        secsWhole = Math.floor(secs),
        secsFrac = secs - secsWhole,
        ntpSecs = secsWhole + osc.SECS_70YRS,
        ntpFracs = Math.round(osc.TWO_32 * secsFrac);

    return [ntpSecs, ntpFracs];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * values. The first represents the number of seconds since January 1, 1900; the second, fractions of a second.
     * "Native" JavaScript timestamps are specified as a Number representing milliseconds since January 1, 1970.
     *
     * @param {Object} timeTag time tag object containing either a native JS timestamp (in ms) or a NTP timestamp pair
     * @return {Uint8Array} raw bytes for the written time tag
     */
    osc.writeTimeTag = function (timeTag) {
var raw = timeTag.raw ? timeTag.raw : osc.<span class="apidocCodeKeywordSpan">jsToNTPTime</span>(timeTag.native),
    arr = new Uint8Array(8), // Two Unit32s.
    dv = new DataView(arr.buffer);

osc.writeInt32(raw[0], dv, 0);
osc.writeInt32(raw[1], dv, 4);

return arr;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.nativeBuffer" id="apidoc.element.osc.nativeBuffer">
        function <span class="apidocSignatureSpan">osc.</span>nativeBuffer
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nativeBuffer = function (obj) {
    if (osc.isBufferEnv) {
        return osc.isBuffer(obj) ? obj :
            new Buffer(obj.buffer ? obj : new Uint8Array(obj));
    }

    return osc.isTypedArrayView(obj) ? obj : new Uint8Array(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var p = osc.Port.prototype = Object.create(EventEmitter.prototype);
p.constructor = osc.Port;

p.send = function (oscPacket) {
    var args = Array.prototype.slice.call(arguments),
        encoded = this.encodeOSC(oscPacket),
        buf = osc.<span class="apidocCodeKeywordSpan">nativeBuffer</span>(encoded);

    args[0] = buf;
    this.sendRaw.apply(this, args);
};

p.encodeOSC = function (packet) {
    // TODO gh-39: This is unsafe; we should only access the underlying
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.ntpToJSTime" id="apidoc.element.osc.ntpToJSTime">
        function <span class="apidocSignatureSpan">osc.</span>ntpToJSTime
        <span class="apidocSignatureSpan">(secs1900, frac)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ntpToJSTime = function (secs1900, frac) {
    var secs1970 = secs1900 - osc.SECS_70YRS,
        decimals = frac / osc.TWO_32,
        msTime = (secs1970 + decimals) * 1000;

    return msTime;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {DataView} dv the DataView instance to read from
 * @param {Object} offsetState an offset state object containing the current index into dv
 * @param {Object} a time tag object containing both the raw NTP as well as the converted native (i.e. JS/UNIX) time
 */
osc.readTimeTag = function (dv, offsetState) {
    var secs1900 = osc.readPrimitive(dv, "getUint32", 4, offsetState),
        frac = osc.readPrimitive(dv, "getUint32", 4, offsetState),
        native = (secs1900 === 0 &amp;&amp; frac === 1) ? Date.now() : osc.<span class="apidocCodeKeywordSpan">ntpToJSTime</span>(secs1900, frac);

    return {
        raw: [secs1900, frac],
        native: native
    };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readArgument" id="apidoc.element.osc.readArgument">
        function <span class="apidocSignatureSpan">osc.</span>readArgument
        <span class="apidocSignatureSpan">(argType, typeTagString, dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArgument = function (argType, typeTagString, dv, options, offsetState) {
    var typeSpec = osc.argumentTypes[argType];
    if (!typeSpec) {
        throw new Error("'" + argType + "' is not a valid OSC type tag. Type tag string was: " + typeTagString);
    }

    var argReader = typeSpec.reader,
        arg = osc[argReader](dv, offsetState);

    if (options.metadata) {
        arg = {
            type: argType,
            value: arg
        };
    }

    return arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                "without a matching close array tag ('[]'). Type tag was: " + typeTagString);
        }

        var typesInArray = fromArrayOpen.slice(0, endArrayIdx);
        arg = osc.readArgumentsIntoArray([], typesInArray, typeTagString, dv, options, offsetState);
        i += endArrayIdx + 2;
    } else {
        arg = osc.<span class="apidocCodeKeywordSpan">readArgument</span>(argType, typeTagString, dv, options, offsetState);
        i++;
    }

    arr.push(arg);
}

return arr;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readArguments" id="apidoc.element.osc.readArguments">
        function <span class="apidocSignatureSpan">osc.</span>readArguments
        <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArguments = function (dv, options, offsetState) {
    var typeTagString = osc.readString(dv, offsetState);
    if (typeTagString.indexOf(",") !== 0) {
        // Despite what the OSC 1.0 spec says,
        // it just doesn't make sense to handle messages without type tags.
        // scsynth appears to read such messages as if they have a single
        // Uint8 argument. sclang throws an error if the type tag is omitted.
        throw new Error("A malformed type tag string was found while reading " +
            "the arguments of an OSC message. String was: " +
            typeTagString, " at offset: " + offsetState.idx);
    }

    var argTypes = typeTagString.substring(1).split(""),
        args = [];

    osc.readArgumentsIntoArray(args, argTypes, typeTagString, dv, options, offsetState);

    return args;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Unsupported, non-API function.
osc.readMessageContents = function (address, dv, options, offsetState) {
    if (address.indexOf("/") !== 0) {
        throw new Error("A malformed OSC address was found while reading " +
            "an OSC message. String was: " + address);
    }

    var args = osc.<span class="apidocCodeKeywordSpan">readArguments</span>(dv, options, offsetState);

    return {
        address: address,
        args: args.length === 1 &amp;&amp; options.unpackSingleArgs ? args[0] : args
    };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readArgumentsIntoArray" id="apidoc.element.osc.readArgumentsIntoArray">
        function <span class="apidocSignatureSpan">osc.</span>readArgumentsIntoArray
        <span class="apidocSignatureSpan">(arr, argTypes, typeTagString, dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArgumentsIntoArray = function (arr, argTypes, typeTagString, dv, options, offsetState) {
    var i = 0;

    while (i &lt; argTypes.length) {
        var argType = argTypes[i],
            arg;

        if (argType === "[") {
            var fromArrayOpen = argTypes.slice(i + 1),
                endArrayIdx = fromArrayOpen.indexOf("]");

            if (endArrayIdx &lt; 0) {
                throw new Error("Invalid argument type tag: an open array type tag ('[') was found " +
                    "without a matching close array tag ('[]'). Type tag was: " + typeTagString);
            }

            var typesInArray = fromArrayOpen.slice(0, endArrayIdx);
            arg = osc.readArgumentsIntoArray([], typesInArray, typeTagString, dv, options, offsetState);
            i += endArrayIdx + 2;
        } else {
            arg = osc.readArgument(argType, typeTagString, dv, options, offsetState);
            i++;
        }

        arr.push(arg);
    }

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            "the arguments of an OSC message. String was: " +
            typeTagString, " at offset: " + offsetState.idx);
    }

    var argTypes = typeTagString.substring(1).split(""),
        args = [];

    osc.<span class="apidocCodeKeywordSpan">readArgumentsIntoArray</span>(args, argTypes, typeTagString, dv, options, offsetState
);

    return args;
};

// Unsupported, non-API function.
osc.readArgument = function (argType, typeTagString, dv, options, offsetState) {
    var typeSpec = osc.argumentTypes[argType];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readBlob" id="apidoc.element.osc.readBlob">
        function <span class="apidocSignatureSpan">osc.</span>readBlob
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBlob = function (dv, offsetState) {
    var len = osc.readInt32(dv, offsetState),
        paddedLen = (len + 3) &amp; ~0x03,
        blob = new Uint8Array(dv.buffer, offsetState.idx, len);

    offsetState.idx += paddedLen;

    return blob;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readBundle" id="apidoc.element.osc.readBundle">
        function <span class="apidocSignatureSpan">osc.</span>readBundle
        <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBundle = function (dv, options, offsetState) {
    return osc.readPacket(dv, options, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readBundleContents" id="apidoc.element.osc.readBundleContents">
        function <span class="apidocSignatureSpan">osc.</span>readBundleContents
        <span class="apidocSignatureSpan">(dv, options, offsetState, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBundleContents = function (dv, options, offsetState, len) {
    var timeTag = osc.readTimeTag(dv, offsetState),
        packets = [];

    while (offsetState.idx &lt; len) {
        var packetSize = osc.readInt32(dv, offsetState),
            packetLen = offsetState.idx + packetSize,
            packet = osc.readPacket(dv, options, offsetState, packetLen);

        packets.push(packet);
    }

    return {
        timeTag: timeTag,
        packets: packets
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        idx: 0
    };

    var header = osc.readString(dv, offsetState),
        firstChar = header[0];

    if (firstChar === "#") {
        return osc.<span class="apidocCodeKeywordSpan">readBundleContents</span>(dv, options, offsetState, len);
    } else if (firstChar === "/") {
        return osc.readMessageContents(header, dv, options, offsetState);
    }

    throw new Error("The header of an OSC packet didn't contain an OSC address or a #bundle string." +
        " Header was: " + header);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readChar32" id="apidoc.element.osc.readChar32">
        function <span class="apidocSignatureSpan">osc.</span>readChar32
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readChar32 = function (dv, offsetState) {
    var charCode = osc.readPrimitive(dv, "getUint32", 4, offsetState);
    return String.fromCharCode(charCode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readColor" id="apidoc.element.osc.readColor">
        function <span class="apidocSignatureSpan">osc.</span>readColor
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readColor = function (dv, offsetState) {
    var bytes = new Uint8Array(dv.buffer, offsetState.idx, 4),
        alpha = bytes[3] / 255;

    offsetState.idx += 4;

    return {
        r: bytes[0],
        g: bytes[1],
        b: bytes[2],
        a: alpha
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readFalse" id="apidoc.element.osc.readFalse">
        function <span class="apidocSignatureSpan">osc.</span>readFalse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFalse = function () {
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readFloat32" id="apidoc.element.osc.readFloat32">
        function <span class="apidocSignatureSpan">osc.</span>readFloat32
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFloat32 = function (dv, offsetState) {
    return osc.readPrimitive(dv, "getFloat32", 4, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readFloat64" id="apidoc.element.osc.readFloat64">
        function <span class="apidocSignatureSpan">osc.</span>readFloat64
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFloat64 = function (dv, offsetState) {
    return osc.readPrimitive(dv, "getFloat64", 8, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readImpulse" id="apidoc.element.osc.readImpulse">
        function <span class="apidocSignatureSpan">osc.</span>readImpulse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readImpulse = function () {
    return 1.0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readInt32" id="apidoc.element.osc.readInt32">
        function <span class="apidocSignatureSpan">osc.</span>readInt32
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt32 = function (dv, offsetState) {
    return osc.readPrimitive(dv, "getInt32", 4, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Reads an OSC blob ("b") (i.e. a Uint8Array).
 *
 * @param {DataView} dv a DataView instance to read from
 * @param {Object} offsetState an offsetState object used to store the current offset index into dv
 * @return {Uint8Array} the data that was read
 */
osc.readBlob = function (dv, offsetState) {
    var len = osc.<span class="apidocCodeKeywordSpan">readInt32</span>(dv, offsetState),
        paddedLen = (len + 3) &amp; ~0x03,
        blob = new Uint8Array(dv.buffer, offsetState.idx, len);

    offsetState.idx += paddedLen;

    return blob;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readInt64" id="apidoc.element.osc.readInt64">
        function <span class="apidocSignatureSpan">osc.</span>readInt64
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt64 = function (dv, offsetState) {
    var high = osc.readPrimitive(dv, "getInt32", 4, offsetState),
        low = osc.readPrimitive(dv, "getInt32", 4, offsetState);

    if (Long) {
        return new Long(low, high);
    } else {
        return {
            high: high,
            low: low,
            unsigned: false
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readMIDIBytes" id="apidoc.element.osc.readMIDIBytes">
        function <span class="apidocSignatureSpan">osc.</span>readMIDIBytes
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readMIDIBytes = function (dv, offsetState) {
    var midi = new Uint8Array(dv.buffer, offsetState.idx, 4);
    offsetState.idx += 4;

    return midi;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readMessage" id="apidoc.element.osc.readMessage">
        function <span class="apidocSignatureSpan">osc.</span>readMessage
        <span class="apidocSignatureSpan">(data, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readMessage = function (data, options, offsetState) {
    options = options || osc.defaults;

    var dv = osc.dataView(data, data.byteOffset, data.byteLength);
    offsetState = offsetState || {
        idx: 0
    };

    var address = osc.readString(dv, offsetState);
    return osc.readMessageContents(address, dv, options, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readMessageContents" id="apidoc.element.osc.readMessageContents">
        function <span class="apidocSignatureSpan">osc.</span>readMessageContents
        <span class="apidocSignatureSpan">(address, dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readMessageContents = function (address, dv, options, offsetState) {
    if (address.indexOf("/") !== 0) {
        throw new Error("A malformed OSC address was found while reading " +
            "an OSC message. String was: " + address);
    }

    var args = osc.readArguments(dv, options, offsetState);

    return {
        address: address,
        args: args.length === 1 &amp;&amp; options.unpackSingleArgs ? args[0] : args
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    var dv = osc.dataView(data, data.byteOffset, data.byteLength);
    offsetState = offsetState || {
        idx: 0
    };

    var address = osc.readString(dv, offsetState);
    return osc.<span class="apidocCodeKeywordSpan">readMessageContents</span>(address, dv, options, offsetState);
};

// Unsupported, non-API function.
osc.readMessageContents = function (address, dv, options, offsetState) {
    if (address.indexOf("/") !== 0) {
        throw new Error("A malformed OSC address was found while reading " +
            "an OSC message. String was: " + address);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readNull" id="apidoc.element.osc.readNull">
        function <span class="apidocSignatureSpan">osc.</span>readNull
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readNull = function () {
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readPacket" id="apidoc.element.osc.readPacket">
        function <span class="apidocSignatureSpan">osc.</span>readPacket
        <span class="apidocSignatureSpan">(data, options, offsetState, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readPacket = function (data, options, offsetState, len) {
    var dv = osc.dataView(data, data.byteOffset, data.byteLength);

    len = len === undefined ? dv.byteLength : len;
    offsetState = offsetState || {
        idx: 0
    };

    var header = osc.readString(dv, offsetState),
        firstChar = header[0];

    if (firstChar === "#") {
        return osc.readBundleContents(dv, options, offsetState, len);
    } else if (firstChar === "/") {
        return osc.readMessageContents(header, dv, options, offsetState);
    }

    throw new Error("The header of an OSC packet didn't contain an OSC address or a #bundle string." +
        " Header was: " + header);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
they should be caught and handled using
&lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;.

```javascript
var msg;

try {
    msg = osc.<span class="apidocCodeKeywordSpan">readPacket</span>(rawPacket);
} catch (error) {
    console.log("An error occurred: ", error.message);
}
```

The osc.js Low-Level API
------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readPrimitive" id="apidoc.element.osc.readPrimitive">
        function <span class="apidocSignatureSpan">osc.</span>readPrimitive
        <span class="apidocSignatureSpan">(dv, readerName, numBytes, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readPrimitive = function (dv, readerName, numBytes, offsetState) {
    var val = dv[readerName](offsetState.idx, false);
    offsetState.idx += numBytes;

    return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Reads an OSC int32 ("i") value.
 *
 * @param {DataView} dv a DataView containing the raw bytes
 * @param {Object} offsetState an offsetState object used to store the current offset index into dv
 * @return {Number} the number that was read
 */
osc.readInt32 = function (dv, offsetState) {
    return osc.<span class="apidocCodeKeywordSpan">readPrimitive</span>(dv, "getInt32", 4, offsetState);
};

/**
 * Writes an OSC int32 ("i") value.
 *
 * @param {Number} val the number to write
 * @param {DataView} [dv] a DataView instance to write the number into
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readString" id="apidoc.element.osc.readString">
        function <span class="apidocSignatureSpan">osc.</span>readString
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readString = function (dv, offsetState) {
    var charCodes = [],
        idx = offsetState.idx;

    for (; idx &lt; dv.byteLength; idx++) {
        var charCode = dv.getUint8(idx);
        if (charCode !== 0) {
            charCodes.push(charCode);
        } else {
            idx++;
            break;
        }
    }

    // Round to the nearest 4-byte block.
    idx = (idx + 3) &amp; ~0x03;
    offsetState.idx = idx;

    return String.fromCharCode.apply(null, charCodes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {DataView} dv a DataView instance to read from
 * @param {Object} offsetState the offsetState object that stores the current offset into dv
 * @param {Oobject} [options] read options
 * @return {Array} an array of the OSC arguments that were read
 */
osc.readArguments = function (dv, options, offsetState) {
    var typeTagString = osc.<span class="apidocCodeKeywordSpan">readString</span>(dv, offsetState);
    if (typeTagString.indexOf(",") !== 0) {
        // Despite what the OSC 1.0 spec says,
        // it just doesn't make sense to handle messages without type tags.
        // scsynth appears to read such messages as if they have a single
        // Uint8 argument. sclang throws an error if the type tag is omitted.
        throw new Error("A malformed type tag string was found while reading " +
            "the arguments of an OSC message. String was: " +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readTimeTag" id="apidoc.element.osc.readTimeTag">
        function <span class="apidocSignatureSpan">osc.</span>readTimeTag
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readTimeTag = function (dv, offsetState) {
    var secs1900 = osc.readPrimitive(dv, "getUint32", 4, offsetState),
        frac = osc.readPrimitive(dv, "getUint32", 4, offsetState),
        native = (secs1900 === 0 &amp;&amp; frac === 1) ? Date.now() : osc.ntpToJSTime(secs1900, frac);

    return {
        raw: [secs1900, frac],
        native: native
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    osc.isValidBundle = function (bundle) {
return bundle.timeTag !== undefined &amp;&amp; bundle.packets !== undefined;
    };

    // Unsupported, non-API function.
    osc.readBundleContents = function (dv, options, offsetState, len) {
var timeTag = osc.<span class="apidocCodeKeywordSpan">readTimeTag</span>(dv, offsetState),
    packets = [];

while (offsetState.idx &lt; len) {
    var packetSize = osc.readInt32(dv, offsetState),
        packetLen = offsetState.idx + packetSize,
        packet = osc.readPacket(dv, options, offsetState, packetLen);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readTrue" id="apidoc.element.osc.readTrue">
        function <span class="apidocSignatureSpan">osc.</span>readTrue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readTrue = function () {
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.relay" id="apidoc.element.osc.relay">
        function <span class="apidocSignatureSpan">osc.</span>relay
        <span class="apidocSignatureSpan">(from, to, eventName, sendFnName, transformFn, sendArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">relay = function (from, to, eventName, sendFnName, transformFn, sendArgs) {
    eventName = eventName || "message";
    sendFnName = sendFnName || "send";
    transformFn = transformFn || function () {};
    sendArgs = sendArgs ? [null].concat(sendArgs) : [];

    var listener = function (data) {
        sendArgs[0] = data;
        data = transformFn(data);
        to[sendFnName].apply(to, sendArgs);
    };

    from.on(eventName, listener);

    return {
        eventName: eventName,
        listener: listener
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// Unsupported, non-API function.
osc.relayPorts = function (from, to, o) {
    var eventName = o.raw ? "raw" : "osc",
        sendFnName = o.raw ? "sendRaw" : "send";

    return osc.<span class="apidocCodeKeywordSpan">relay</span>(from, to, eventName, sendFnName, o.transform);
};

// Unsupported, non-API function.
osc.stopRelaying = function (from, relaySpec) {
    from.removeListener(relaySpec.eventName, relaySpec.listener);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.relayPorts" id="apidoc.element.osc.relayPorts">
        function <span class="apidocSignatureSpan">osc.</span>relayPorts
        <span class="apidocSignatureSpan">(from, to, o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">relayPorts = function (from, to, o) {
    var eventName = o.raw ? "raw" : "osc",
        sendFnName = o.raw ? "sendRaw" : "send";

    return osc.relay(from, to, eventName, sendFnName, o.transform);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.close();
}

this.port1Spec = osc.<span class="apidocCodeKeywordSpan">relayPorts</span>(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
// Users are still responsible for closing the underlying ports
// if necessary.
var closeListener = this.close.bind(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.stopRelaying" id="apidoc.element.osc.stopRelaying">
        function <span class="apidocSignatureSpan">osc.</span>stopRelaying
        <span class="apidocSignatureSpan">(from, relaySpec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopRelaying = function (from, relaySpec) {
    from.removeListener(relaySpec.eventName, relaySpec.listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // if necessary.
    var closeListener = this.close.bind(this);
    this.port1.on("close", closeListener);
    this.port2.on("close", closeListener);
};

p.close = function () {
    osc.<span class="apidocCodeKeywordSpan">stopRelaying</span>(this.port1, this.port1Spec);
    osc.stopRelaying(this.port2, this.port2Spec);
    this.emit("close", this.port1, this.port2);
};


// If we're in a require-compatible environment, export ourselves.
if (typeof module !== "undefined" &amp;&amp; module.exports) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.timeTag" id="apidoc.element.osc.timeTag">
        function <span class="apidocSignatureSpan">osc.</span>timeTag
        <span class="apidocSignatureSpan">(secs, now)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeTag = function (secs, now) {
    secs = secs || 0;
    now = now || Date.now();

    var nowSecs = now / 1000,
        nowWhole = Math.floor(nowSecs),
        nowFracs = nowSecs - nowWhole,
        secsWhole = Math.floor(secs),
        secsFracs = secs - secsWhole,
        fracs = nowFracs + secsFracs;

    if (fracs &gt; 1) {
        var fracsWhole = Math.floor(fracs),
            fracsFracs = fracs - fracsWhole;

        secsWhole += fracsWhole;
        fracs = fracsFracs;
    }

    var ntpSecs = nowWhole + secsWhole + osc.SECS_70YRS,
        ntpFracs = Math.round(osc.TWO_32 * fracs);

    return {
        raw: [ntpSecs, ntpFracs]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

##### Sending OSC bundles:
```javascript
oscPort.on("ready", function () {
oscPort.send({
    timeTag: osc.<span class="apidocCodeKeywordSpan">timeTag</span>(60), // Schedules this bundle 60 seconds from now.
    packets: [
        {
            address: "/carrier/frequency",
            args: 440
        },
        {
            address: "/carrier/amplitude"
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeArgument" id="apidoc.element.osc.writeArgument">
        function <span class="apidocSignatureSpan">osc.</span>writeArgument
        <span class="apidocSignatureSpan">(arg, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArgument = function (arg, dataCollection) {
    if (osc.isArray(arg)) {
        return osc.writeArrayArguments(arg, dataCollection);
    }

    var type = arg.type,
        writer = osc.argumentTypes[type].writer;

    if (writer) {
        var data = osc[writer](arg.value);
        osc.addDataPart(data, dataCollection);
    }

    return arg.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

osc.writeArrayArguments = function (args, dataCollection) {
    var typeTag = "[";

    for (var i = 0; i &lt; args.length; i++) {
        var arg = args[i];
        typeTag += osc.<span class="apidocCodeKeywordSpan">writeArgument</span>(arg, dataCollection);
    }

    typeTag += "]";

    return typeTag;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeArguments" id="apidoc.element.osc.writeArguments">
        function <span class="apidocSignatureSpan">osc.</span>writeArguments
        <span class="apidocSignatureSpan">(args, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArguments = function (args, options) {
    var argCollection = osc.collectArguments(args, options);
    return osc.joinParts(argCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeArrayArguments" id="apidoc.element.osc.writeArrayArguments">
        function <span class="apidocSignatureSpan">osc.</span>writeArrayArguments
        <span class="apidocSignatureSpan">(args, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArrayArguments = function (args, dataCollection) {
    var typeTag = "[";

    for (var i = 0; i &lt; args.length; i++) {
        var arg = args[i];
        typeTag += osc.writeArgument(arg, dataCollection);
    }

    typeTag += "]";

    return typeTag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
typeTag += "]";

return typeTag;
    };

    osc.writeArgument = function (arg, dataCollection) {
if (osc.isArray(arg)) {
    return osc.<span class="apidocCodeKeywordSpan">writeArrayArguments</span>(arg, dataCollection);
}

var type = arg.type,
    writer = osc.argumentTypes[type].writer;

if (writer) {
    var data = osc[writer](arg.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeBlob" id="apidoc.element.osc.writeBlob">
        function <span class="apidocSignatureSpan">osc.</span>writeBlob
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeBlob = function (data) {
    data = osc.byteArray(data);

    var len = data.byteLength,
        paddedLen = (len + 3) &amp; ~0x03,
        offset = 4, // Extra 4 bytes is for the size.
        blobLen = paddedLen + offset,
        arr = new Uint8Array(blobLen),
        dv = new DataView(arr.buffer);

    // Write the size.
    osc.writeInt32(len, dv);

    // Since we're writing to a real ArrayBuffer,
    // we don't need to pad the remaining bytes.
    arr.set(data, offset);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeBundle" id="apidoc.element.osc.writeBundle">
        function <span class="apidocSignatureSpan">osc.</span>writeBundle
        <span class="apidocSignatureSpan">(bundle, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeBundle = function (bundle, options) {
    if (!osc.isValidBundle(bundle)) {
        throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. " +
            "Bundle was: " + JSON.stringify(bundle, null, 2));
    }

    options = options || osc.defaults;
    var bundleCollection = osc.collectBundlePackets(bundle, options);

    return osc.joinParts(bundleCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} [options] write options
 * @return {Uint8Array} an array of bytes containing the message
 */
osc.writePacket = function (packet, options) {
    if (osc.isValidMessage(packet)) {
        return osc.writeMessage(packet, options);
    } else if (osc.isValidBundle(packet)) {
        return osc.<span class="apidocCodeKeywordSpan">writeBundle</span>(packet, options);
    } else {
        throw new Error("The specified packet was not recognized as a valid OSC message or bundle." +
            " Packet was: " + JSON.stringify(packet, null, 2));
    }
};

// Unsupported, non-API.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeChar32" id="apidoc.element.osc.writeChar32">
        function <span class="apidocSignatureSpan">osc.</span>writeChar32
        <span class="apidocSignatureSpan">(str, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeChar32 = function (str, dv, offset) {
    var charCode = str.charCodeAt(0);
    if (charCode === undefined || charCode &lt; -1) {
        return undefined;
    }

    return osc.writePrimitive(charCode, dv, "setUint32", 4, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeColor" id="apidoc.element.osc.writeColor">
        function <span class="apidocSignatureSpan">osc.</span>writeColor
        <span class="apidocSignatureSpan">(color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeColor = function (color) {
    var alpha = Math.round(color.a * 255),
        arr = new Uint8Array([color.r, color.g, color.b, alpha]);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeFloat32" id="apidoc.element.osc.writeFloat32">
        function <span class="apidocSignatureSpan">osc.</span>writeFloat32
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFloat32 = function (val, dv, offset) {
    return osc.writePrimitive(val, dv, "setFloat32", 4, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeFloat64" id="apidoc.element.osc.writeFloat64">
        function <span class="apidocSignatureSpan">osc.</span>writeFloat64
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFloat64 = function (val, dv, offset) {
    return osc.writePrimitive(val, dv, "setFloat64", 8, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeInt32" id="apidoc.element.osc.writeInt32">
        function <span class="apidocSignatureSpan">osc.</span>writeInt32
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt32 = function (val, dv, offset) {
    return osc.writePrimitive(val, dv, "setInt32", 4, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        paddedLen = (len + 3) &amp; ~0x03,
        offset = 4, // Extra 4 bytes is for the size.
        blobLen = paddedLen + offset,
        arr = new Uint8Array(blobLen),
        dv = new DataView(arr.buffer);

    // Write the size.
    osc.<span class="apidocCodeKeywordSpan">writeInt32</span>(len, dv);

    // Since we're writing to a real ArrayBuffer,
    // we don't need to pad the remaining bytes.
    arr.set(data, offset);

    return arr;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeInt64" id="apidoc.element.osc.writeInt64">
        function <span class="apidocSignatureSpan">osc.</span>writeInt64
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt64 = function (val, dv, offset) {
    var arr = new Uint8Array(8);
    arr.set(osc.writePrimitive(val.high, dv, "setInt32", 4, offset), 0);
    arr.set(osc.writePrimitive(val.low,  dv, "setInt32", 4, offset + 4), 4);
    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeMIDIBytes" id="apidoc.element.osc.writeMIDIBytes">
        function <span class="apidocSignatureSpan">osc.</span>writeMIDIBytes
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeMIDIBytes = function (bytes) {
    bytes = osc.byteArray(bytes);

    var arr = new Uint8Array(4);
    arr.set(bytes);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeMessage" id="apidoc.element.osc.writeMessage">
        function <span class="apidocSignatureSpan">osc.</span>writeMessage
        <span class="apidocSignatureSpan">(msg, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeMessage = function (msg, options) {
    options = options || osc.defaults;

    if (!osc.isValidMessage(msg)) {
        throw new Error("An OSC message must contain a valid address. Message was: " +
            JSON.stringify(msg, null, 2));
    }

    var msgCollection = osc.collectMessageParts(msg, options);
    return osc.joinParts(msgCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Object} a bundle or message object
 * @param {Object} [options] write options
 * @return {Uint8Array} an array of bytes containing the message
 */
osc.writePacket = function (packet, options) {
    if (osc.isValidMessage(packet)) {
        return osc.<span class="apidocCodeKeywordSpan">writeMessage</span>(packet, options);
    } else if (osc.isValidBundle(packet)) {
        return osc.writeBundle(packet, options);
    } else {
        throw new Error("The specified packet was not recognized as a valid OSC message or bundle." +
            " Packet was: " + JSON.stringify(packet, null, 2));
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writePacket" id="apidoc.element.osc.writePacket">
        function <span class="apidocSignatureSpan">osc.</span>writePacket
        <span class="apidocSignatureSpan">(packet, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writePacket = function (packet, options) {
    if (osc.isValidMessage(packet)) {
        return osc.writeMessage(packet, options);
    } else if (osc.isValidBundle(packet)) {
        return osc.writeBundle(packet, options);
    } else {
        throw new Error("The specified packet was not recognized as a valid OSC message or bundle." +
            " Packet was: " + JSON.stringify(packet, null, 2));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &lt;code&gt;options&lt;/code&gt;: (optional) An options object, described below; &lt;br /&gt;
        &lt;code&gt;offsetState&lt;/code&gt;: (optional) an offset state object containing an &lt;code&gt;idx&lt;/
code&gt; property that specifies the offset index into &lt;code&gt;data&lt;/code&gt;; &lt;br /&gt;
        &lt;code&gt;length&lt;/code&gt; the length (in bytes) to read from &lt;code&gt;data&lt;/code&gt;
    &lt;/td&gt;
    &lt;td&gt;An osc.js message or bundle object&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;code&gt;osc.<span class="apidocCodeKeywordSpan">writePacket</span>()&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;Writes an OSC message or bundle object to a binary array.&lt;/td&gt;
    &lt;td&gt;
        &lt;code&gt;packate&lt;/code&gt;: An osc.js message or bundle object;&lt;br /&gt;
        &lt;code&gt;options&lt;/code&gt;: (optional) An options object, described below&lt;br /&gt;
    &lt;/td&gt;
    &lt;td&gt;A &lt;code&gt;Uint8Array&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writePrimitive" id="apidoc.element.osc.writePrimitive">
        function <span class="apidocSignatureSpan">osc.</span>writePrimitive
        <span class="apidocSignatureSpan">(val, dv, writerName, numBytes, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writePrimitive = function (val, dv, writerName, numBytes, offset) {
    offset = offset === undefined ? 0 : offset;

    var arr;
    if (!dv) {
        arr = new Uint8Array(numBytes);
        dv = new DataView(arr.buffer);
    } else {
        arr = new Uint8Array(dv.buffer);
    }

    dv[writerName](offset, val, false);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Writes an OSC int32 ("i") value.
 *
 * @param {Number} val the number to write
 * @param {DataView} [dv] a DataView instance to write the number into
 * @param {Number} [offset] an offset into dv
 */
osc.writeInt32 = function (val, dv, offset) {
    return osc.<span class="apidocCodeKeywordSpan">writePrimitive</span>(val, dv, "setInt32", 4, offset);
};

/**
 * Reads an OSC int64 ("h") value.
 *
 * @param {DataView} dv a DataView containing the raw bytes
 * @param {Object} offsetState an offsetState object used to store the current offset index into dv
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeString" id="apidoc.element.osc.writeString">
        function <span class="apidocSignatureSpan">osc.</span>writeString
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeString = function (str) {
    var terminated = str + "\u0000",
        len = terminated.length,
        paddedLen = (len + 3) &amp; ~0x03,
        arr = new Uint8Array(paddedLen);

    for (var i = 0; i &lt; terminated.length; i++) {
        var charCode = terminated.charCodeAt(i);
        arr[i] = charCode;
    }

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        currPartIdx = dataCollection.parts.length;

    for (var i = 0; i &lt; args.length; i++) {
        var arg = args[i];
        typeTagString += osc.writeArgument(arg, dataCollection);
    }

    var typeData = osc.<span class="apidocCodeKeywordSpan">writeString</span>(typeTagString);
    dataCollection.byteLength += typeData.byteLength;
    dataCollection.parts.splice(currPartIdx, 0, typeData);

    return dataCollection;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeTimeTag" id="apidoc.element.osc.writeTimeTag">
        function <span class="apidocSignatureSpan">osc.</span>writeTimeTag
        <span class="apidocSignatureSpan">(timeTag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeTimeTag = function (timeTag) {
    var raw = timeTag.raw ? timeTag.raw : osc.jsToNTPTime(timeTag.native),
        arr = new Uint8Array(8), // Two Unit32s.
        dv = new DataView(arr.buffer);

    osc.writeInt32(raw[0], dv, 0);
    osc.writeInt32(raw[1], dv, 4);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    osc.collectBundlePackets = function (bundle, options, dataCollection) {
        dataCollection = dataCollection || {
byteLength: 0,
parts: []
        };

        osc.addDataPart(osc.writeString("#bundle"), dataCollection);
        osc.addDataPart(osc.<span class="apidocCodeKeywordSpan">writeTimeTag</span>(bundle.timeTag), dataCollection);

        for (var i = 0; i &lt; bundle.packets.length; i++) {
var packet = bundle.packets[i],
    collector = packet.address ? osc.collectMessageParts : osc.collectBundlePackets,
    packetCollection = collector(packet, options);

dataCollection.byteLength += packetCollection.byteLength;
...</pre></li>
    </ul>


































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.Gruntfile" id="apidoc.module.osc.Gruntfile">module osc.Gruntfile</a></h1>


    <h2>
        <a href="#apidoc.element.osc.Gruntfile.Gruntfile" id="apidoc.element.osc.Gruntfile.Gruntfile">
        function <span class="apidocSignatureSpan">osc.</span>Gruntfile
        <span class="apidocSignatureSpan">(grunt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Gruntfile = function (grunt) {

    var files = {
        moduleDeps: [
            "node_modules/long/dist/long.js",
            "node_modules/slip/src/slip.js",
            "node_modules/wolfy87-eventemitter/EventEmitter.js"
        ],

        osc: [
            "src/osc.js"
        ],

        oscWeb: [
            "src/osc-transports.js",
            "src/platforms/osc-websocket-client.js"
        ],

        oscChrome: [
            "src/platforms/osc-chromeapp.js"
        ],

        moduleHeader: [
            "build-support/js/module-header.js"
        ],

        moduleFooter: [
            "build-support/js/module-footer.js"
        ]
    };

    grunt.initConfig({
        pkg: grunt.file.readJSON("package.json"),

        jshint: {
            all: ["src/*.js", "tests/**/*.js", "!**/node_modules/**"],
            options: {
                jshintrc: true
            }
        },

        concat: {
            options: {
                separator: ";",
                banner: "&lt;%= oscjs.banners.short %&gt;"
            },

            base: {
                src: [].concat(files.osc),
                dest: "dist/&lt;%= pkg.name %&gt;.js"
            },

            browser: {
                src: [].concat(files.osc, files.moduleDeps, files.oscWeb),
                dest: "dist/&lt;%= pkg.name %&gt;-browser.js"
            },

            chromeapp: {
                src: [].concat(files.osc, files.moduleDeps, files.oscWeb, files.oscChrome),
                dest: "dist/&lt;%= pkg.name %&gt;-chromeapp.js"
            },

            module: {
                src: [].concat(files.moduleHeader, files.osc, files.oscWeb, files.moduleFooter),
                dest: "dist/&lt;%= pkg.name %&gt;-module.js"
            }
        },

        uglify: {
            options: {
                banner: "&lt;%= oscjs.banners.short %&gt;",
                beautify: {
                    ascii_only: true
                }
            },
            all: {
                files: [
                    {
                        expand: true,
                        cwd: "dist/",
                        src: ["*.js"],
                        dest: "dist/",
                        ext: ".min.js",
                    }
                ]
            }
        },

        clean: {
            all: {
                src: ["dist/"]
            }
        },

        oscjs: {
            banners: {
                short: "/*! osc.js &lt;%= pkg.version %&gt;, " +
                    "Copyright &lt;%= grunt.template.today('yyyy') %&gt; Colin Clark | " +
                    "github.com/colinbdclark/osc.js */\n\n"
            }
        }
    });

    // Load relevant Grunt plugins.
    grunt.loadNpmTasks("grunt-contrib-concat");
    grunt.loadNpmTasks("grunt-contrib-uglify");
    grunt.loadNpmTasks("grunt-contrib-clean");
    grunt.loadNpmTasks("grunt-contrib-jshint");

    grunt.registerTask("default", ["clean", "jshint", "concat", "uglify"]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.Port" id="apidoc.module.osc.Port">module osc.Port</a></h1>


    <h2>
        <a href="#apidoc.element.osc.Port.Port" id="apidoc.element.osc.Port.Port">
        function <span class="apidocSignatureSpan">osc.</span>Port
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Port = function (options) {
    this.options = options || {};
    this.on("data", this.decodeOSC.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.Port.prototype" id="apidoc.module.osc.Port.prototype">module osc.Port.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.Port.prototype.constructor" id="apidoc.element.osc.Port.prototype.constructor">
        function <span class="apidocSignatureSpan">osc.Port.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (options) {
    this.options = options || {};
    this.on("data", this.decodeOSC.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Port.prototype.decodeOSC" id="apidoc.element.osc.Port.prototype.decodeOSC">
        function <span class="apidocSignatureSpan">osc.Port.prototype.</span>decodeOSC
        <span class="apidocSignatureSpan">(data, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeOSC = function (data, packetInfo) {
    data = osc.byteArray(data);
    this.emit("raw", data, packetInfo);

    try {
        var packet = osc.readPacket(data, this.options);
        this.emit("osc", packet, packetInfo);
        osc.firePacketEvents(this, packet, undefined, packetInfo);
    } catch (err) {
        this.emit("error", err);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Port.prototype.encodeOSC" id="apidoc.element.osc.Port.prototype.encodeOSC">
        function <span class="apidocSignatureSpan">osc.Port.prototype.</span>encodeOSC
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeOSC = function (packet) {
    // TODO gh-39: This is unsafe; we should only access the underlying
    // buffer within the range of its view.
    packet = packet.buffer ? packet.buffer : packet;
    var encoded;

    try {
        encoded = osc.writePacket(packet, this.options);
    } catch (err) {
        this.emit("error", err);
    }

    return encoded;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

var p = osc.Port.prototype = Object.create(EventEmitter.prototype);
p.constructor = osc.Port;

p.send = function (oscPacket) {
    var args = Array.prototype.slice.call(arguments),
        encoded = this.<span class="apidocCodeKeywordSpan">encodeOSC</span>(oscPacket),
        buf = osc.nativeBuffer(encoded);

    args[0] = buf;
    this.sendRaw.apply(this, args);
};

p.encodeOSC = function (packet) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Port.prototype.send" id="apidoc.element.osc.Port.prototype.send">
        function <span class="apidocSignatureSpan">osc.Port.prototype.</span>send
        <span class="apidocSignatureSpan">(oscPacket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (oscPacket) {
    var args = Array.prototype.slice.call(arguments),
        encoded = this.encodeOSC(oscPacket),
        buf = osc.nativeBuffer(encoded);

    args[0] = buf;
    this.sendRaw.apply(this, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

##### Sending OSC messages:
```javascript
// For most Ports, send() should only be called after the "ready" event fires.
oscPort.on("ready", function () {
    oscPort.<span class="apidocCodeKeywordSpan">send</span>({
        address: "/carrier/frequency",
        args: 440
    });
});
```

##### Sending OSC bundles:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.Port.prototype.decodeOSC" id="apidoc.module.osc.Port.prototype.decodeOSC">module osc.Port.prototype.decodeOSC</a></h1>


    <h2>
        <a href="#apidoc.element.osc.Port.prototype.decodeOSC.decodeOSC" id="apidoc.element.osc.Port.prototype.decodeOSC.decodeOSC">
        function <span class="apidocSignatureSpan">osc.Port.prototype.</span>decodeOSC
        <span class="apidocSignatureSpan">(data, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeOSC = function (data, packetInfo) {
    data = osc.byteArray(data);
    this.emit("raw", data, packetInfo);

    try {
        var packet = osc.readPacket(data, this.options);
        this.emit("osc", packet, packetInfo);
        osc.firePacketEvents(this, packet, undefined, packetInfo);
    } catch (err) {
        this.emit("error", err);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.Port.prototype.encodeOSC" id="apidoc.module.osc.Port.prototype.encodeOSC">module osc.Port.prototype.encodeOSC</a></h1>


    <h2>
        <a href="#apidoc.element.osc.Port.prototype.encodeOSC.encodeOSC" id="apidoc.element.osc.Port.prototype.encodeOSC.encodeOSC">
        function <span class="apidocSignatureSpan">osc.Port.prototype.</span>encodeOSC
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeOSC = function (packet) {
    // TODO gh-39: This is unsafe; we should only access the underlying
    // buffer within the range of its view.
    packet = packet.buffer ? packet.buffer : packet;
    var encoded;

    try {
        encoded = osc.writePacket(packet, this.options);
    } catch (err) {
        this.emit("error", err);
    }

    return encoded;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

var p = osc.Port.prototype = Object.create(EventEmitter.prototype);
p.constructor = osc.Port;

p.send = function (oscPacket) {
    var args = Array.prototype.slice.call(arguments),
        encoded = this.<span class="apidocCodeKeywordSpan">encodeOSC</span>(oscPacket),
        buf = osc.nativeBuffer(encoded);

    args[0] = buf;
    this.sendRaw.apply(this, args);
};

p.encodeOSC = function (packet) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.Port.prototype.send" id="apidoc.module.osc.Port.prototype.send">module osc.Port.prototype.send</a></h1>


    <h2>
        <a href="#apidoc.element.osc.Port.prototype.send.send" id="apidoc.element.osc.Port.prototype.send.send">
        function <span class="apidocSignatureSpan">osc.Port.prototype.</span>send
        <span class="apidocSignatureSpan">(oscPacket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (oscPacket) {
    var args = Array.prototype.slice.call(arguments),
        encoded = this.encodeOSC(oscPacket),
        buf = osc.nativeBuffer(encoded);

    args[0] = buf;
    this.sendRaw.apply(this, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

##### Sending OSC messages:
```javascript
// For most Ports, send() should only be called after the "ready" event fires.
oscPort.on("ready", function () {
    oscPort.<span class="apidocCodeKeywordSpan">send</span>({
        address: "/carrier/frequency",
        args: 440
    });
});
```

##### Sending OSC bundles:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.Relay" id="apidoc.module.osc.Relay">module osc.Relay</a></h1>


    <h2>
        <a href="#apidoc.element.osc.Relay.Relay" id="apidoc.element.osc.Relay.Relay">
        function <span class="apidocSignatureSpan">osc.</span>Relay
        <span class="apidocSignatureSpan">(port1, port2, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Relay = function (port1, port2, options) {
    var o = this.options = options || {};
    o.raw = false;

    this.port1 = port1;
    this.port2 = port2;

    this.listen();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.Relay.prototype" id="apidoc.module.osc.Relay.prototype">module osc.Relay.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.Relay.prototype.close" id="apidoc.element.osc.Relay.prototype.close">
        function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    osc.stopRelaying(this.port1, this.port1Spec);
    osc.stopRelaying(this.port2, this.port2Spec);
    this.emit("close", this.port1, this.port2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Relay.prototype.constructor" id="apidoc.element.osc.Relay.prototype.constructor">
        function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>constructor
        <span class="apidocSignatureSpan">(port1, port2, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (port1, port2, options) {
    var o = this.options = options || {};
    o.raw = false;

    this.port1 = port1;
    this.port2 = port2;

    this.listen();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Relay.prototype.listen" id="apidoc.element.osc.Relay.prototype.listen">
        function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
    if (this.port1Spec &amp;&amp; this.port2Spec) {
        this.close();
    }

    this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
    this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

    // Bind port close listeners to ensure that the relay
    // will stop forwarding messages if one of its ports close.
    // Users are still responsible for closing the underlying ports
    // if necessary.
    var closeListener = this.close.bind(this);
    this.port1.on("close", closeListener);
    this.port2.on("close", closeListener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var osc = require("osc"),
    http = require("http"),
    WebSocket = require("ws");

// Create an Express server app
// and serve up a directory of static files.
var app = require("express").express(),
    server = app.<span class="apidocCodeKeywordSpan">listen</span>(8081);

app.use("/", express.static(__dirname + "/static"));

// Listen for Web Socket requests.
var wss = new WebSocket.Server({
    server: server
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Relay.prototype.open" id="apidoc.element.osc.Relay.prototype.open">
        function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
    this.port1.open();
    this.port2.open();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oscPort = new osc.WebSocketPort({
    url: "ws://localhost:8081" // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.<span class="apidocCodeKeywordSpan">open</span>();
```

##### Listening for incoming OSC messages:
```javascript
oscPort.on("message", function (oscMsg) {
    console.log("An OSC message just arrived!", oscMsg);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.Relay.prototype.close" id="apidoc.module.osc.Relay.prototype.close">module osc.Relay.prototype.close</a></h1>


    <h2>
        <a href="#apidoc.element.osc.Relay.prototype.close.close" id="apidoc.element.osc.Relay.prototype.close.close">
        function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    osc.stopRelaying(this.port1, this.port1Spec);
    osc.stopRelaying(this.port2, this.port2Spec);
    this.emit("close", this.port1, this.port2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.Relay.prototype.listen" id="apidoc.module.osc.Relay.prototype.listen">module osc.Relay.prototype.listen</a></h1>


    <h2>
        <a href="#apidoc.element.osc.Relay.prototype.listen.listen" id="apidoc.element.osc.Relay.prototype.listen.listen">
        function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
    if (this.port1Spec &amp;&amp; this.port2Spec) {
        this.close();
    }

    this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
    this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

    // Bind port close listeners to ensure that the relay
    // will stop forwarding messages if one of its ports close.
    // Users are still responsible for closing the underlying ports
    // if necessary.
    var closeListener = this.close.bind(this);
    this.port1.on("close", closeListener);
    this.port2.on("close", closeListener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var osc = require("osc"),
    http = require("http"),
    WebSocket = require("ws");

// Create an Express server app
// and serve up a directory of static files.
var app = require("express").express(),
    server = app.<span class="apidocCodeKeywordSpan">listen</span>(8081);

app.use("/", express.static(__dirname + "/static"));

// Listen for Web Socket requests.
var wss = new WebSocket.Server({
    server: server
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.Relay.prototype.open" id="apidoc.module.osc.Relay.prototype.open">module osc.Relay.prototype.open</a></h1>


    <h2>
        <a href="#apidoc.element.osc.Relay.prototype.open.open" id="apidoc.element.osc.Relay.prototype.open.open">
        function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
    this.port1.open();
    this.port2.open();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oscPort = new osc.WebSocketPort({
    url: "ws://localhost:8081" // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.<span class="apidocCodeKeywordSpan">open</span>();
```

##### Listening for incoming OSC messages:
```javascript
oscPort.on("message", function (oscMsg) {
    console.log("An OSC message just arrived!", oscMsg);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.SLIPPort" id="apidoc.module.osc.SLIPPort">module osc.SLIPPort</a></h1>


    <h2>
        <a href="#apidoc.element.osc.SLIPPort.SLIPPort" id="apidoc.element.osc.SLIPPort.SLIPPort">
        function <span class="apidocSignatureSpan">osc.</span>SLIPPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SLIPPort = function (options) {
    var that = this;
    var o = this.options = options || {};
    o.useSLIP = o.useSLIP === undefined ? true : o.useSLIP;

    this.decoder = new slip.Decoder({
        onMessage: this.decodeOSC.bind(this),
        onError: function (err) {
            that.emit("error", err);
        }
    });

    var decodeHandler = o.useSLIP ? this.decodeSLIPData : this.decodeOSC;
    this.on("data", decodeHandler.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.SLIPPort.prototype" id="apidoc.module.osc.SLIPPort.prototype">module osc.SLIPPort.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.SLIPPort.prototype.constructor" id="apidoc.element.osc.SLIPPort.prototype.constructor">
        function <span class="apidocSignatureSpan">osc.SLIPPort.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (options) {
    var that = this;
    var o = this.options = options || {};
    o.useSLIP = o.useSLIP === undefined ? true : o.useSLIP;

    this.decoder = new slip.Decoder({
        onMessage: this.decodeOSC.bind(this),
        onError: function (err) {
            that.emit("error", err);
        }
    });

    var decodeHandler = o.useSLIP ? this.decodeSLIPData : this.decodeOSC;
    this.on("data", decodeHandler.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SLIPPort.prototype.decodeSLIPData" id="apidoc.element.osc.SLIPPort.prototype.decodeSLIPData">
        function <span class="apidocSignatureSpan">osc.SLIPPort.prototype.</span>decodeSLIPData
        <span class="apidocSignatureSpan">(data, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeSLIPData = function (data, packetInfo) {
    // TODO: Get packetInfo through SLIP decoder.
    this.decoder.decode(data, packetInfo);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SLIPPort.prototype.encodeOSC" id="apidoc.element.osc.SLIPPort.prototype.encodeOSC">
        function <span class="apidocSignatureSpan">osc.SLIPPort.prototype.</span>encodeOSC
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeOSC = function (packet) {
    // TODO gh-39: This is unsafe; we should only access the underlying
    // buffer within the range of its view.
    packet = packet.buffer ? packet.buffer : packet;
    var framed;

    try {
        var encoded = osc.writePacket(packet, this.options);
        framed = slip.encode(encoded);
    } catch (err) {
        this.emit("error", err);
    }

    return framed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

var p = osc.Port.prototype = Object.create(EventEmitter.prototype);
p.constructor = osc.Port;

p.send = function (oscPacket) {
    var args = Array.prototype.slice.call(arguments),
        encoded = this.<span class="apidocCodeKeywordSpan">encodeOSC</span>(oscPacket),
        buf = osc.nativeBuffer(encoded);

    args[0] = buf;
    this.sendRaw.apply(this, args);
};

p.encodeOSC = function (packet) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.SLIPPort.prototype.decodeSLIPData" id="apidoc.module.osc.SLIPPort.prototype.decodeSLIPData">module osc.SLIPPort.prototype.decodeSLIPData</a></h1>


    <h2>
        <a href="#apidoc.element.osc.SLIPPort.prototype.decodeSLIPData.decodeSLIPData" id="apidoc.element.osc.SLIPPort.prototype.decodeSLIPData.decodeSLIPData">
        function <span class="apidocSignatureSpan">osc.SLIPPort.prototype.</span>decodeSLIPData
        <span class="apidocSignatureSpan">(data, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeSLIPData = function (data, packetInfo) {
    // TODO: Get packetInfo through SLIP decoder.
    this.decoder.decode(data, packetInfo);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.SLIPPort.prototype.encodeOSC" id="apidoc.module.osc.SLIPPort.prototype.encodeOSC">module osc.SLIPPort.prototype.encodeOSC</a></h1>


    <h2>
        <a href="#apidoc.element.osc.SLIPPort.prototype.encodeOSC.encodeOSC" id="apidoc.element.osc.SLIPPort.prototype.encodeOSC.encodeOSC">
        function <span class="apidocSignatureSpan">osc.SLIPPort.prototype.</span>encodeOSC
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeOSC = function (packet) {
    // TODO gh-39: This is unsafe; we should only access the underlying
    // buffer within the range of its view.
    packet = packet.buffer ? packet.buffer : packet;
    var framed;

    try {
        var encoded = osc.writePacket(packet, this.options);
        framed = slip.encode(encoded);
    } catch (err) {
        this.emit("error", err);
    }

    return framed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

var p = osc.Port.prototype = Object.create(EventEmitter.prototype);
p.constructor = osc.Port;

p.send = function (oscPacket) {
    var args = Array.prototype.slice.call(arguments),
        encoded = this.<span class="apidocCodeKeywordSpan">encodeOSC</span>(oscPacket),
        buf = osc.nativeBuffer(encoded);

    args[0] = buf;
    this.sendRaw.apply(this, args);
};

p.encodeOSC = function (packet) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.SerialPort" id="apidoc.module.osc.SerialPort">module osc.SerialPort</a></h1>


    <h2>
        <a href="#apidoc.element.osc.SerialPort.SerialPort" id="apidoc.element.osc.SerialPort.SerialPort">
        function <span class="apidocSignatureSpan">osc.</span>SerialPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SerialPort = function (options) {
    this.on("open", this.listen.bind(this));
    osc.SLIPPort.call(this, options);
    this.options.bitrate = this.options.bitrate || 9600;

    this.serialPort = options.serialPort;
    if (this.serialPort) {
        this.emit("open", this.serialPort);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
}
```

#### Connecting to the serial port and listening for OSC messages
```javascript
// Instantiate a new OSC Serial Port.
var serialPort = new osc.<span class="apidocCodeKeywordSpan">SerialPort</span>({
    devicePath: "/dev/cu.usbmodem22131"
});

// Listen for the message event and map the OSC message to the synth.
serialPort.on("message", function (oscMsg) {
    console.log("An OSC message was received!", oscMsg);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.SerialPort.prototype" id="apidoc.module.osc.SerialPort.prototype">module osc.SerialPort.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.close" id="apidoc.element.osc.SerialPort.prototype.close">
        function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    if (this.serialPort) {
        this.serialPort.close();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.constructor" id="apidoc.element.osc.SerialPort.prototype.constructor">
        function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (options) {
    this.on("open", this.listen.bind(this));
    osc.SLIPPort.call(this, options);
    this.options.bitrate = this.options.bitrate || 9600;

    this.serialPort = options.serialPort;
    if (this.serialPort) {
        this.emit("open", this.serialPort);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.listen" id="apidoc.element.osc.SerialPort.prototype.listen">
        function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
    var that = this;

    this.serialPort.on("data", function (data) {
        that.emit("data", data, undefined);
    });

    this.serialPort.on("error", function (err) {
        that.emit("error", err);
    });

    this.serialPort.on("close", function (err) {
        if (err) {
            that.emit("error", err);
        } else {
            that.emit("close");
        }
    });

    that.emit("ready");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var osc = require("osc"),
    http = require("http"),
    WebSocket = require("ws");

// Create an Express server app
// and serve up a directory of static files.
var app = require("express").express(),
    server = app.<span class="apidocCodeKeywordSpan">listen</span>(8081);

app.use("/", express.static(__dirname + "/static"));

// Listen for Web Socket requests.
var wss = new WebSocket.Server({
    server: server
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.open" id="apidoc.element.osc.SerialPort.prototype.open">
        function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
    if (this.serialPort) {
        // If we already have a serial port, close it and open a new one.
        this.once("close", this.open.bind(this));
        this.close();
        return;
    }

    var that = this;

    this.serialPort = new SerialPort(this.options.devicePath, {
        baudrate: this.options.bitrate,
        autoOpen: false
    });

    this.serialPort.open(function() {
        that.emit("open", that.serialPort);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oscPort = new osc.WebSocketPort({
    url: "ws://localhost:8081" // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.<span class="apidocCodeKeywordSpan">open</span>();
```

##### Listening for incoming OSC messages:
```javascript
oscPort.on("message", function (oscMsg) {
    console.log("An OSC message just arrived!", oscMsg);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.sendRaw" id="apidoc.element.osc.SerialPort.prototype.sendRaw">
        function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>sendRaw
        <span class="apidocSignatureSpan">(encoded)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendRaw = function (encoded) {
    if (!this.serialPort || !this.serialPort.isOpen()) {
        osc.fireClosedPortSendError(this);
        return;
    }

    var that = this;
    this.serialPort.write(encoded, function (err) {
        if (err) {
            that.emit("error", err);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.SerialPort.prototype.close" id="apidoc.module.osc.SerialPort.prototype.close">module osc.SerialPort.prototype.close</a></h1>


    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.close.close" id="apidoc.element.osc.SerialPort.prototype.close.close">
        function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    if (this.serialPort) {
        this.serialPort.close();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.SerialPort.prototype.listen" id="apidoc.module.osc.SerialPort.prototype.listen">module osc.SerialPort.prototype.listen</a></h1>


    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.listen.listen" id="apidoc.element.osc.SerialPort.prototype.listen.listen">
        function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
    var that = this;

    this.serialPort.on("data", function (data) {
        that.emit("data", data, undefined);
    });

    this.serialPort.on("error", function (err) {
        that.emit("error", err);
    });

    this.serialPort.on("close", function (err) {
        if (err) {
            that.emit("error", err);
        } else {
            that.emit("close");
        }
    });

    that.emit("ready");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var osc = require("osc"),
    http = require("http"),
    WebSocket = require("ws");

// Create an Express server app
// and serve up a directory of static files.
var app = require("express").express(),
    server = app.<span class="apidocCodeKeywordSpan">listen</span>(8081);

app.use("/", express.static(__dirname + "/static"));

// Listen for Web Socket requests.
var wss = new WebSocket.Server({
    server: server
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.SerialPort.prototype.open" id="apidoc.module.osc.SerialPort.prototype.open">module osc.SerialPort.prototype.open</a></h1>


    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.open.open" id="apidoc.element.osc.SerialPort.prototype.open.open">
        function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
    if (this.serialPort) {
        // If we already have a serial port, close it and open a new one.
        this.once("close", this.open.bind(this));
        this.close();
        return;
    }

    var that = this;

    this.serialPort = new SerialPort(this.options.devicePath, {
        baudrate: this.options.bitrate,
        autoOpen: false
    });

    this.serialPort.open(function() {
        that.emit("open", that.serialPort);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oscPort = new osc.WebSocketPort({
    url: "ws://localhost:8081" // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.<span class="apidocCodeKeywordSpan">open</span>();
```

##### Listening for incoming OSC messages:
```javascript
oscPort.on("message", function (oscMsg) {
    console.log("An OSC message just arrived!", oscMsg);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.SerialPort.prototype.sendRaw" id="apidoc.module.osc.SerialPort.prototype.sendRaw">module osc.SerialPort.prototype.sendRaw</a></h1>


    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.sendRaw.sendRaw" id="apidoc.element.osc.SerialPort.prototype.sendRaw.sendRaw">
        function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>sendRaw
        <span class="apidocSignatureSpan">(encoded)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendRaw = function (encoded) {
    if (!this.serialPort || !this.serialPort.isOpen()) {
        osc.fireClosedPortSendError(this);
        return;
    }

    var that = this;
    this.serialPort.write(encoded, function (err) {
        if (err) {
            that.emit("error", err);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.TCPSocketPort" id="apidoc.module.osc.TCPSocketPort">module osc.TCPSocketPort</a></h1>


    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.TCPSocketPort" id="apidoc.element.osc.TCPSocketPort.TCPSocketPort">
        function <span class="apidocSignatureSpan">osc.</span>TCPSocketPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TCPSocketPort = function (options) {
    osc.SLIPPort.call(this, options);

    var o = this.options;
    o.localAddress = o.localAddress || "127.0.0.1";
    o.localPort = o.localPort !== undefined ? o.localPort : 57121;

    this.on("open", this.listen.bind(this));
    this.socket = options.socket;

    if (this.socket) {
        this.emit("open", this.socket);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.TCPSocketPort.prototype" id="apidoc.module.osc.TCPSocketPort.prototype">module osc.TCPSocketPort.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.close" id="apidoc.element.osc.TCPSocketPort.prototype.close">
        function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    this.socket.end();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.constructor" id="apidoc.element.osc.TCPSocketPort.prototype.constructor">
        function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (options) {
    osc.SLIPPort.call(this, options);

    var o = this.options;
    o.localAddress = o.localAddress || "127.0.0.1";
    o.localPort = o.localPort !== undefined ? o.localPort : 57121;

    this.on("open", this.listen.bind(this));
    this.socket = options.socket;

    if (this.socket) {
        this.emit("open", this.socket);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.listen" id="apidoc.element.osc.TCPSocketPort.prototype.listen">
        function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
    var that = this;
    this.socket.on("data", function (msg) {
        that.emit("data", msg, undefined);
    });

    this.socket.on("error", function (err) {
        that.emit("error", err);
    });

    this.socket.on("close", function (err) {
        if (err) {
            that.emit("error", err);
        } else {
            that.emit("close");
        }
    });

    this.socket.on("connect", function () {
        that.emit("ready");
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var osc = require("osc"),
    http = require("http"),
    WebSocket = require("ws");

// Create an Express server app
// and serve up a directory of static files.
var app = require("express").express(),
    server = app.<span class="apidocCodeKeywordSpan">listen</span>(8081);

app.use("/", express.static(__dirname + "/static"));

// Listen for Web Socket requests.
var wss = new WebSocket.Server({
    server: server
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.open" id="apidoc.element.osc.TCPSocketPort.prototype.open">
        function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>open
        <span class="apidocSignatureSpan">(address, port)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function (address, port) {
    var o = this.options;
    address = address || o.address;
    port = port !== undefined ? port : o.port;

    if (!this.socket) {
        this.socket = net.connect({
            port: port,
            host: address
        });
    } else {
        this.socket.connect(port, address);
    }

    this.emit("open", this.socket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oscPort = new osc.WebSocketPort({
    url: "ws://localhost:8081" // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.<span class="apidocCodeKeywordSpan">open</span>();
```

##### Listening for incoming OSC messages:
```javascript
oscPort.on("message", function (oscMsg) {
    console.log("An OSC message just arrived!", oscMsg);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.sendRaw" id="apidoc.element.osc.TCPSocketPort.prototype.sendRaw">
        function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>sendRaw
        <span class="apidocSignatureSpan">(encoded)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendRaw = function (encoded) {
    if (!this.socket) {
        return;
    }

    encoded = new Buffer(encoded);

    try {
        this.socket.write(encoded);
    } catch (err) {
        this.emit("error", err);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.TCPSocketPort.prototype.close" id="apidoc.module.osc.TCPSocketPort.prototype.close">module osc.TCPSocketPort.prototype.close</a></h1>


    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.close.close" id="apidoc.element.osc.TCPSocketPort.prototype.close.close">
        function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    this.socket.end();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.TCPSocketPort.prototype.listen" id="apidoc.module.osc.TCPSocketPort.prototype.listen">module osc.TCPSocketPort.prototype.listen</a></h1>


    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.listen.listen" id="apidoc.element.osc.TCPSocketPort.prototype.listen.listen">
        function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
    var that = this;
    this.socket.on("data", function (msg) {
        that.emit("data", msg, undefined);
    });

    this.socket.on("error", function (err) {
        that.emit("error", err);
    });

    this.socket.on("close", function (err) {
        if (err) {
            that.emit("error", err);
        } else {
            that.emit("close");
        }
    });

    this.socket.on("connect", function () {
        that.emit("ready");
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var osc = require("osc"),
    http = require("http"),
    WebSocket = require("ws");

// Create an Express server app
// and serve up a directory of static files.
var app = require("express").express(),
    server = app.<span class="apidocCodeKeywordSpan">listen</span>(8081);

app.use("/", express.static(__dirname + "/static"));

// Listen for Web Socket requests.
var wss = new WebSocket.Server({
    server: server
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.TCPSocketPort.prototype.open" id="apidoc.module.osc.TCPSocketPort.prototype.open">module osc.TCPSocketPort.prototype.open</a></h1>


    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.open.open" id="apidoc.element.osc.TCPSocketPort.prototype.open.open">
        function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>open
        <span class="apidocSignatureSpan">(address, port)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function (address, port) {
    var o = this.options;
    address = address || o.address;
    port = port !== undefined ? port : o.port;

    if (!this.socket) {
        this.socket = net.connect({
            port: port,
            host: address
        });
    } else {
        this.socket.connect(port, address);
    }

    this.emit("open", this.socket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oscPort = new osc.WebSocketPort({
    url: "ws://localhost:8081" // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.<span class="apidocCodeKeywordSpan">open</span>();
```

##### Listening for incoming OSC messages:
```javascript
oscPort.on("message", function (oscMsg) {
    console.log("An OSC message just arrived!", oscMsg);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.TCPSocketPort.prototype.sendRaw" id="apidoc.module.osc.TCPSocketPort.prototype.sendRaw">module osc.TCPSocketPort.prototype.sendRaw</a></h1>


    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.sendRaw.sendRaw" id="apidoc.element.osc.TCPSocketPort.prototype.sendRaw.sendRaw">
        function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>sendRaw
        <span class="apidocSignatureSpan">(encoded)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendRaw = function (encoded) {
    if (!this.socket) {
        return;
    }

    encoded = new Buffer(encoded);

    try {
        this.socket.write(encoded);
    } catch (err) {
        this.emit("error", err);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.UDPPort" id="apidoc.module.osc.UDPPort">module osc.UDPPort</a></h1>


    <h2>
        <a href="#apidoc.element.osc.UDPPort.UDPPort" id="apidoc.element.osc.UDPPort.UDPPort">
        function <span class="apidocSignatureSpan">osc.</span>UDPPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UDPPort = function (options) {
    osc.Port.call(this, options);

    this.options.localAddress = this.options.localAddress || "127.0.0.1";
    this.options.localPort = this.options.localPort !== undefined ?
        this.options.localPort : 57121;

    this.options.remoteAddress = this.options.remoteAddress || "127.0.0.1";
    this.options.remotePort = this.options.remotePort !== undefined ?
        this.options.remotePort : 57121;

    this.on("open", this.listen.bind(this));

    this.socket = options.socket;
    if (this.socket) {
        this.emit("open", this.socket);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;/tr&gt;
&lt;/table&gt;

#### Sample Code

```javascript
// Create an osc.js UDP Port listening on port 57121.
var udpPort = new osc.<span class="apidocCodeKeywordSpan">UDPPort</span>({
localAddress: "0.0.0.0",
localPort: 57121
});

// Listen for incoming OSC bundles.
udpPort.on("bundle", function (oscBundle, timeTag, info) {
console.log("An OSC bundle just arrived for time tag", timeTag, ":", oscBundle);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort.setupMulticast" id="apidoc.element.osc.UDPPort.setupMulticast">
        function <span class="apidocSignatureSpan">osc.UDPPort.</span>setupMulticast
        <span class="apidocSignatureSpan">(that)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupMulticast = function (that) {
    if (that.options.multicastTTL !== undefined) {
        that.socket.setMulticastTTL(that.options.multicastTTL);
    }

    if (that.options.multicastMembership) {
        if (typeof that.options.multicastMembership === "string") {
            that.options.multicastMembership = [that.options.multicastMembership];
        }

        that.options.multicastMembership.forEach(function (addr) {
            if (typeof addr === "string") {
              that.socket.addMembership(addr);
            } else {
              that.socket.addMembership(addr.address, addr.interface);
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.UDPPort.prototype" id="apidoc.module.osc.UDPPort.prototype">module osc.UDPPort.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.close" id="apidoc.element.osc.UDPPort.prototype.close">
        function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    if (this.socket) {
        this.socket.close();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.constructor" id="apidoc.element.osc.UDPPort.prototype.constructor">
        function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (options) {
    osc.Port.call(this, options);

    this.options.localAddress = this.options.localAddress || "127.0.0.1";
    this.options.localPort = this.options.localPort !== undefined ?
        this.options.localPort : 57121;

    this.options.remoteAddress = this.options.remoteAddress || "127.0.0.1";
    this.options.remotePort = this.options.remotePort !== undefined ?
        this.options.remotePort : 57121;

    this.on("open", this.listen.bind(this));

    this.socket = options.socket;
    if (this.socket) {
        this.emit("open", this.socket);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.listen" id="apidoc.element.osc.UDPPort.prototype.listen">
        function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
    if (!this.socket) {
        return;
    }

    var that = this;
    this.socket.on("message", function (msg, rinfo) {
        that.emit("data", msg, rinfo);
    });

    this.socket.on("error", function (error) {
        that.emit("error", error);
    });

    this.socket.on("close", function () {
        that.emit("close");
    });

    that.emit("ready");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var osc = require("osc"),
    http = require("http"),
    WebSocket = require("ws");

// Create an Express server app
// and serve up a directory of static files.
var app = require("express").express(),
    server = app.<span class="apidocCodeKeywordSpan">listen</span>(8081);

app.use("/", express.static(__dirname + "/static"));

// Listen for Web Socket requests.
var wss = new WebSocket.Server({
    server: server
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.open" id="apidoc.element.osc.UDPPort.prototype.open">
        function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
    var that = this;

    if (this.socket) {
        return;
    }

    this.socket = dgram.createSocket("udp4");

    function onBound() {
        osc.UDPPort.setupMulticast(that);

        if (that.options.broadcast) {
            that.socket.setBroadcast(that.options.broadcast);
        }

        that.emit("open", that.socket);
    }

    this.socket.bind(this.options.localPort, this.options.localAddress, onBound);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oscPort = new osc.WebSocketPort({
    url: "ws://localhost:8081" // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.<span class="apidocCodeKeywordSpan">open</span>();
```

##### Listening for incoming OSC messages:
```javascript
oscPort.on("message", function (oscMsg) {
    console.log("An OSC message just arrived!", oscMsg);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.sendRaw" id="apidoc.element.osc.UDPPort.prototype.sendRaw">
        function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>sendRaw
        <span class="apidocSignatureSpan">(encoded, address, port)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendRaw = function (encoded, address, port) {
    if (!this.socket) {
        osc.fireClosedPortSendError(this);
        return;
    }

    var length = encoded.byteLength !== undefined ? encoded.byteLength : encoded.length,
        that = this;

    address = address || this.options.remoteAddress;
    port = port !== undefined ? port : this.options.remotePort;

    this.socket.send(encoded, 0, length, port, address, function (err) {
        if (err) {
            that.emit("error", err);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.UDPPort.prototype.close" id="apidoc.module.osc.UDPPort.prototype.close">module osc.UDPPort.prototype.close</a></h1>


    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.close.close" id="apidoc.element.osc.UDPPort.prototype.close.close">
        function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    if (this.socket) {
        this.socket.close();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.UDPPort.prototype.listen" id="apidoc.module.osc.UDPPort.prototype.listen">module osc.UDPPort.prototype.listen</a></h1>


    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.listen.listen" id="apidoc.element.osc.UDPPort.prototype.listen.listen">
        function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
    if (!this.socket) {
        return;
    }

    var that = this;
    this.socket.on("message", function (msg, rinfo) {
        that.emit("data", msg, rinfo);
    });

    this.socket.on("error", function (error) {
        that.emit("error", error);
    });

    this.socket.on("close", function () {
        that.emit("close");
    });

    that.emit("ready");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var osc = require("osc"),
    http = require("http"),
    WebSocket = require("ws");

// Create an Express server app
// and serve up a directory of static files.
var app = require("express").express(),
    server = app.<span class="apidocCodeKeywordSpan">listen</span>(8081);

app.use("/", express.static(__dirname + "/static"));

// Listen for Web Socket requests.
var wss = new WebSocket.Server({
    server: server
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.UDPPort.prototype.open" id="apidoc.module.osc.UDPPort.prototype.open">module osc.UDPPort.prototype.open</a></h1>


    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.open.open" id="apidoc.element.osc.UDPPort.prototype.open.open">
        function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
    var that = this;

    if (this.socket) {
        return;
    }

    this.socket = dgram.createSocket("udp4");

    function onBound() {
        osc.UDPPort.setupMulticast(that);

        if (that.options.broadcast) {
            that.socket.setBroadcast(that.options.broadcast);
        }

        that.emit("open", that.socket);
    }

    this.socket.bind(this.options.localPort, this.options.localAddress, onBound);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oscPort = new osc.WebSocketPort({
    url: "ws://localhost:8081" // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.<span class="apidocCodeKeywordSpan">open</span>();
```

##### Listening for incoming OSC messages:
```javascript
oscPort.on("message", function (oscMsg) {
    console.log("An OSC message just arrived!", oscMsg);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.UDPPort.prototype.sendRaw" id="apidoc.module.osc.UDPPort.prototype.sendRaw">module osc.UDPPort.prototype.sendRaw</a></h1>


    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.sendRaw.sendRaw" id="apidoc.element.osc.UDPPort.prototype.sendRaw.sendRaw">
        function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>sendRaw
        <span class="apidocSignatureSpan">(encoded, address, port)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendRaw = function (encoded, address, port) {
    if (!this.socket) {
        osc.fireClosedPortSendError(this);
        return;
    }

    var length = encoded.byteLength !== undefined ? encoded.byteLength : encoded.length,
        that = this;

    address = address || this.options.remoteAddress;
    port = port !== undefined ? port : this.options.remotePort;

    this.socket.send(encoded, 0, length, port, address, function (err) {
        if (err) {
            that.emit("error", err);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.UDPPort.setupMulticast" id="apidoc.module.osc.UDPPort.setupMulticast">module osc.UDPPort.setupMulticast</a></h1>


    <h2>
        <a href="#apidoc.element.osc.UDPPort.setupMulticast.setupMulticast" id="apidoc.element.osc.UDPPort.setupMulticast.setupMulticast">
        function <span class="apidocSignatureSpan">osc.UDPPort.</span>setupMulticast
        <span class="apidocSignatureSpan">(that)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupMulticast = function (that) {
    if (that.options.multicastTTL !== undefined) {
        that.socket.setMulticastTTL(that.options.multicastTTL);
    }

    if (that.options.multicastMembership) {
        if (typeof that.options.multicastMembership === "string") {
            that.options.multicastMembership = [that.options.multicastMembership];
        }

        that.options.multicastMembership.forEach(function (addr) {
            if (typeof addr === "string") {
              that.socket.addMembership(addr);
            } else {
              that.socket.addMembership(addr.address, addr.interface);
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket" id="apidoc.module.osc.WebSocket">module osc.WebSocket</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.WebSocket" id="apidoc.element.osc.WebSocket.WebSocket">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket
        <span class="apidocSignatureSpan">(address, protocols, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocket(address, protocols, options) {
  if (this instanceof WebSocket === false) {
    return new WebSocket(address, protocols, options);
  }

  EventEmitter.call(this);

  if (protocols &amp;&amp; !Array.isArray(protocols) &amp;&amp; 'object' === typeof protocols) {
    // accept the "options" Object as the 2nd argument
    options = protocols;
    protocols = null;
  }

  if ('string' === typeof protocols) {
    protocols = [ protocols ];
  }

  if (!Array.isArray(protocols)) {
    protocols = [];
  }

  this._socket = null;
  this._ultron = null;
  this._closeReceived = false;
  this.bytesReceived = 0;
  this.readyState = null;
  this.supports = {};
  this.extensions = {};
  this._binaryType = 'nodebuffer';

  if (Array.isArray(address)) {
    initAsServerClient.apply(this, address.concat(options));
  } else {
    initAsClient.apply(this, [address, protocols, options]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver" id="apidoc.element.osc.WebSocket.Receiver">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>Receiver
        <span class="apidocSignatureSpan">(extensions, maxPayload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Receiver(extensions, maxPayload) {
  if (this instanceof Receiver === false) {
    throw new TypeError("Classes can't be function-called");
  }
  if(typeof extensions==='number'){
    maxPayload=extensions;
    extensions={};
  }


  // memory pool for fragmented messages
  var fragmentedPoolPrevUsed = -1;
  this.fragmentedBufferPool = new BufferPool(1024, function(db, length) {
    return db.used + length;
  }, function(db) {
    return fragmentedPoolPrevUsed = fragmentedPoolPrevUsed &gt;= 0 ?
      Math.ceil((fragmentedPoolPrevUsed + db.used) / 2) :
      db.used;
  });

  // memory pool for unfragmented messages
  var unfragmentedPoolPrevUsed = -1;
  this.unfragmentedBufferPool = new BufferPool(1024, function(db, length) {
    return db.used + length;
  }, function(db) {
    return unfragmentedPoolPrevUsed = unfragmentedPoolPrevUsed &gt;= 0 ?
      Math.ceil((unfragmentedPoolPrevUsed + db.used) / 2) :
      db.used;
  });
  this.extensions = extensions || {};
  this.maxPayload = maxPayload || 0;
  this.currentPayloadLength = 0;
  this.state = {
    activeFragmentedOperation: null,
    lastFragment: false,
    masked: false,
    opcode: 0,
    fragmentedOperation: false
  };
  this.overflow = [];
  this.headerBuffer = new Buffer(10);
  this.expectOffset = 0;
  this.expectBuffer = null;
  this.expectHandler = null;
  this.currentMessage = [];
  this.currentMessageLength = 0;
  this.messageHandlers = [];
  this.expectHeader(2, this.processPacket);
  this.dead = false;
  this.processing = false;

  this.onerror = function() {};
  this.ontext = function() {};
  this.onbinary = function() {};
  this.onclose = function() {};
  this.onping = function() {};
  this.onpong = function() {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender" id="apidoc.element.osc.WebSocket.Sender">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>Sender
        <span class="apidocSignatureSpan">(socket, extensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Sender(socket, extensions) {
  if (this instanceof Sender === false) {
    throw new TypeError("Classes can't be function-called");
  }

  events.EventEmitter.call(this);

  this._socket = socket;
  this.extensions = extensions || {};
  this.firstFragment = true;
  this.compress = false;
  this.messageHandlers = [];
  this.processing = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Server" id="apidoc.element.osc.WebSocket.Server">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>Server
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketServer(options, callback) {
  if (this instanceof WebSocketServer === false) {
    return new WebSocketServer(options, callback);
  }

  events.EventEmitter.call(this);

  options = new Options({
    host: '0.0.0.0',
    port: null,
    server: null,
    verifyClient: null,
    handleProtocols: null,
    path: null,
    noServer: false,
    disableHixie: false,
    clientTracking: true,
    perMessageDeflate: true,
    maxPayload: 100 * 1024 * 1024
  }).merge(options);

  if (!options.isDefinedAndNonNull('port') &amp;&amp; !options.isDefinedAndNonNull('server') &amp;&amp; !options.value.noServer) {
    throw new TypeError('`port` or a `server` must be provided');
  }

  var self = this;

  if (options.isDefinedAndNonNull('port')) {
    this._server = http.createServer(function (req, res) {
      var body = http.STATUS_CODES[426];
      res.writeHead(426, {
        'Content-Length': body.length,
        'Content-Type': 'text/plain'
      });
      res.end(body);
    });
    this._server.allowHalfOpen = false;
    this._server.listen(options.value.port, options.value.host, callback);
    this._closeServer = function() { if (self._server) self._server.close(); };
  }
  else if (options.value.server) {
    this._server = options.value.server;
    if (options.value.path) {
      // take note of the path, to avoid collisions when multiple websocket servers are
      // listening on the same http server
      if (this._server._webSocketPaths &amp;&amp; options.value.server._webSocketPaths[options.value.path]) {
        throw new Error('two instances of WebSocketServer cannot listen on the same http server path');
      }
      if (typeof this._server._webSocketPaths !== 'object') {
        this._server._webSocketPaths = {};
      }
      this._server._webSocketPaths[options.value.path] = 1;
    }
  }
  if (this._server) {
    this._onceServerListening = function() { self.emit('listening'); };
    this._server.once('listening', this._onceServerListening);
  }

  if (typeof this._server != 'undefined') {
    this._onServerError = function(error) { self.emit('error', error) };
    this._server.on('error', this._onServerError);
    this._onServerUpgrade = function(req, socket, upgradeHead) {
      //copy upgradeHead to avoid retention of large slab buffers used in node core
      var head = new Buffer(upgradeHead.length);
      upgradeHead.copy(head);

      self.handleUpgrade(req, socket, head, function(client) {
        self.emit('connection'+req.url, client);
        self.emit('connection', client);
      });
    };
    this._server.on('upgrade', this._onServerUpgrade);
  }

  this.options = options.value;
  this.path = options.value.path;
  this.clients = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// and serve up a directory of static files.
var app = require("express").express(),
server = app.listen(8081);

app.use("/", express.static(__dirname + "/static"));

// Listen for Web Socket requests.
var wss = new WebSocket.<span class="apidocCodeKeywordSpan">Server</span>({
server: server
});

// Listen for Web Socket connections.
wss.on("connection", function (socket) {
var socketPort = new osc.WebSocketPort({
    socket: socket
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.buildHostHeader" id="apidoc.element.osc.WebSocket.buildHostHeader">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>buildHostHeader
        <span class="apidocSignatureSpan">(isSecure, hostname, port)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildHostHeader(isSecure, hostname, port) {
  var headerHost = hostname;
  if (hostname) {
    if ((isSecure &amp;&amp; (port != 443)) || (!isSecure &amp;&amp; (port != 80))){
      headerHost = headerHost + ':' + port;
    }
  }
  return headerHost;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.connect" id="apidoc.element.osc.WebSocket.connect">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>connect
        <span class="apidocSignatureSpan">(address, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function connect(address, fn) {
  var client = new WS(address);

  if (typeof fn === 'function') {
    client.on('open', fn);
  }

  return client;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.createConnection" id="apidoc.element.osc.WebSocket.createConnection">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>createConnection
        <span class="apidocSignatureSpan">(address, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function connect(address, fn) {
  var client = new WS(address);

  if (typeof fn === 'function') {
    client.on('open', fn);
  }

  return client;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.createServer" id="apidoc.element.osc.WebSocket.createServer">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>createServer
        <span class="apidocSignatureSpan">(options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createServer(options, fn) {
  var server = new WS.Server(options);

  if (typeof fn === 'function') {
    server.on('connection', fn);
  }

  return server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.super_" id="apidoc.element.osc.WebSocket.super_">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver" id="apidoc.module.osc.WebSocket.Receiver">module osc.WebSocket.Receiver</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.Receiver" id="apidoc.element.osc.WebSocket.Receiver.Receiver">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>Receiver
        <span class="apidocSignatureSpan">(extensions, maxPayload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Receiver(extensions, maxPayload) {
  if (this instanceof Receiver === false) {
    throw new TypeError("Classes can't be function-called");
  }
  if(typeof extensions==='number'){
    maxPayload=extensions;
    extensions={};
  }


  // memory pool for fragmented messages
  var fragmentedPoolPrevUsed = -1;
  this.fragmentedBufferPool = new BufferPool(1024, function(db, length) {
    return db.used + length;
  }, function(db) {
    return fragmentedPoolPrevUsed = fragmentedPoolPrevUsed &gt;= 0 ?
      Math.ceil((fragmentedPoolPrevUsed + db.used) / 2) :
      db.used;
  });

  // memory pool for unfragmented messages
  var unfragmentedPoolPrevUsed = -1;
  this.unfragmentedBufferPool = new BufferPool(1024, function(db, length) {
    return db.used + length;
  }, function(db) {
    return unfragmentedPoolPrevUsed = unfragmentedPoolPrevUsed &gt;= 0 ?
      Math.ceil((unfragmentedPoolPrevUsed + db.used) / 2) :
      db.used;
  });
  this.extensions = extensions || {};
  this.maxPayload = maxPayload || 0;
  this.currentPayloadLength = 0;
  this.state = {
    activeFragmentedOperation: null,
    lastFragment: false,
    masked: false,
    opcode: 0,
    fragmentedOperation: false
  };
  this.overflow = [];
  this.headerBuffer = new Buffer(10);
  this.expectOffset = 0;
  this.expectBuffer = null;
  this.expectHandler = null;
  this.currentMessage = [];
  this.currentMessageLength = 0;
  this.messageHandlers = [];
  this.expectHeader(2, this.processPacket);
  this.dead = false;
  this.processing = false;

  this.onerror = function() {};
  this.ontext = function() {};
  this.onbinary = function() {};
  this.onclose = function() {};
  this.onping = function() {};
  this.onpong = function() {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver.prototype" id="apidoc.module.osc.WebSocket.Receiver.prototype">module osc.WebSocket.Receiver.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.add" id="apidoc.element.osc.WebSocket.Receiver.prototype.add">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>add
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (data) {
  if (this.dead) return;
  var dataLength = data.length;
  if (dataLength == 0) return;
  if (this.expectBuffer == null) {
    this.overflow.push(data);
    return;
  }
  var toRead = Math.min(dataLength, this.expectBuffer.length - this.expectOffset);
  fastCopy(toRead, data, this.expectBuffer, this.expectOffset);
  this.expectOffset += toRead;
  if (toRead &lt; dataLength) {
    this.overflow.push(data.slice(toRead));
  }
  while (this.expectBuffer &amp;&amp; this.expectOffset == this.expectBuffer.length) {
    var bufferForHandler = this.expectBuffer;
    this.expectBuffer = null;
    this.expectOffset = 0;
    this.expectHandler.call(this, bufferForHandler);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.allocateFromPool" id="apidoc.element.osc.WebSocket.Receiver.prototype.allocateFromPool">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>allocateFromPool
        <span class="apidocSignatureSpan">(length, isFragmented)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allocateFromPool = function (length, isFragmented) {
  return (isFragmented ? this.fragmentedBufferPool : this.unfragmentedBufferPool).get(length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.applyExtensions" id="apidoc.element.osc.WebSocket.Receiver.prototype.applyExtensions">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>applyExtensions
        <span class="apidocSignatureSpan">(messageBuffer, fin, compressed, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyExtensions = function (messageBuffer, fin, compressed, callback) {
  var self = this;
  if (compressed) {
    this.extensions[PerMessageDeflate.extensionName].decompress(messageBuffer, fin, function(err, buffer) {
      if (self.dead) return;
      if (err) {
        callback(new Error('invalid compressed data'));
        return;
      }
      callback(null, buffer);
    });
  } else {
    callback(null, messageBuffer);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.cleanup" id="apidoc.element.osc.WebSocket.Receiver.prototype.cleanup">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>cleanup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanup = function () {
  this.dead = true;
  this.overflow = null;
  this.headerBuffer = null;
  this.expectBuffer = null;
  this.expectHandler = null;
  this.unfragmentedBufferPool = null;
  this.fragmentedBufferPool = null;
  this.state = null;
  this.currentMessage = null;
  this.onerror = null;
  this.ontext = null;
  this.onbinary = null;
  this.onclose = null;
  this.onping = null;
  this.onpong = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.endPacket" id="apidoc.element.osc.WebSocket.Receiver.prototype.endPacket">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>endPacket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endPacket = function () {
  if (this.dead) return;
  if (!this.state.fragmentedOperation) this.unfragmentedBufferPool.reset(true);
  else if (this.state.lastFragment) this.fragmentedBufferPool.reset(true);
  this.expectOffset = 0;
  this.expectBuffer = null;
  this.expectHandler = null;
  if (this.state.lastFragment &amp;&amp; this.state.opcode === this.state.activeFragmentedOperation) {
    // end current fragmented operation
    this.state.activeFragmentedOperation = null;
  }
  this.currentPayloadLength = 0;
  this.state.lastFragment = false;
  this.state.opcode = this.state.activeFragmentedOperation != null ? this.state.activeFragmentedOperation : 0;
  this.state.masked = false;
  this.expectHeader(2, this.processPacket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.error" id="apidoc.element.osc.WebSocket.Receiver.prototype.error">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>error
        <span class="apidocSignatureSpan">(reason, protocolErrorCode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (reason, protocolErrorCode) {
  if (this.dead) return;
  this.reset();
  if(typeof reason == 'string'){
    this.onerror(new Error(reason), protocolErrorCode);
  }
  else if(reason.constructor == Error){
    this.onerror(reason, protocolErrorCode);
  }
  else{
    this.onerror(new Error("An error occured"),protocolErrorCode);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.expectData" id="apidoc.element.osc.WebSocket.Receiver.prototype.expectData">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>expectData
        <span class="apidocSignatureSpan">(length, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expectData = function (length, handler) {
  if (length == 0) {
    handler(null);
    return;
  }
  this.expectBuffer = this.allocateFromPool(length, this.state.fragmentedOperation);
  this.expectHandler = handler;
  var toRead = length;
  while (toRead &gt; 0 &amp;&amp; this.overflow.length &gt; 0) {
    var fromOverflow = this.overflow.pop();
    if (toRead &lt; fromOverflow.length) this.overflow.push(fromOverflow.slice(toRead));
    var read = Math.min(fromOverflow.length, toRead);
    fastCopy(read, fromOverflow, this.expectBuffer, this.expectOffset);
    this.expectOffset += read;
    toRead -= read;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.expectHeader" id="apidoc.element.osc.WebSocket.Receiver.prototype.expectHeader">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>expectHeader
        <span class="apidocSignatureSpan">(length, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expectHeader = function (length, handler) {
  if (length == 0) {
    handler(null);
    return;
  }
  this.expectBuffer = this.headerBuffer.slice(this.expectOffset, this.expectOffset + length);
  this.expectHandler = handler;
  var toRead = length;
  while (toRead &gt; 0 &amp;&amp; this.overflow.length &gt; 0) {
    var fromOverflow = this.overflow.pop();
    if (toRead &lt; fromOverflow.length) this.overflow.push(fromOverflow.slice(toRead));
    var read = Math.min(fromOverflow.length, toRead);
    fastCopy(read, fromOverflow, this.expectBuffer, this.expectOffset);
    this.expectOffset += read;
    toRead -= read;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.flush" id="apidoc.element.osc.WebSocket.Receiver.prototype.flush">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function () {
  if (this.processing || this.dead) return;

  var handler = this.messageHandlers.shift();
  if (!handler) return;

  this.processing = true;
  var self = this;

  handler(function() {
    self.processing = false;
    self.flush();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.maxPayloadExceeded" id="apidoc.element.osc.WebSocket.Receiver.prototype.maxPayloadExceeded">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>maxPayloadExceeded
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxPayloadExceeded = function (length) {
  if (this.maxPayload=== undefined || this.maxPayload === null || this.maxPayload &lt; 1) {
    return false;
  }
  var fullLength = this.currentPayloadLength + length;
  if (fullLength &lt; this.maxPayload) {
    this.currentPayloadLength = fullLength;
    return false;
  }
  this.error('payload cannot exceed ' + this.maxPayload + ' bytes', 1009);
  this.messageBuffer=[];
  this.cleanup();

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.processPacket" id="apidoc.element.osc.WebSocket.Receiver.prototype.processPacket">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>processPacket
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processPacket = function (data) {
  if (this.extensions[PerMessageDeflate.extensionName]) {
    if ((data[0] &amp; 0x30) != 0) {
      this.error('reserved fields (2, 3) must be empty', 1002);
      return;
    }
  } else {
    if ((data[0] &amp; 0x70) != 0) {
      this.error('reserved fields must be empty', 1002);
      return;
    }
  }
  this.state.lastFragment = (data[0] &amp; 0x80) == 0x80;
  this.state.masked = (data[1] &amp; 0x80) == 0x80;
  var compressed = (data[0] &amp; 0x40) == 0x40;
  var opcode = data[0] &amp; 0xf;
  if (opcode === 0) {
    if (compressed) {
      this.error('continuation frame cannot have the Per-message Compressed bits', 1002);
      return;
    }
    // continuation frame
    this.state.fragmentedOperation = true;
    this.state.opcode = this.state.activeFragmentedOperation;
    if (!(this.state.opcode == 1 || this.state.opcode == 2)) {
      this.error('continuation frame cannot follow current opcode', 1002);
      return;
    }
  }
  else {
    if (opcode &lt; 3 &amp;&amp; this.state.activeFragmentedOperation != null) {
      this.error('data frames after the initial data frame must have opcode 0', 1002);
      return;
    }
    if (opcode &gt;= 8 &amp;&amp; compressed) {
      this.error('control frames cannot have the Per-message Compressed bits', 1002);
      return;
    }
    this.state.compressed = compressed;
    this.state.opcode = opcode;
    if (this.state.lastFragment === false) {
      this.state.fragmentedOperation = true;
      this.state.activeFragmentedOperation = opcode;
    }
    else this.state.fragmentedOperation = false;
  }
  var handler = opcodes[this.state.opcode];
  if (typeof handler == 'undefined') this.error('no handler for opcode ' + this.state.opcode, 1002);
  else {
    handler.start.call(this, data);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.reset" id="apidoc.element.osc.WebSocket.Receiver.prototype.reset">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
  if (this.dead) return;
  this.state = {
    activeFragmentedOperation: null,
    lastFragment: false,
    masked: false,
    opcode: 0,
    fragmentedOperation: false
  };
  this.fragmentedBufferPool.reset(true);
  this.unfragmentedBufferPool.reset(true);
  this.expectOffset = 0;
  this.expectBuffer = null;
  this.expectHandler = null;
  this.overflow = [];
  this.currentMessage = [];
  this.currentMessageLength = 0;
  this.messageHandlers = [];
  this.currentPayloadLength = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.unmask" id="apidoc.element.osc.WebSocket.Receiver.prototype.unmask">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>unmask
        <span class="apidocSignatureSpan">(mask, buf, binary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmask = function (mask, buf, binary) {
  if (mask != null &amp;&amp; buf != null) bufferUtil.unmask(buf, mask);
  if (binary) return buf;
  return buf != null ? buf.toString('utf8') : '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.add" id="apidoc.module.osc.WebSocket.Receiver.prototype.add">module osc.WebSocket.Receiver.prototype.add</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.add.add" id="apidoc.element.osc.WebSocket.Receiver.prototype.add.add">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>add
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (data) {
  if (this.dead) return;
  var dataLength = data.length;
  if (dataLength == 0) return;
  if (this.expectBuffer == null) {
    this.overflow.push(data);
    return;
  }
  var toRead = Math.min(dataLength, this.expectBuffer.length - this.expectOffset);
  fastCopy(toRead, data, this.expectBuffer, this.expectOffset);
  this.expectOffset += toRead;
  if (toRead &lt; dataLength) {
    this.overflow.push(data.slice(toRead));
  }
  while (this.expectBuffer &amp;&amp; this.expectOffset == this.expectBuffer.length) {
    var bufferForHandler = this.expectBuffer;
    this.expectBuffer = null;
    this.expectOffset = 0;
    this.expectHandler.call(this, bufferForHandler);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.allocateFromPool" id="apidoc.module.osc.WebSocket.Receiver.prototype.allocateFromPool">module osc.WebSocket.Receiver.prototype.allocateFromPool</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.allocateFromPool.allocateFromPool" id="apidoc.element.osc.WebSocket.Receiver.prototype.allocateFromPool.allocateFromPool">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>allocateFromPool
        <span class="apidocSignatureSpan">(length, isFragmented)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allocateFromPool = function (length, isFragmented) {
  return (isFragmented ? this.fragmentedBufferPool : this.unfragmentedBufferPool).get(length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.applyExtensions" id="apidoc.module.osc.WebSocket.Receiver.prototype.applyExtensions">module osc.WebSocket.Receiver.prototype.applyExtensions</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.applyExtensions.applyExtensions" id="apidoc.element.osc.WebSocket.Receiver.prototype.applyExtensions.applyExtensions">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>applyExtensions
        <span class="apidocSignatureSpan">(messageBuffer, fin, compressed, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyExtensions = function (messageBuffer, fin, compressed, callback) {
  var self = this;
  if (compressed) {
    this.extensions[PerMessageDeflate.extensionName].decompress(messageBuffer, fin, function(err, buffer) {
      if (self.dead) return;
      if (err) {
        callback(new Error('invalid compressed data'));
        return;
      }
      callback(null, buffer);
    });
  } else {
    callback(null, messageBuffer);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.cleanup" id="apidoc.module.osc.WebSocket.Receiver.prototype.cleanup">module osc.WebSocket.Receiver.prototype.cleanup</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.cleanup.cleanup" id="apidoc.element.osc.WebSocket.Receiver.prototype.cleanup.cleanup">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>cleanup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanup = function () {
  this.dead = true;
  this.overflow = null;
  this.headerBuffer = null;
  this.expectBuffer = null;
  this.expectHandler = null;
  this.unfragmentedBufferPool = null;
  this.fragmentedBufferPool = null;
  this.state = null;
  this.currentMessage = null;
  this.onerror = null;
  this.ontext = null;
  this.onbinary = null;
  this.onclose = null;
  this.onping = null;
  this.onpong = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.endPacket" id="apidoc.module.osc.WebSocket.Receiver.prototype.endPacket">module osc.WebSocket.Receiver.prototype.endPacket</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.endPacket.endPacket" id="apidoc.element.osc.WebSocket.Receiver.prototype.endPacket.endPacket">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>endPacket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endPacket = function () {
  if (this.dead) return;
  if (!this.state.fragmentedOperation) this.unfragmentedBufferPool.reset(true);
  else if (this.state.lastFragment) this.fragmentedBufferPool.reset(true);
  this.expectOffset = 0;
  this.expectBuffer = null;
  this.expectHandler = null;
  if (this.state.lastFragment &amp;&amp; this.state.opcode === this.state.activeFragmentedOperation) {
    // end current fragmented operation
    this.state.activeFragmentedOperation = null;
  }
  this.currentPayloadLength = 0;
  this.state.lastFragment = false;
  this.state.opcode = this.state.activeFragmentedOperation != null ? this.state.activeFragmentedOperation : 0;
  this.state.masked = false;
  this.expectHeader(2, this.processPacket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.error" id="apidoc.module.osc.WebSocket.Receiver.prototype.error">module osc.WebSocket.Receiver.prototype.error</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.error.error" id="apidoc.element.osc.WebSocket.Receiver.prototype.error.error">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>error
        <span class="apidocSignatureSpan">(reason, protocolErrorCode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (reason, protocolErrorCode) {
  if (this.dead) return;
  this.reset();
  if(typeof reason == 'string'){
    this.onerror(new Error(reason), protocolErrorCode);
  }
  else if(reason.constructor == Error){
    this.onerror(reason, protocolErrorCode);
  }
  else{
    this.onerror(new Error("An error occured"),protocolErrorCode);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.expectData" id="apidoc.module.osc.WebSocket.Receiver.prototype.expectData">module osc.WebSocket.Receiver.prototype.expectData</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.expectData.expectData" id="apidoc.element.osc.WebSocket.Receiver.prototype.expectData.expectData">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>expectData
        <span class="apidocSignatureSpan">(length, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expectData = function (length, handler) {
  if (length == 0) {
    handler(null);
    return;
  }
  this.expectBuffer = this.allocateFromPool(length, this.state.fragmentedOperation);
  this.expectHandler = handler;
  var toRead = length;
  while (toRead &gt; 0 &amp;&amp; this.overflow.length &gt; 0) {
    var fromOverflow = this.overflow.pop();
    if (toRead &lt; fromOverflow.length) this.overflow.push(fromOverflow.slice(toRead));
    var read = Math.min(fromOverflow.length, toRead);
    fastCopy(read, fromOverflow, this.expectBuffer, this.expectOffset);
    this.expectOffset += read;
    toRead -= read;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.expectHeader" id="apidoc.module.osc.WebSocket.Receiver.prototype.expectHeader">module osc.WebSocket.Receiver.prototype.expectHeader</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.expectHeader.expectHeader" id="apidoc.element.osc.WebSocket.Receiver.prototype.expectHeader.expectHeader">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>expectHeader
        <span class="apidocSignatureSpan">(length, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expectHeader = function (length, handler) {
  if (length == 0) {
    handler(null);
    return;
  }
  this.expectBuffer = this.headerBuffer.slice(this.expectOffset, this.expectOffset + length);
  this.expectHandler = handler;
  var toRead = length;
  while (toRead &gt; 0 &amp;&amp; this.overflow.length &gt; 0) {
    var fromOverflow = this.overflow.pop();
    if (toRead &lt; fromOverflow.length) this.overflow.push(fromOverflow.slice(toRead));
    var read = Math.min(fromOverflow.length, toRead);
    fastCopy(read, fromOverflow, this.expectBuffer, this.expectOffset);
    this.expectOffset += read;
    toRead -= read;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.flush" id="apidoc.module.osc.WebSocket.Receiver.prototype.flush">module osc.WebSocket.Receiver.prototype.flush</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.flush.flush" id="apidoc.element.osc.WebSocket.Receiver.prototype.flush.flush">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function () {
  if (this.processing || this.dead) return;

  var handler = this.messageHandlers.shift();
  if (!handler) return;

  this.processing = true;
  var self = this;

  handler(function() {
    self.processing = false;
    self.flush();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.maxPayloadExceeded" id="apidoc.module.osc.WebSocket.Receiver.prototype.maxPayloadExceeded">module osc.WebSocket.Receiver.prototype.maxPayloadExceeded</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.maxPayloadExceeded.maxPayloadExceeded" id="apidoc.element.osc.WebSocket.Receiver.prototype.maxPayloadExceeded.maxPayloadExceeded">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>maxPayloadExceeded
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxPayloadExceeded = function (length) {
  if (this.maxPayload=== undefined || this.maxPayload === null || this.maxPayload &lt; 1) {
    return false;
  }
  var fullLength = this.currentPayloadLength + length;
  if (fullLength &lt; this.maxPayload) {
    this.currentPayloadLength = fullLength;
    return false;
  }
  this.error('payload cannot exceed ' + this.maxPayload + ' bytes', 1009);
  this.messageBuffer=[];
  this.cleanup();

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.processPacket" id="apidoc.module.osc.WebSocket.Receiver.prototype.processPacket">module osc.WebSocket.Receiver.prototype.processPacket</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.processPacket.processPacket" id="apidoc.element.osc.WebSocket.Receiver.prototype.processPacket.processPacket">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>processPacket
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processPacket = function (data) {
  if (this.extensions[PerMessageDeflate.extensionName]) {
    if ((data[0] &amp; 0x30) != 0) {
      this.error('reserved fields (2, 3) must be empty', 1002);
      return;
    }
  } else {
    if ((data[0] &amp; 0x70) != 0) {
      this.error('reserved fields must be empty', 1002);
      return;
    }
  }
  this.state.lastFragment = (data[0] &amp; 0x80) == 0x80;
  this.state.masked = (data[1] &amp; 0x80) == 0x80;
  var compressed = (data[0] &amp; 0x40) == 0x40;
  var opcode = data[0] &amp; 0xf;
  if (opcode === 0) {
    if (compressed) {
      this.error('continuation frame cannot have the Per-message Compressed bits', 1002);
      return;
    }
    // continuation frame
    this.state.fragmentedOperation = true;
    this.state.opcode = this.state.activeFragmentedOperation;
    if (!(this.state.opcode == 1 || this.state.opcode == 2)) {
      this.error('continuation frame cannot follow current opcode', 1002);
      return;
    }
  }
  else {
    if (opcode &lt; 3 &amp;&amp; this.state.activeFragmentedOperation != null) {
      this.error('data frames after the initial data frame must have opcode 0', 1002);
      return;
    }
    if (opcode &gt;= 8 &amp;&amp; compressed) {
      this.error('control frames cannot have the Per-message Compressed bits', 1002);
      return;
    }
    this.state.compressed = compressed;
    this.state.opcode = opcode;
    if (this.state.lastFragment === false) {
      this.state.fragmentedOperation = true;
      this.state.activeFragmentedOperation = opcode;
    }
    else this.state.fragmentedOperation = false;
  }
  var handler = opcodes[this.state.opcode];
  if (typeof handler == 'undefined') this.error('no handler for opcode ' + this.state.opcode, 1002);
  else {
    handler.start.call(this, data);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.reset" id="apidoc.module.osc.WebSocket.Receiver.prototype.reset">module osc.WebSocket.Receiver.prototype.reset</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.reset.reset" id="apidoc.element.osc.WebSocket.Receiver.prototype.reset.reset">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
  if (this.dead) return;
  this.state = {
    activeFragmentedOperation: null,
    lastFragment: false,
    masked: false,
    opcode: 0,
    fragmentedOperation: false
  };
  this.fragmentedBufferPool.reset(true);
  this.unfragmentedBufferPool.reset(true);
  this.expectOffset = 0;
  this.expectBuffer = null;
  this.expectHandler = null;
  this.overflow = [];
  this.currentMessage = [];
  this.currentMessageLength = 0;
  this.messageHandlers = [];
  this.currentPayloadLength = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver.prototype.unmask" id="apidoc.module.osc.WebSocket.Receiver.prototype.unmask">module osc.WebSocket.Receiver.prototype.unmask</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.unmask.unmask" id="apidoc.element.osc.WebSocket.Receiver.prototype.unmask.unmask">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>unmask
        <span class="apidocSignatureSpan">(mask, buf, binary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmask = function (mask, buf, binary) {
  if (mask != null &amp;&amp; buf != null) bufferUtil.unmask(buf, mask);
  if (binary) return buf;
  return buf != null ? buf.toString('utf8') : '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Sender" id="apidoc.module.osc.WebSocket.Sender">module osc.WebSocket.Sender</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.Sender" id="apidoc.element.osc.WebSocket.Sender.Sender">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>Sender
        <span class="apidocSignatureSpan">(socket, extensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Sender(socket, extensions) {
  if (this instanceof Sender === false) {
    throw new TypeError("Classes can't be function-called");
  }

  events.EventEmitter.call(this);

  this._socket = socket;
  this.extensions = extensions || {};
  this.firstFragment = true;
  this.compress = false;
  this.messageHandlers = [];
  this.processing = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.super_" id="apidoc.element.osc.WebSocket.Sender.super_">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Sender.prototype" id="apidoc.module.osc.WebSocket.Sender.prototype">module osc.WebSocket.Sender.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.applyExtensions" id="apidoc.element.osc.WebSocket.Sender.prototype.applyExtensions">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>applyExtensions
        <span class="apidocSignatureSpan">(data, fin, compress, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyExtensions = function (data, fin, compress, callback) {
  if (compress &amp;&amp; data) {
    if ((data.buffer || data) instanceof ArrayBuffer) {
      data = getArrayBuffer(data);
    }
    this.extensions[PerMessageDeflate.extensionName].compress(data, fin, callback);
  } else {
    callback(null, data);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.close" id="apidoc.element.osc.WebSocket.Sender.prototype.close">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>close
        <span class="apidocSignatureSpan">(code, data, mask, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (code, data, mask, cb) {
  if (typeof code !== 'undefined') {
    if (typeof code !== 'number' ||
      !ErrorCodes.isValidErrorCode(code)) throw new Error('first argument must be a valid error code number');
  }
  code = code || 1000;
  var dataBuffer = new Buffer(2 + (data ? Buffer.byteLength(data) : 0));
  writeUInt16BE.call(dataBuffer, code, 0);
  if (dataBuffer.length &gt; 2) dataBuffer.write(data, 2);

  var self = this;
  this.messageHandlers.push(function(callback) {
    self.frameAndSend(0x8, dataBuffer, true, mask);
    callback();
    if (typeof cb == 'function') cb();
  });
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.flush" id="apidoc.element.osc.WebSocket.Sender.prototype.flush">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function () {
  if (this.processing) return;

  var handler = this.messageHandlers.shift();
  if (!handler) return;

  this.processing = true;

  var self = this;

  handler(function() {
    self.processing = false;
    self.flush();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.frameAndSend" id="apidoc.element.osc.WebSocket.Sender.prototype.frameAndSend">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>frameAndSend
        <span class="apidocSignatureSpan">(opcode, data, finalFragment, maskData, compressed, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">frameAndSend = function (opcode, data, finalFragment, maskData, compressed, cb) {
  var canModifyData = false;

  if (!data) {
    try {
      this._socket.write(new Buffer([opcode | (finalFragment ? 0x80 : 0), 0 | (maskData ? 0x80 : 0)].concat(maskData ? [0, 0, 0,
0] : [])), 'binary', cb);
    }
    catch (e) {
      if (typeof cb == 'function') cb(e);
      else this.emit('error', e);
    }
    return;
  }

  if (!Buffer.isBuffer(data)) {
    canModifyData = true;
    if (data &amp;&amp; (typeof data.byteLength !== 'undefined' || typeof data.buffer !== 'undefined')) {
      data = getArrayBuffer(data);
    } else {
      //
      // If people want to send a number, this would allocate the number in
      // bytes as memory size instead of storing the number as buffer value. So
      // we need to transform it to string in order to prevent possible
      // vulnerabilities / memory attacks.
      //
      if (typeof data === 'number') data = data.toString();

      data = new Buffer(data);
    }
  }

  var dataLength = data.length
    , dataOffset = maskData ? 6 : 2
    , secondByte = dataLength;

  if (dataLength &gt;= 65536) {
    dataOffset += 8;
    secondByte = 127;
  }
  else if (dataLength &gt; 125) {
    dataOffset += 2;
    secondByte = 126;
  }

  var mergeBuffers = dataLength &lt; 32768 || (maskData &amp;&amp; !canModifyData);
  var totalLength = mergeBuffers ? dataLength + dataOffset : dataOffset;
  var outputBuffer = new Buffer(totalLength);
  outputBuffer[0] = finalFragment ? opcode | 0x80 : opcode;
  if (compressed) outputBuffer[0] |= 0x40;

  switch (secondByte) {
    case 126:
      writeUInt16BE.call(outputBuffer, dataLength, 2);
      break;
    case 127:
      writeUInt32BE.call(outputBuffer, 0, 2);
      writeUInt32BE.call(outputBuffer, dataLength, 6);
  }

  if (maskData) {
    outputBuffer[1] = secondByte | 0x80;
    var mask = getRandomMask();
    outputBuffer[dataOffset - 4] = mask[0];
    outputBuffer[dataOffset - 3] = mask[1];
    outputBuffer[dataOffset - 2] = mask[2];
    outputBuffer[dataOffset - 1] = mask[3];
    if (mergeBuffers) {
      bufferUtil.mask(data, mask, outputBuffer, dataOffset, dataLength);
      try {
        this._socket.write(outputBuffer, 'binary', cb);
      }
      catch (e) {
        if (typeof cb == 'function') cb(e);
        else this.emit('error', e);
      }
    }
    else {
      bufferUtil.mask(data, mask, data, 0, dataLength);
      try {
        this._socket.write(outputBuffer, 'binary');
        this._socket.write(data, 'binary', cb);
      }
      catch (e) {
        if (typeof cb == 'function') cb(e);
        else this.emit('error', e);
      }
    }
  }
  else {
    outputBuffer[1] = secondByte;
    if (mergeBuffers) {
      data.copy(outputBuffer, dataOffset);
      try {
        this._socket.write(outputBuffer, 'binary', cb);
      }
      catch (e) {
        if (typeof cb == 'function') cb(e);
        else this.emit('error', e);
      }
    }
    else {
      try {
        this._socket.write(outputBuffer, 'binary');
        this._socket.write(data, 'binary', cb);
      }
      catch (e) {
        if (typeof cb == 'function') cb(e);
        else this.emit('error', e);
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.ping" id="apidoc.element.osc.WebSocket.Sender.prototype.ping">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>ping
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ping = function (data, options) {
  var mask = options &amp;&amp; options.mask;
  var self = this;
  this.messageHandlers.push(function(callback) {
    self.frameAndSend(0x9, data || '', true, mask);
    callback();
  });
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.pong" id="apidoc.element.osc.WebSocket.Sender.prototype.pong">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>pong
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pong = function (data, options) {
  var mask = options &amp;&amp; options.mask;
  var self = this;
  this.messageHandlers.push(function(callback) {
    self.frameAndSend(0xa, data || '', true, mask);
    callback();
  });
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.send" id="apidoc.element.osc.WebSocket.Sender.prototype.send">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>send
        <span class="apidocSignatureSpan">(data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (data, options, cb) {
  var finalFragment = options &amp;&amp; options.fin === false ? false : true;
  var mask = options &amp;&amp; options.mask;
  var compress = options &amp;&amp; options.compress;
  var opcode = options &amp;&amp; options.binary ? 2 : 1;
  if (this.firstFragment === false) {
    opcode = 0;
    compress = false;
  } else {
    this.firstFragment = false;
    this.compress = compress;
  }
  if (finalFragment) this.firstFragment = true

  var compressFragment = this.compress;

  var self = this;
  this.messageHandlers.push(function(callback) {
    self.applyExtensions(data, finalFragment, compressFragment, function(err, data) {
      if (err) {
        if (typeof cb == 'function') cb(err);
        else self.emit('error', err);
        return;
      }
      self.frameAndSend(opcode, data, finalFragment, mask, compress, cb);
      callback();
    });
  });
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

##### Sending OSC messages:
```javascript
// For most Ports, send() should only be called after the "ready" event fires.
oscPort.on("ready", function () {
    oscPort.<span class="apidocCodeKeywordSpan">send</span>({
        address: "/carrier/frequency",
        args: 440
    });
});
```

##### Sending OSC bundles:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Sender.prototype.applyExtensions" id="apidoc.module.osc.WebSocket.Sender.prototype.applyExtensions">module osc.WebSocket.Sender.prototype.applyExtensions</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.applyExtensions.applyExtensions" id="apidoc.element.osc.WebSocket.Sender.prototype.applyExtensions.applyExtensions">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>applyExtensions
        <span class="apidocSignatureSpan">(data, fin, compress, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyExtensions = function (data, fin, compress, callback) {
  if (compress &amp;&amp; data) {
    if ((data.buffer || data) instanceof ArrayBuffer) {
      data = getArrayBuffer(data);
    }
    this.extensions[PerMessageDeflate.extensionName].compress(data, fin, callback);
  } else {
    callback(null, data);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Sender.prototype.close" id="apidoc.module.osc.WebSocket.Sender.prototype.close">module osc.WebSocket.Sender.prototype.close</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.close.close" id="apidoc.element.osc.WebSocket.Sender.prototype.close.close">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>close
        <span class="apidocSignatureSpan">(code, data, mask, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (code, data, mask, cb) {
  if (typeof code !== 'undefined') {
    if (typeof code !== 'number' ||
      !ErrorCodes.isValidErrorCode(code)) throw new Error('first argument must be a valid error code number');
  }
  code = code || 1000;
  var dataBuffer = new Buffer(2 + (data ? Buffer.byteLength(data) : 0));
  writeUInt16BE.call(dataBuffer, code, 0);
  if (dataBuffer.length &gt; 2) dataBuffer.write(data, 2);

  var self = this;
  this.messageHandlers.push(function(callback) {
    self.frameAndSend(0x8, dataBuffer, true, mask);
    callback();
    if (typeof cb == 'function') cb();
  });
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Sender.prototype.flush" id="apidoc.module.osc.WebSocket.Sender.prototype.flush">module osc.WebSocket.Sender.prototype.flush</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.flush.flush" id="apidoc.element.osc.WebSocket.Sender.prototype.flush.flush">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function () {
  if (this.processing) return;

  var handler = this.messageHandlers.shift();
  if (!handler) return;

  this.processing = true;

  var self = this;

  handler(function() {
    self.processing = false;
    self.flush();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Sender.prototype.frameAndSend" id="apidoc.module.osc.WebSocket.Sender.prototype.frameAndSend">module osc.WebSocket.Sender.prototype.frameAndSend</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.frameAndSend.frameAndSend" id="apidoc.element.osc.WebSocket.Sender.prototype.frameAndSend.frameAndSend">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>frameAndSend
        <span class="apidocSignatureSpan">(opcode, data, finalFragment, maskData, compressed, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">frameAndSend = function (opcode, data, finalFragment, maskData, compressed, cb) {
  var canModifyData = false;

  if (!data) {
    try {
      this._socket.write(new Buffer([opcode | (finalFragment ? 0x80 : 0), 0 | (maskData ? 0x80 : 0)].concat(maskData ? [0, 0, 0,
0] : [])), 'binary', cb);
    }
    catch (e) {
      if (typeof cb == 'function') cb(e);
      else this.emit('error', e);
    }
    return;
  }

  if (!Buffer.isBuffer(data)) {
    canModifyData = true;
    if (data &amp;&amp; (typeof data.byteLength !== 'undefined' || typeof data.buffer !== 'undefined')) {
      data = getArrayBuffer(data);
    } else {
      //
      // If people want to send a number, this would allocate the number in
      // bytes as memory size instead of storing the number as buffer value. So
      // we need to transform it to string in order to prevent possible
      // vulnerabilities / memory attacks.
      //
      if (typeof data === 'number') data = data.toString();

      data = new Buffer(data);
    }
  }

  var dataLength = data.length
    , dataOffset = maskData ? 6 : 2
    , secondByte = dataLength;

  if (dataLength &gt;= 65536) {
    dataOffset += 8;
    secondByte = 127;
  }
  else if (dataLength &gt; 125) {
    dataOffset += 2;
    secondByte = 126;
  }

  var mergeBuffers = dataLength &lt; 32768 || (maskData &amp;&amp; !canModifyData);
  var totalLength = mergeBuffers ? dataLength + dataOffset : dataOffset;
  var outputBuffer = new Buffer(totalLength);
  outputBuffer[0] = finalFragment ? opcode | 0x80 : opcode;
  if (compressed) outputBuffer[0] |= 0x40;

  switch (secondByte) {
    case 126:
      writeUInt16BE.call(outputBuffer, dataLength, 2);
      break;
    case 127:
      writeUInt32BE.call(outputBuffer, 0, 2);
      writeUInt32BE.call(outputBuffer, dataLength, 6);
  }

  if (maskData) {
    outputBuffer[1] = secondByte | 0x80;
    var mask = getRandomMask();
    outputBuffer[dataOffset - 4] = mask[0];
    outputBuffer[dataOffset - 3] = mask[1];
    outputBuffer[dataOffset - 2] = mask[2];
    outputBuffer[dataOffset - 1] = mask[3];
    if (mergeBuffers) {
      bufferUtil.mask(data, mask, outputBuffer, dataOffset, dataLength);
      try {
        this._socket.write(outputBuffer, 'binary', cb);
      }
      catch (e) {
        if (typeof cb == 'function') cb(e);
        else this.emit('error', e);
      }
    }
    else {
      bufferUtil.mask(data, mask, data, 0, dataLength);
      try {
        this._socket.write(outputBuffer, 'binary');
        this._socket.write(data, 'binary', cb);
      }
      catch (e) {
        if (typeof cb == 'function') cb(e);
        else this.emit('error', e);
      }
    }
  }
  else {
    outputBuffer[1] = secondByte;
    if (mergeBuffers) {
      data.copy(outputBuffer, dataOffset);
      try {
        this._socket.write(outputBuffer, 'binary', cb);
      }
      catch (e) {
        if (typeof cb == 'function') cb(e);
        else this.emit('error', e);
      }
    }
    else {
      try {
        this._socket.write(outputBuffer, 'binary');
        this._socket.write(data, 'binary', cb);
      }
      catch (e) {
        if (typeof cb == 'function') cb(e);
        else this.emit('error', e);
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Sender.prototype.ping" id="apidoc.module.osc.WebSocket.Sender.prototype.ping">module osc.WebSocket.Sender.prototype.ping</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.ping.ping" id="apidoc.element.osc.WebSocket.Sender.prototype.ping.ping">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>ping
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ping = function (data, options) {
  var mask = options &amp;&amp; options.mask;
  var self = this;
  this.messageHandlers.push(function(callback) {
    self.frameAndSend(0x9, data || '', true, mask);
    callback();
  });
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Sender.prototype.pong" id="apidoc.module.osc.WebSocket.Sender.prototype.pong">module osc.WebSocket.Sender.prototype.pong</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.pong.pong" id="apidoc.element.osc.WebSocket.Sender.prototype.pong.pong">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>pong
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pong = function (data, options) {
  var mask = options &amp;&amp; options.mask;
  var self = this;
  this.messageHandlers.push(function(callback) {
    self.frameAndSend(0xa, data || '', true, mask);
    callback();
  });
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Sender.prototype.send" id="apidoc.module.osc.WebSocket.Sender.prototype.send">module osc.WebSocket.Sender.prototype.send</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.send.send" id="apidoc.element.osc.WebSocket.Sender.prototype.send.send">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>send
        <span class="apidocSignatureSpan">(data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (data, options, cb) {
  var finalFragment = options &amp;&amp; options.fin === false ? false : true;
  var mask = options &amp;&amp; options.mask;
  var compress = options &amp;&amp; options.compress;
  var opcode = options &amp;&amp; options.binary ? 2 : 1;
  if (this.firstFragment === false) {
    opcode = 0;
    compress = false;
  } else {
    this.firstFragment = false;
    this.compress = compress;
  }
  if (finalFragment) this.firstFragment = true

  var compressFragment = this.compress;

  var self = this;
  this.messageHandlers.push(function(callback) {
    self.applyExtensions(data, finalFragment, compressFragment, function(err, data) {
      if (err) {
        if (typeof cb == 'function') cb(err);
        else self.emit('error', err);
        return;
      }
      self.frameAndSend(opcode, data, finalFragment, mask, compress, cb);
      callback();
    });
  });
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

##### Sending OSC messages:
```javascript
// For most Ports, send() should only be called after the "ready" event fires.
oscPort.on("ready", function () {
    oscPort.<span class="apidocCodeKeywordSpan">send</span>({
        address: "/carrier/frequency",
        args: 440
    });
});
```

##### Sending OSC bundles:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Server" id="apidoc.module.osc.WebSocket.Server">module osc.WebSocket.Server</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Server.Server" id="apidoc.element.osc.WebSocket.Server.Server">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>Server
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketServer(options, callback) {
  if (this instanceof WebSocketServer === false) {
    return new WebSocketServer(options, callback);
  }

  events.EventEmitter.call(this);

  options = new Options({
    host: '0.0.0.0',
    port: null,
    server: null,
    verifyClient: null,
    handleProtocols: null,
    path: null,
    noServer: false,
    disableHixie: false,
    clientTracking: true,
    perMessageDeflate: true,
    maxPayload: 100 * 1024 * 1024
  }).merge(options);

  if (!options.isDefinedAndNonNull('port') &amp;&amp; !options.isDefinedAndNonNull('server') &amp;&amp; !options.value.noServer) {
    throw new TypeError('`port` or a `server` must be provided');
  }

  var self = this;

  if (options.isDefinedAndNonNull('port')) {
    this._server = http.createServer(function (req, res) {
      var body = http.STATUS_CODES[426];
      res.writeHead(426, {
        'Content-Length': body.length,
        'Content-Type': 'text/plain'
      });
      res.end(body);
    });
    this._server.allowHalfOpen = false;
    this._server.listen(options.value.port, options.value.host, callback);
    this._closeServer = function() { if (self._server) self._server.close(); };
  }
  else if (options.value.server) {
    this._server = options.value.server;
    if (options.value.path) {
      // take note of the path, to avoid collisions when multiple websocket servers are
      // listening on the same http server
      if (this._server._webSocketPaths &amp;&amp; options.value.server._webSocketPaths[options.value.path]) {
        throw new Error('two instances of WebSocketServer cannot listen on the same http server path');
      }
      if (typeof this._server._webSocketPaths !== 'object') {
        this._server._webSocketPaths = {};
      }
      this._server._webSocketPaths[options.value.path] = 1;
    }
  }
  if (this._server) {
    this._onceServerListening = function() { self.emit('listening'); };
    this._server.once('listening', this._onceServerListening);
  }

  if (typeof this._server != 'undefined') {
    this._onServerError = function(error) { self.emit('error', error) };
    this._server.on('error', this._onServerError);
    this._onServerUpgrade = function(req, socket, upgradeHead) {
      //copy upgradeHead to avoid retention of large slab buffers used in node core
      var head = new Buffer(upgradeHead.length);
      upgradeHead.copy(head);

      self.handleUpgrade(req, socket, head, function(client) {
        self.emit('connection'+req.url, client);
        self.emit('connection', client);
      });
    };
    this._server.on('upgrade', this._onServerUpgrade);
  }

  this.options = options.value;
  this.path = options.value.path;
  this.clients = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// and serve up a directory of static files.
var app = require("express").express(),
server = app.listen(8081);

app.use("/", express.static(__dirname + "/static"));

// Listen for Web Socket requests.
var wss = new WebSocket.<span class="apidocCodeKeywordSpan">Server</span>({
server: server
});

// Listen for Web Socket connections.
wss.on("connection", function (socket) {
var socketPort = new osc.WebSocketPort({
    socket: socket
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Server.super_" id="apidoc.element.osc.WebSocket.Server.super_">
        function <span class="apidocSignatureSpan">osc.WebSocket.Server.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Server.prototype" id="apidoc.module.osc.WebSocket.Server.prototype">module osc.WebSocket.Server.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Server.prototype.close" id="apidoc.element.osc.WebSocket.Server.prototype.close">
        function <span class="apidocSignatureSpan">osc.WebSocket.Server.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback) {
  // terminate all associated clients
  var error = null;
  try {
    for (var i = 0, l = this.clients.length; i &lt; l; ++i) {
      this.clients[i].terminate();
    }
  }
  catch (e) {
    error = e;
  }

  // remove path descriptor, if any
  if (this.path &amp;&amp; this._server._webSocketPaths) {
    delete this._server._webSocketPaths[this.path];
    if (Object.keys(this._server._webSocketPaths).length == 0) {
      delete this._server._webSocketPaths;
    }
  }

  // close the http server if it was internally created
  try {
    if (typeof this._closeServer !== 'undefined') {
      this._closeServer();
    }
  }
  finally {
    if (this._server) {
      this._server.removeListener('listening', this._onceServerListening);
      this._server.removeListener('error', this._onServerError);
      this._server.removeListener('upgrade', this._onServerUpgrade);
    }
    delete this._server;
  }
  if(callback)
    callback(error);
  else if(error)
    throw error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Server.prototype.handleUpgrade" id="apidoc.element.osc.WebSocket.Server.prototype.handleUpgrade">
        function <span class="apidocSignatureSpan">osc.WebSocket.Server.prototype.</span>handleUpgrade
        <span class="apidocSignatureSpan">(req, socket, upgradeHead, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleUpgrade = function (req, socket, upgradeHead, cb) {
  // check for wrong path
  if (this.options.path) {
    var u = url.parse(req.url);
    if (u &amp;&amp; u.pathname !== this.options.path) return;
  }

  if (typeof req.headers.upgrade === 'undefined' || req.headers.upgrade.toLowerCase() !== 'websocket') {
    abortConnection(socket, 400, 'Bad Request');
    return;
  }

  if (req.headers['sec-websocket-key1']) handleHixieUpgrade.apply(this, arguments);
  else handleHybiUpgrade.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Server.prototype.close" id="apidoc.module.osc.WebSocket.Server.prototype.close">module osc.WebSocket.Server.prototype.close</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Server.prototype.close.close" id="apidoc.element.osc.WebSocket.Server.prototype.close.close">
        function <span class="apidocSignatureSpan">osc.WebSocket.Server.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback) {
  // terminate all associated clients
  var error = null;
  try {
    for (var i = 0, l = this.clients.length; i &lt; l; ++i) {
      this.clients[i].terminate();
    }
  }
  catch (e) {
    error = e;
  }

  // remove path descriptor, if any
  if (this.path &amp;&amp; this._server._webSocketPaths) {
    delete this._server._webSocketPaths[this.path];
    if (Object.keys(this._server._webSocketPaths).length == 0) {
      delete this._server._webSocketPaths;
    }
  }

  // close the http server if it was internally created
  try {
    if (typeof this._closeServer !== 'undefined') {
      this._closeServer();
    }
  }
  finally {
    if (this._server) {
      this._server.removeListener('listening', this._onceServerListening);
      this._server.removeListener('error', this._onServerError);
      this._server.removeListener('upgrade', this._onServerUpgrade);
    }
    delete this._server;
  }
  if(callback)
    callback(error);
  else if(error)
    throw error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Server.prototype.handleUpgrade" id="apidoc.module.osc.WebSocket.Server.prototype.handleUpgrade">module osc.WebSocket.Server.prototype.handleUpgrade</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Server.prototype.handleUpgrade.handleUpgrade" id="apidoc.element.osc.WebSocket.Server.prototype.handleUpgrade.handleUpgrade">
        function <span class="apidocSignatureSpan">osc.WebSocket.Server.prototype.</span>handleUpgrade
        <span class="apidocSignatureSpan">(req, socket, upgradeHead, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleUpgrade = function (req, socket, upgradeHead, cb) {
  // check for wrong path
  if (this.options.path) {
    var u = url.parse(req.url);
    if (u &amp;&amp; u.pathname !== this.options.path) return;
  }

  if (typeof req.headers.upgrade === 'undefined' || req.headers.upgrade.toLowerCase() !== 'websocket') {
    abortConnection(socket, 400, 'Bad Request');
    return;
  }

  if (req.headers['sec-websocket-key1']) handleHixieUpgrade.apply(this, arguments);
  else handleHybiUpgrade.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.buildHostHeader" id="apidoc.module.osc.WebSocket.buildHostHeader">module osc.WebSocket.buildHostHeader</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.buildHostHeader.buildHostHeader" id="apidoc.element.osc.WebSocket.buildHostHeader.buildHostHeader">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>buildHostHeader
        <span class="apidocSignatureSpan">(isSecure, hostname, port)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildHostHeader(isSecure, hostname, port) {
  var headerHost = hostname;
  if (hostname) {
    if ((isSecure &amp;&amp; (port != 443)) || (!isSecure &amp;&amp; (port != 80))){
      headerHost = headerHost + ':' + port;
    }
  }
  return headerHost;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.createConnection" id="apidoc.module.osc.WebSocket.createConnection">module osc.WebSocket.createConnection</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.createConnection.createConnection" id="apidoc.element.osc.WebSocket.createConnection.createConnection">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>createConnection
        <span class="apidocSignatureSpan">(address, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function connect(address, fn) {
  var client = new WS(address);

  if (typeof fn === 'function') {
    client.on('open', fn);
  }

  return client;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.createServer" id="apidoc.module.osc.WebSocket.createServer">module osc.WebSocket.createServer</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.createServer.createServer" id="apidoc.element.osc.WebSocket.createServer.createServer">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>createServer
        <span class="apidocSignatureSpan">(options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createServer(options, fn) {
  var server = new WS.Server(options);

  if (typeof fn === 'function') {
    server.on('connection', fn);
  }

  return server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.prototype" id="apidoc.module.osc.WebSocket.prototype">module osc.WebSocket.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.addEventListener" id="apidoc.element.osc.WebSocket.prototype.addEventListener">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>addEventListener
        <span class="apidocSignatureSpan">(method, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addEventListener = function (method, listener) {
  var target = this;

  function onMessage (data, flags) {
    if (flags.binary &amp;&amp; this.binaryType === 'arraybuffer')
        data = new Uint8Array(data).buffer;
    listener.call(target, new MessageEvent(data, !!flags.binary, target));
  }

  function onClose (code, message) {
    listener.call(target, new CloseEvent(code, message, target));
  }

  function onError (event) {
    event.type = 'error';
    event.target = target;
    listener.call(target, event);
  }

  function onOpen () {
    listener.call(target, new OpenEvent(target));
  }

  if (typeof listener === 'function') {
    if (method === 'message') {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onMessage._listener = listener;
      this.on(method, onMessage);
    } else if (method === 'close') {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onClose._listener = listener;
      this.on(method, onClose);
    } else if (method === 'error') {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onError._listener = listener;
      this.on(method, onError);
    } else if (method === 'open') {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onOpen._listener = listener;
      this.on(method, onOpen);
    } else {
      this.on(method, listener);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.close" id="apidoc.element.osc.WebSocket.prototype.close">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>close
        <span class="apidocSignatureSpan">(code, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function close(code, data) {
  if (this.readyState === WebSocket.CLOSED) return;

  if (this.readyState === WebSocket.CONNECTING) {
    this.readyState = WebSocket.CLOSED;
    return;
  }

  if (this.readyState === WebSocket.CLOSING) {
    if (this._closeReceived &amp;&amp; this._isServer) {
      this.terminate();
    }
    return;
  }

  var self = this;
  try {
    this.readyState = WebSocket.CLOSING;
    this._closeCode = code;
    this._closeMessage = data;
    var mask = !this._isServer;
    this._sender.close(code, data, mask, function(err) {
      if (err) self.emit('error', err);

      if (self._closeReceived &amp;&amp; self._isServer) {
        self.terminate();
      } else {
        // ensure that the connection is cleaned up even when no response of closing handshake.
        clearTimeout(self._closeTimer);
        self._closeTimer = setTimeout(cleanupWebsocketResources.bind(self, true), closeTimeout);
      }
    });
  } catch (e) {
    this.emit('error', e);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.pause" id="apidoc.element.osc.WebSocket.prototype.pause">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pauser() {
  if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');

  return this._socket.pause();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.ping" id="apidoc.element.osc.WebSocket.prototype.ping">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>ping
        <span class="apidocSignatureSpan">(data, options, dontFailWhenClosed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ping(data, options, dontFailWhenClosed) {
  if (this.readyState !== WebSocket.OPEN) {
    if (dontFailWhenClosed === true) return;
    throw new Error('not opened');
  }

  options = options || {};

  if (typeof options.mask === 'undefined') options.mask = !this._isServer;

  this._sender.ping(data, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.pong" id="apidoc.element.osc.WebSocket.prototype.pong">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>pong
        <span class="apidocSignatureSpan">(data, options, dontFailWhenClosed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pong = function (data, options, dontFailWhenClosed) {
  if (this.readyState !== WebSocket.OPEN) {
    if (dontFailWhenClosed === true) return;
    throw new Error('not opened');
  }

  options = options || {};

  if (typeof options.mask === 'undefined') options.mask = !this._isServer;

  this._sender.pong(data, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.resume" id="apidoc.element.osc.WebSocket.prototype.resume">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resume() {
  if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');

  return this._socket.resume();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.send" id="apidoc.element.osc.WebSocket.prototype.send">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>send
        <span class="apidocSignatureSpan">(data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function send(data, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  if (this.readyState !== WebSocket.OPEN) {
    if (typeof cb === 'function') cb(new Error('not opened'));
    else throw new Error('not opened');
    return;
  }

  if (!data) data = '';
  if (this._queue) {
    var self = this;
    this._queue.push(function() { self.send(data, options, cb); });
    return;
  }

  options = options || {};
  options.fin = true;

  if (typeof options.binary === 'undefined') {
    options.binary = (data instanceof ArrayBuffer || data instanceof Buffer ||
      data instanceof Uint8Array ||
      data instanceof Uint16Array ||
      data instanceof Uint32Array ||
      data instanceof Int8Array ||
      data instanceof Int16Array ||
      data instanceof Int32Array ||
      data instanceof Float32Array ||
      data instanceof Float64Array);
  }

  if (typeof options.mask === 'undefined') options.mask = !this._isServer;
  if (typeof options.compress === 'undefined') options.compress = true;
  if (!this.extensions[PerMessageDeflate.extensionName]) {
    options.compress = false;
  }

  var readable = typeof stream.Readable === 'function'
    ? stream.Readable
    : stream.Stream;

  if (data instanceof readable) {
    startQueue(this);
    var self = this;

    sendStream(this, data, options, function send(error) {
      process.nextTick(function tock() {
        executeQueueSends(self);
      });

      if (typeof cb === 'function') cb(error);
    });
  } else {
    this._sender.send(data, options, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

##### Sending OSC messages:
```javascript
// For most Ports, send() should only be called after the "ready" event fires.
oscPort.on("ready", function () {
    oscPort.<span class="apidocCodeKeywordSpan">send</span>({
        address: "/carrier/frequency",
        args: 440
    });
});
```

##### Sending OSC bundles:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.stream" id="apidoc.element.osc.WebSocket.prototype.stream">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>stream
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stream(options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  var self = this;

  if (typeof cb !== 'function') throw new Error('callback must be provided');

  if (this.readyState !== WebSocket.OPEN) {
    if (typeof cb === 'function') cb(new Error('not opened'));
    else throw new Error('not opened');
    return;
  }

  if (this._queue) {
    this._queue.push(function () { self.stream(options, cb); });
    return;
  }

  options = options || {};

  if (typeof options.mask === 'undefined') options.mask = !this._isServer;
  if (typeof options.compress === 'undefined') options.compress = true;
  if (!this.extensions[PerMessageDeflate.extensionName]) {
    options.compress = false;
  }

  startQueue(this);

  function send(data, final) {
    try {
      if (self.readyState !== WebSocket.OPEN) throw new Error('not opened');
      options.fin = final === true;
      self._sender.send(data, options);
      if (!final) process.nextTick(cb.bind(null, null, send));
      else executeQueueSends(self);
    } catch (e) {
      if (typeof cb === 'function') cb(e);
      else {
        delete self._queue;
        self.emit('error', e);
      }
    }
  }

  process.nextTick(cb.bind(null, null, send));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.terminate" id="apidoc.element.osc.WebSocket.prototype.terminate">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>terminate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function terminate() {
  if (this.readyState === WebSocket.CLOSED) return;

  if (this._socket) {
    this.readyState = WebSocket.CLOSING;

    // End the connection
    try { this._socket.end(); }
    catch (e) {
      // Socket error during end() call, so just destroy it right now
      cleanupWebsocketResources.call(this, true);
      return;
    }

    // Add a timeout to ensure that the connection is completely
    // cleaned up within 30 seconds, even if the clean close procedure
    // fails for whatever reason
    // First cleanup any pre-existing timeout from an earlier "terminate" call,
    // if one exists.  Otherwise terminate calls in quick succession will leak timeouts
    // and hold the program open for `closeTimout` time.
    if (this._closeTimer) { clearTimeout(this._closeTimer); }
    this._closeTimer = setTimeout(cleanupWebsocketResources.bind(this, true), closeTimeout);
  } else if (this.readyState === WebSocket.CONNECTING) {
    cleanupWebsocketResources.call(this, true);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.prototype.addEventListener" id="apidoc.module.osc.WebSocket.prototype.addEventListener">module osc.WebSocket.prototype.addEventListener</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.addEventListener.addEventListener" id="apidoc.element.osc.WebSocket.prototype.addEventListener.addEventListener">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>addEventListener
        <span class="apidocSignatureSpan">(method, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addEventListener = function (method, listener) {
  var target = this;

  function onMessage (data, flags) {
    if (flags.binary &amp;&amp; this.binaryType === 'arraybuffer')
        data = new Uint8Array(data).buffer;
    listener.call(target, new MessageEvent(data, !!flags.binary, target));
  }

  function onClose (code, message) {
    listener.call(target, new CloseEvent(code, message, target));
  }

  function onError (event) {
    event.type = 'error';
    event.target = target;
    listener.call(target, event);
  }

  function onOpen () {
    listener.call(target, new OpenEvent(target));
  }

  if (typeof listener === 'function') {
    if (method === 'message') {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onMessage._listener = listener;
      this.on(method, onMessage);
    } else if (method === 'close') {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onClose._listener = listener;
      this.on(method, onClose);
    } else if (method === 'error') {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onError._listener = listener;
      this.on(method, onError);
    } else if (method === 'open') {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onOpen._listener = listener;
      this.on(method, onOpen);
    } else {
      this.on(method, listener);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.prototype.close" id="apidoc.module.osc.WebSocket.prototype.close">module osc.WebSocket.prototype.close</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.close.close" id="apidoc.element.osc.WebSocket.prototype.close.close">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>close
        <span class="apidocSignatureSpan">(code, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function close(code, data) {
  if (this.readyState === WebSocket.CLOSED) return;

  if (this.readyState === WebSocket.CONNECTING) {
    this.readyState = WebSocket.CLOSED;
    return;
  }

  if (this.readyState === WebSocket.CLOSING) {
    if (this._closeReceived &amp;&amp; this._isServer) {
      this.terminate();
    }
    return;
  }

  var self = this;
  try {
    this.readyState = WebSocket.CLOSING;
    this._closeCode = code;
    this._closeMessage = data;
    var mask = !this._isServer;
    this._sender.close(code, data, mask, function(err) {
      if (err) self.emit('error', err);

      if (self._closeReceived &amp;&amp; self._isServer) {
        self.terminate();
      } else {
        // ensure that the connection is cleaned up even when no response of closing handshake.
        clearTimeout(self._closeTimer);
        self._closeTimer = setTimeout(cleanupWebsocketResources.bind(self, true), closeTimeout);
      }
    });
  } catch (e) {
    this.emit('error', e);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.prototype.pause" id="apidoc.module.osc.WebSocket.prototype.pause">module osc.WebSocket.prototype.pause</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.pause.pause" id="apidoc.element.osc.WebSocket.prototype.pause.pause">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pauser() {
  if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');

  return this._socket.pause();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.prototype.ping" id="apidoc.module.osc.WebSocket.prototype.ping">module osc.WebSocket.prototype.ping</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.ping.ping" id="apidoc.element.osc.WebSocket.prototype.ping.ping">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>ping
        <span class="apidocSignatureSpan">(data, options, dontFailWhenClosed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ping(data, options, dontFailWhenClosed) {
  if (this.readyState !== WebSocket.OPEN) {
    if (dontFailWhenClosed === true) return;
    throw new Error('not opened');
  }

  options = options || {};

  if (typeof options.mask === 'undefined') options.mask = !this._isServer;

  this._sender.ping(data, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.prototype.pong" id="apidoc.module.osc.WebSocket.prototype.pong">module osc.WebSocket.prototype.pong</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.pong.pong" id="apidoc.element.osc.WebSocket.prototype.pong.pong">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>pong
        <span class="apidocSignatureSpan">(data, options, dontFailWhenClosed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pong = function (data, options, dontFailWhenClosed) {
  if (this.readyState !== WebSocket.OPEN) {
    if (dontFailWhenClosed === true) return;
    throw new Error('not opened');
  }

  options = options || {};

  if (typeof options.mask === 'undefined') options.mask = !this._isServer;

  this._sender.pong(data, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.prototype.resume" id="apidoc.module.osc.WebSocket.prototype.resume">module osc.WebSocket.prototype.resume</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.resume.resume" id="apidoc.element.osc.WebSocket.prototype.resume.resume">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resume() {
  if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');

  return this._socket.resume();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.prototype.send" id="apidoc.module.osc.WebSocket.prototype.send">module osc.WebSocket.prototype.send</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.send.send" id="apidoc.element.osc.WebSocket.prototype.send.send">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>send
        <span class="apidocSignatureSpan">(data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function send(data, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  if (this.readyState !== WebSocket.OPEN) {
    if (typeof cb === 'function') cb(new Error('not opened'));
    else throw new Error('not opened');
    return;
  }

  if (!data) data = '';
  if (this._queue) {
    var self = this;
    this._queue.push(function() { self.send(data, options, cb); });
    return;
  }

  options = options || {};
  options.fin = true;

  if (typeof options.binary === 'undefined') {
    options.binary = (data instanceof ArrayBuffer || data instanceof Buffer ||
      data instanceof Uint8Array ||
      data instanceof Uint16Array ||
      data instanceof Uint32Array ||
      data instanceof Int8Array ||
      data instanceof Int16Array ||
      data instanceof Int32Array ||
      data instanceof Float32Array ||
      data instanceof Float64Array);
  }

  if (typeof options.mask === 'undefined') options.mask = !this._isServer;
  if (typeof options.compress === 'undefined') options.compress = true;
  if (!this.extensions[PerMessageDeflate.extensionName]) {
    options.compress = false;
  }

  var readable = typeof stream.Readable === 'function'
    ? stream.Readable
    : stream.Stream;

  if (data instanceof readable) {
    startQueue(this);
    var self = this;

    sendStream(this, data, options, function send(error) {
      process.nextTick(function tock() {
        executeQueueSends(self);
      });

      if (typeof cb === 'function') cb(error);
    });
  } else {
    this._sender.send(data, options, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

##### Sending OSC messages:
```javascript
// For most Ports, send() should only be called after the "ready" event fires.
oscPort.on("ready", function () {
    oscPort.<span class="apidocCodeKeywordSpan">send</span>({
        address: "/carrier/frequency",
        args: 440
    });
});
```

##### Sending OSC bundles:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.prototype.stream" id="apidoc.module.osc.WebSocket.prototype.stream">module osc.WebSocket.prototype.stream</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.stream.stream" id="apidoc.element.osc.WebSocket.prototype.stream.stream">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>stream
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stream(options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  var self = this;

  if (typeof cb !== 'function') throw new Error('callback must be provided');

  if (this.readyState !== WebSocket.OPEN) {
    if (typeof cb === 'function') cb(new Error('not opened'));
    else throw new Error('not opened');
    return;
  }

  if (this._queue) {
    this._queue.push(function () { self.stream(options, cb); });
    return;
  }

  options = options || {};

  if (typeof options.mask === 'undefined') options.mask = !this._isServer;
  if (typeof options.compress === 'undefined') options.compress = true;
  if (!this.extensions[PerMessageDeflate.extensionName]) {
    options.compress = false;
  }

  startQueue(this);

  function send(data, final) {
    try {
      if (self.readyState !== WebSocket.OPEN) throw new Error('not opened');
      options.fin = final === true;
      self._sender.send(data, options);
      if (!final) process.nextTick(cb.bind(null, null, send));
      else executeQueueSends(self);
    } catch (e) {
      if (typeof cb === 'function') cb(e);
      else {
        delete self._queue;
        self.emit('error', e);
      }
    }
  }

  process.nextTick(cb.bind(null, null, send));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.prototype.terminate" id="apidoc.module.osc.WebSocket.prototype.terminate">module osc.WebSocket.prototype.terminate</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.terminate.terminate" id="apidoc.element.osc.WebSocket.prototype.terminate.terminate">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>terminate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function terminate() {
  if (this.readyState === WebSocket.CLOSED) return;

  if (this._socket) {
    this.readyState = WebSocket.CLOSING;

    // End the connection
    try { this._socket.end(); }
    catch (e) {
      // Socket error during end() call, so just destroy it right now
      cleanupWebsocketResources.call(this, true);
      return;
    }

    // Add a timeout to ensure that the connection is completely
    // cleaned up within 30 seconds, even if the clean close procedure
    // fails for whatever reason
    // First cleanup any pre-existing timeout from an earlier "terminate" call,
    // if one exists.  Otherwise terminate calls in quick succession will leak timeouts
    // and hold the program open for `closeTimout` time.
    if (this._closeTimer) { clearTimeout(this._closeTimer); }
    this._closeTimer = setTimeout(cleanupWebsocketResources.bind(this, true), closeTimeout);
  } else if (this.readyState === WebSocket.CONNECTING) {
    cleanupWebsocketResources.call(this, true);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocketPort" id="apidoc.module.osc.WebSocketPort">module osc.WebSocketPort</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.WebSocketPort" id="apidoc.element.osc.WebSocketPort.WebSocketPort">
        function <span class="apidocSignatureSpan">osc.</span>WebSocketPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocketPort = function (options) {
    osc.Port.call(this, options);
    this.on("open", this.listen.bind(this));

    this.socket = options.socket;
    if (this.socket) {
        if (this.socket.readyState === 1) {
            osc.WebSocketPort.setupSocketForBinary(this.socket);
            this.emit("open", this.socket);
        } else {
            this.open();
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &lt;/head&gt;
    &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
```

##### Creating an OSC Web Socket Port object:
```javascript
var oscPort = new osc.<span class="apidocCodeKeywordSpan">WebSocketPort</span>({
    url: "ws://localhost:8081" // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.open();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.setupSocketForBinary" id="apidoc.element.osc.WebSocketPort.setupSocketForBinary">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.</span>setupSocketForBinary
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupSocketForBinary = function (socket) {
    socket.binaryType = osc.isNode ? "nodebuffer" : "arraybuffer";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocketPort.prototype" id="apidoc.module.osc.WebSocketPort.prototype">module osc.WebSocketPort.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.close" id="apidoc.element.osc.WebSocketPort.prototype.close">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>close
        <span class="apidocSignatureSpan">(code, reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (code, reason) {
    this.socket.close(code, reason);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.constructor" id="apidoc.element.osc.WebSocketPort.prototype.constructor">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (options) {
    osc.Port.call(this, options);
    this.on("open", this.listen.bind(this));

    this.socket = options.socket;
    if (this.socket) {
        if (this.socket.readyState === 1) {
            osc.WebSocketPort.setupSocketForBinary(this.socket);
            this.emit("open", this.socket);
        } else {
            this.open();
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.listen" id="apidoc.element.osc.WebSocketPort.prototype.listen">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
    var that = this;
    this.socket.onmessage = function (e) {
        that.emit("data", e.data, e);
    };

    this.socket.onerror = function (err) {
        that.emit("error", err);
    };

    this.socket.onclose = function (e) {
        that.emit("close", e);
    };

    that.emit("ready");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var osc = require("osc"),
    http = require("http"),
    WebSocket = require("ws");

// Create an Express server app
// and serve up a directory of static files.
var app = require("express").express(),
    server = app.<span class="apidocCodeKeywordSpan">listen</span>(8081);

app.use("/", express.static(__dirname + "/static"));

// Listen for Web Socket requests.
var wss = new WebSocket.Server({
    server: server
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.open" id="apidoc.element.osc.WebSocketPort.prototype.open">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
    if (!this.socket || this.socket.readyState &gt; 1) {
        this.socket = new osc.WebSocket(this.options.url);
    }

    osc.WebSocketPort.setupSocketForBinary(this.socket);

    var that = this;
    this.socket.onopen = function () {
        that.emit("open", that.socket);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oscPort = new osc.WebSocketPort({
    url: "ws://localhost:8081" // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.<span class="apidocCodeKeywordSpan">open</span>();
```

##### Listening for incoming OSC messages:
```javascript
oscPort.on("message", function (oscMsg) {
    console.log("An OSC message just arrived!", oscMsg);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.sendRaw" id="apidoc.element.osc.WebSocketPort.prototype.sendRaw">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>sendRaw
        <span class="apidocSignatureSpan">(encoded)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendRaw = function (encoded) {
    if (!this.socket || this.socket.readyState !== 1) {
        osc.fireClosedPortSendError(this);
        return;
    }

    this.socket.send(encoded);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocketPort.prototype.close" id="apidoc.module.osc.WebSocketPort.prototype.close">module osc.WebSocketPort.prototype.close</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.close.close" id="apidoc.element.osc.WebSocketPort.prototype.close.close">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>close
        <span class="apidocSignatureSpan">(code, reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (code, reason) {
    this.socket.close(code, reason);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocketPort.prototype.listen" id="apidoc.module.osc.WebSocketPort.prototype.listen">module osc.WebSocketPort.prototype.listen</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.listen.listen" id="apidoc.element.osc.WebSocketPort.prototype.listen.listen">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
    var that = this;
    this.socket.onmessage = function (e) {
        that.emit("data", e.data, e);
    };

    this.socket.onerror = function (err) {
        that.emit("error", err);
    };

    this.socket.onclose = function (e) {
        that.emit("close", e);
    };

    that.emit("ready");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var osc = require("osc"),
    http = require("http"),
    WebSocket = require("ws");

// Create an Express server app
// and serve up a directory of static files.
var app = require("express").express(),
    server = app.<span class="apidocCodeKeywordSpan">listen</span>(8081);

app.use("/", express.static(__dirname + "/static"));

// Listen for Web Socket requests.
var wss = new WebSocket.Server({
    server: server
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocketPort.prototype.open" id="apidoc.module.osc.WebSocketPort.prototype.open">module osc.WebSocketPort.prototype.open</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.open.open" id="apidoc.element.osc.WebSocketPort.prototype.open.open">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
    if (!this.socket || this.socket.readyState &gt; 1) {
        this.socket = new osc.WebSocket(this.options.url);
    }

    osc.WebSocketPort.setupSocketForBinary(this.socket);

    var that = this;
    this.socket.onopen = function () {
        that.emit("open", that.socket);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oscPort = new osc.WebSocketPort({
    url: "ws://localhost:8081" // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.<span class="apidocCodeKeywordSpan">open</span>();
```

##### Listening for incoming OSC messages:
```javascript
oscPort.on("message", function (oscMsg) {
    console.log("An OSC message just arrived!", oscMsg);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocketPort.prototype.sendRaw" id="apidoc.module.osc.WebSocketPort.prototype.sendRaw">module osc.WebSocketPort.prototype.sendRaw</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.sendRaw.sendRaw" id="apidoc.element.osc.WebSocketPort.prototype.sendRaw.sendRaw">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>sendRaw
        <span class="apidocSignatureSpan">(encoded)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendRaw = function (encoded) {
    if (!this.socket || this.socket.readyState !== 1) {
        osc.fireClosedPortSendError(this);
        return;
    }

    this.socket.send(encoded);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocketPort.setupSocketForBinary" id="apidoc.module.osc.WebSocketPort.setupSocketForBinary">module osc.WebSocketPort.setupSocketForBinary</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.setupSocketForBinary.setupSocketForBinary" id="apidoc.element.osc.WebSocketPort.setupSocketForBinary.setupSocketForBinary">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.</span>setupSocketForBinary
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupSocketForBinary = function (socket) {
    socket.binaryType = osc.isNode ? "nodebuffer" : "arraybuffer";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.addDataPart" id="apidoc.module.osc.addDataPart">module osc.addDataPart</a></h1>


    <h2>
        <a href="#apidoc.element.osc.addDataPart.addDataPart" id="apidoc.element.osc.addDataPart.addDataPart">
        function <span class="apidocSignatureSpan">osc.</span>addDataPart
        <span class="apidocSignatureSpan">(dataPart, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addDataPart = function (dataPart, dataCollection) {
    dataCollection.parts.push(dataPart);
    dataCollection.byteLength += dataPart.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    var type = arg.type,
        writer = osc.argumentTypes[type].writer;

    if (writer) {
        var data = osc[writer](arg.value);
        osc.<span class="apidocCodeKeywordSpan">addDataPart</span>(data, dataCollection);
    }

    return arg.type;
};

// Unsupported, non-API function.
osc.collectArguments = function (args, options, dataCollection) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.annotateArguments" id="apidoc.module.osc.annotateArguments">module osc.annotateArguments</a></h1>


    <h2>
        <a href="#apidoc.element.osc.annotateArguments.annotateArguments" id="apidoc.element.osc.annotateArguments.annotateArguments">
        function <span class="apidocSignatureSpan">osc.</span>annotateArguments
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">annotateArguments = function (args) {
    var annotated = [];

    for (var i = 0; i &lt; args.length; i++) {
        var arg = args[i],
            msgArg;

        if (typeof (arg) === "object" &amp;&amp; arg.type &amp;&amp; arg.value !== undefined) {
            // We've got an explicitly typed argument.
            msgArg = arg;
        } else if (osc.isArray(arg)) {
            // We've got an array of arguments,
            // so they each need to be inferred and expanded.
            msgArg = osc.annotateArguments(arg);
        } else {
            var oscType = osc.inferTypeForArgument(arg);
            msgArg = {
                type: oscType,
                value: arg
            };
        }

        annotated.push(msgArg);
    }

    return annotated;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

dataCollection = dataCollection || {
    byteLength: 0,
    parts: []
};

if (!options.metadata) {
    args = osc.<span class="apidocCodeKeywordSpan">annotateArguments</span>(args);
}

var typeTagString = ",",
    currPartIdx = dataCollection.parts.length;

for (var i = 0; i &lt; args.length; i++) {
    var arg = args[i];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.byteArray" id="apidoc.module.osc.byteArray">module osc.byteArray</a></h1>


    <h2>
        <a href="#apidoc.element.osc.byteArray.byteArray" id="apidoc.element.osc.byteArray.byteArray">
        function <span class="apidocSignatureSpan">osc.</span>byteArray
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">byteArray = function (obj) {
    if (obj instanceof Uint8Array) {
        return obj;
    }

    var buf = obj.buffer ? obj.buffer : obj;

    if (!(buf instanceof ArrayBuffer) &amp;&amp; (typeof buf.length === "undefined" || typeof buf === "string")) {
        throw new Error("Can't wrap a non-array-like object as Uint8Array. Object was: " +
            JSON.stringify(obj, null, 2));
    }


    // TODO gh-39: This is a potentially unsafe algorithm;
    // if we're getting anything other than a TypedArrayView (such as a DataView),
    // we really need to determine the range of the view it is viewing.
    return new Uint8Array(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.emit("error", err);
}

return encoded;
    };

    p.decodeOSC = function (data, packetInfo) {
data = osc.<span class="apidocCodeKeywordSpan">byteArray</span>(data);
this.emit("raw", data, packetInfo);

try {
    var packet = osc.readPacket(data, this.options);
    this.emit("osc", packet, packetInfo);
    osc.firePacketEvents(this, packet, undefined, packetInfo);
} catch (err) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.collectArguments" id="apidoc.module.osc.collectArguments">module osc.collectArguments</a></h1>


    <h2>
        <a href="#apidoc.element.osc.collectArguments.collectArguments" id="apidoc.element.osc.collectArguments.collectArguments">
        function <span class="apidocSignatureSpan">osc.</span>collectArguments
        <span class="apidocSignatureSpan">(args, options, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectArguments = function (args, options, dataCollection) {
    if (!osc.isArray(args)) {
        args = typeof args === "undefined" ? [] : [args];
    }

    dataCollection = dataCollection || {
        byteLength: 0,
        parts: []
    };

    if (!options.metadata) {
        args = osc.annotateArguments(args);
    }

    var typeTagString = ",",
        currPartIdx = dataCollection.parts.length;

    for (var i = 0; i &lt; args.length; i++) {
        var arg = args[i];
        typeTagString += osc.writeArgument(arg, dataCollection);
    }

    var typeData = osc.writeString(typeTagString);
    dataCollection.byteLength += typeData.byteLength;
    dataCollection.parts.splice(currPartIdx, 0, typeData);

    return dataCollection;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Writes the specified arguments.
 *
 * @param {Array} args an array of arguments
 * @param {Object} options options for writing
 * @return {Uint8Array} a buffer containing the OSC-formatted argument type tag and values
 */
osc.writeArguments = function (args, options) {
    var argCollection = osc.<span class="apidocCodeKeywordSpan">collectArguments</span>(args, options);
    return osc.joinParts(argCollection);
};

// Unsupported, non-API function.
osc.joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.collectBundlePackets" id="apidoc.module.osc.collectBundlePackets">module osc.collectBundlePackets</a></h1>


    <h2>
        <a href="#apidoc.element.osc.collectBundlePackets.collectBundlePackets" id="apidoc.element.osc.collectBundlePackets.collectBundlePackets">
        function <span class="apidocSignatureSpan">osc.</span>collectBundlePackets
        <span class="apidocSignatureSpan">(bundle, options, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectBundlePackets = function (bundle, options, dataCollection) {
    dataCollection = dataCollection || {
        byteLength: 0,
        parts: []
    };

    osc.addDataPart(osc.writeString("#bundle"), dataCollection);
    osc.addDataPart(osc.writeTimeTag(bundle.timeTag), dataCollection);

    for (var i = 0; i &lt; bundle.packets.length; i++) {
        var packet = bundle.packets[i],
            collector = packet.address ? osc.collectMessageParts : osc.collectBundlePackets,
            packetCollection = collector(packet, options);

        dataCollection.byteLength += packetCollection.byteLength;
        osc.addDataPart(osc.writeInt32(packetCollection.byteLength), dataCollection);
        dataCollection.parts = dataCollection.parts.concat(packetCollection.parts);
    }

    return dataCollection;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
osc.writeBundle = function (bundle, options) {
    if (!osc.isValidBundle(bundle)) {
        throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. " +
            "Bundle was: " + JSON.stringify(bundle, null, 2));
    }

    options = options || osc.defaults;
    var bundleCollection = osc.<span class="apidocCodeKeywordSpan">collectBundlePackets</span>(bundle, options);

    return osc.joinParts(bundleCollection);
};

osc.isValidBundle = function (bundle) {
    return bundle.timeTag !== undefined &amp;&amp; bundle.packets !== undefined;
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.collectMessageParts" id="apidoc.module.osc.collectMessageParts">module osc.collectMessageParts</a></h1>


    <h2>
        <a href="#apidoc.element.osc.collectMessageParts.collectMessageParts" id="apidoc.element.osc.collectMessageParts.collectMessageParts">
        function <span class="apidocSignatureSpan">osc.</span>collectMessageParts
        <span class="apidocSignatureSpan">(msg, options, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectMessageParts = function (msg, options, dataCollection) {
    dataCollection = dataCollection || {
        byteLength: 0,
        parts: []
    };

    osc.addDataPart(osc.writeString(msg.address), dataCollection);
    return osc.collectArguments(msg.args, options, dataCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    options = options || osc.defaults;

    if (!osc.isValidMessage(msg)) {
        throw new Error("An OSC message must contain a valid address. Message was: " +
            JSON.stringify(msg, null, 2));
    }

    var msgCollection = osc.<span class="apidocCodeKeywordSpan">collectMessageParts</span>(msg, options);
    return osc.joinParts(msgCollection);
};

osc.isValidMessage = function (msg) {
    return msg.address &amp;&amp; msg.address.indexOf("/") === 0;
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.copyByteArray" id="apidoc.module.osc.copyByteArray">module osc.copyByteArray</a></h1>


    <h2>
        <a href="#apidoc.element.osc.copyByteArray.copyByteArray" id="apidoc.element.osc.copyByteArray.copyByteArray">
        function <span class="apidocSignatureSpan">osc.</span>copyByteArray
        <span class="apidocSignatureSpan">(source, target, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copyByteArray = function (source, target, offset) {
    if (osc.isTypedArrayView(source) &amp;&amp; osc.isTypedArrayView(target)) {
        target.set(source, offset);
    } else {
        var start = offset === undefined ? 0 : offset,
            len = Math.min(target.length - offset, source.length);

        for (var i = 0, j = start; i &lt; len; i++, j++) {
            target[j] = source[i];
        }
    }

    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
osc.joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
        offset = 0;

    for (var i = 0; i &lt; parts.length; i++) {
        var part = parts[i];
        osc.<span class="apidocCodeKeywordSpan">copyByteArray</span>(part, buf, offset);
        offset += part.length;
    }

    return buf;
};

// Unsupported, non-API function.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.dataView" id="apidoc.module.osc.dataView">module osc.dataView</a></h1>


    <h2>
        <a href="#apidoc.element.osc.dataView.dataView" id="apidoc.element.osc.dataView.dataView">
        function <span class="apidocSignatureSpan">osc.</span>dataView
        <span class="apidocSignatureSpan">(obj, offset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dataView = function (obj, offset, length) {
    if (obj.buffer) {
        return new DataView(obj.buffer, offset, length);
    }

    if (obj instanceof ArrayBuffer) {
        return new DataView(obj, offset, length);
    }

    return new DataView(new Uint8Array(obj), offset, length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} [options] read options
 * @param {Object} [offsetState] an offsetState object that stores the current offset into dv
 * @return {Object} the OSC message, formatted as a JavaScript object containing "address" and "args" properties
 */
osc.readMessage = function (data, options, offsetState) {
    options = options || osc.defaults;

    var dv = osc.<span class="apidocCodeKeywordSpan">dataView</span>(data, data.byteOffset, data.byteLength);
    offsetState = offsetState || {
        idx: 0
    };

    var address = osc.readString(dv, offsetState);
    return osc.readMessageContents(address, dv, options, offsetState);
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.fireBundleEvents" id="apidoc.module.osc.fireBundleEvents">module osc.fireBundleEvents</a></h1>


    <h2>
        <a href="#apidoc.element.osc.fireBundleEvents.fireBundleEvents" id="apidoc.element.osc.fireBundleEvents.fireBundleEvents">
        function <span class="apidocSignatureSpan">osc.</span>fireBundleEvents
        <span class="apidocSignatureSpan">(port, bundle, timeTag, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fireBundleEvents = function (port, bundle, timeTag, packetInfo) {
    port.emit("bundle", bundle, timeTag, packetInfo);
    for (var i = 0; i &lt; bundle.packets.length; i++) {
        var packet = bundle.packets[i];
        osc.firePacketEvents(port, packet, bundle.timeTag, packetInfo);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
"use strict";

// Unsupported, non-API function.
osc.firePacketEvents = function (port, packet, timeTag, packetInfo) {
    if (packet.address) {
        port.emit("message", packet, timeTag, packetInfo);
    } else {
        osc.<span class="apidocCodeKeywordSpan">fireBundleEvents</span>(port, packet, timeTag, packetInfo);
    }
};

// Unsupported, non-API function.
osc.fireBundleEvents = function (port, bundle, timeTag, packetInfo) {
    port.emit("bundle", bundle, timeTag, packetInfo);
    for (var i = 0; i &lt; bundle.packets.length; i++) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.fireClosedPortSendError" id="apidoc.module.osc.fireClosedPortSendError">module osc.fireClosedPortSendError</a></h1>


    <h2>
        <a href="#apidoc.element.osc.fireClosedPortSendError.fireClosedPortSendError" id="apidoc.element.osc.fireClosedPortSendError.fireClosedPortSendError">
        function <span class="apidocSignatureSpan">osc.</span>fireClosedPortSendError
        <span class="apidocSignatureSpan">(port, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fireClosedPortSendError = function (port, msg) {
    msg = msg || "Can't send packets on a closed osc.Port object. Please open (or reopen) this Port by calling open().";

    port.emit("error", msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.firePacketEvents" id="apidoc.module.osc.firePacketEvents">module osc.firePacketEvents</a></h1>


    <h2>
        <a href="#apidoc.element.osc.firePacketEvents.firePacketEvents" id="apidoc.element.osc.firePacketEvents.firePacketEvents">
        function <span class="apidocSignatureSpan">osc.</span>firePacketEvents
        <span class="apidocSignatureSpan">(port, packet, timeTag, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">firePacketEvents = function (port, packet, timeTag, packetInfo) {
    if (packet.address) {
        port.emit("message", packet, timeTag, packetInfo);
    } else {
        osc.fireBundleEvents(port, packet, timeTag, packetInfo);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };

    // Unsupported, non-API function.
    osc.fireBundleEvents = function (port, bundle, timeTag, packetInfo) {
port.emit("bundle", bundle, timeTag, packetInfo);
for (var i = 0; i &lt; bundle.packets.length; i++) {
    var packet = bundle.packets[i];
    osc.<span class="apidocCodeKeywordSpan">firePacketEvents</span>(port, packet, bundle.timeTag, packetInfo);
}
    };

    osc.fireClosedPortSendError = function (port, msg) {
msg = msg || "Can't send packets on a closed osc.Port object. Please open (or reopen) this Port by calling open()."
;;

port.emit("error", msg);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.inferTypeForArgument" id="apidoc.module.osc.inferTypeForArgument">module osc.inferTypeForArgument</a></h1>


    <h2>
        <a href="#apidoc.element.osc.inferTypeForArgument.inferTypeForArgument" id="apidoc.element.osc.inferTypeForArgument.inferTypeForArgument">
        function <span class="apidocSignatureSpan">osc.</span>inferTypeForArgument
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inferTypeForArgument = function (arg) {
    var type = typeof arg;

    // TODO: This is freaking hideous.
    switch (type) {
        case "boolean":
            return arg ? "T" : "F";
        case "string":
            return "s";
        case "number":
            return "f";
        case "undefined":
            return "N";
        case "object":
            if (arg === null) {
                return "N";
            } else if (arg instanceof Uint8Array ||
                arg instanceof ArrayBuffer) {
                return "b";
            } else if (typeof arg.high === "number" &amp;&amp; typeof arg.low === "number") {
                return "h";
            }
            break;
    }

    throw new Error("Can't infer OSC argument type for value: " +
        JSON.stringify(arg, null, 2));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // We've got an explicitly typed argument.
    msgArg = arg;
} else if (osc.isArray(arg)) {
    // We've got an array of arguments,
    // so they each need to be inferred and expanded.
    msgArg = osc.annotateArguments(arg);
} else {
    var oscType = osc.<span class="apidocCodeKeywordSpan">inferTypeForArgument</span>(arg);
    msgArg = {
        type: oscType,
        value: arg
    };
}

annotated.push(msgArg);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.isArray" id="apidoc.module.osc.isArray">module osc.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.osc.isArray.isArray" id="apidoc.element.osc.isArray.isArray">
        function <span class="apidocSignatureSpan">osc.</span>isArray
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (obj) {
    return obj &amp;&amp; Object.prototype.toString.call(obj) === "[object Array]";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

typeTag += "]";

return typeTag;
    };

    osc.writeArgument = function (arg, dataCollection) {
if (osc.<span class="apidocCodeKeywordSpan">isArray</span>(arg)) {
    return osc.writeArrayArguments(arg, dataCollection);
}

var type = arg.type,
    writer = osc.argumentTypes[type].writer;

if (writer) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.isBuffer" id="apidoc.module.osc.isBuffer">module osc.isBuffer</a></h1>


    <h2>
        <a href="#apidoc.element.osc.isBuffer.isBuffer" id="apidoc.element.osc.isBuffer.isBuffer">
        function <span class="apidocSignatureSpan">osc.</span>isBuffer
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBuffer = function (obj) {
    return osc.isBufferEnv &amp;&amp; obj instanceof Buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Array-like or Array-wrapping} obj an array-like or array-wrapping object
 * @returns {Buffer|Uint8Array} a buffer object
 */
// Unsupported, non-API function.
osc.nativeBuffer = function (obj) {
    if (osc.isBufferEnv) {
        return osc.<span class="apidocCodeKeywordSpan">isBuffer</span>(obj) ? obj :
            new Buffer(obj.buffer ? obj : new Uint8Array(obj));
    }

    return osc.isTypedArrayView(obj) ? obj : new Uint8Array(obj);
};

// Unsupported, non-API function
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.isTypedArrayView" id="apidoc.module.osc.isTypedArrayView">module osc.isTypedArrayView</a></h1>


    <h2>
        <a href="#apidoc.element.osc.isTypedArrayView.isTypedArrayView" id="apidoc.element.osc.isTypedArrayView.isTypedArrayView">
        function <span class="apidocSignatureSpan">osc.</span>isTypedArrayView
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isTypedArrayView = function (obj) {
    return obj.buffer &amp;&amp; obj.buffer instanceof ArrayBuffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Unsupported, non-API function.
osc.nativeBuffer = function (obj) {
    if (osc.isBufferEnv) {
        return osc.isBuffer(obj) ? obj :
            new Buffer(obj.buffer ? obj : new Uint8Array(obj));
    }

    return osc.<span class="apidocCodeKeywordSpan">isTypedArrayView</span>(obj) ? obj : new Uint8Array(obj);
};

// Unsupported, non-API function
osc.copyByteArray = function (source, target, offset) {
    if (osc.isTypedArrayView(source) &amp;&amp; osc.isTypedArrayView(target)) {
        target.set(source, offset);
    } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.isValidBundle" id="apidoc.module.osc.isValidBundle">module osc.isValidBundle</a></h1>


    <h2>
        <a href="#apidoc.element.osc.isValidBundle.isValidBundle" id="apidoc.element.osc.isValidBundle.isValidBundle">
        function <span class="apidocSignatureSpan">osc.</span>isValidBundle
        <span class="apidocSignatureSpan">(bundle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidBundle = function (bundle) {
    return bundle.timeTag !== undefined &amp;&amp; bundle.packets !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * Writes an OSC bundle.
     *
     * @param {Object} a bundle object containing "timeTag" and "packets" properties
     * @param {object} [options] write options
     * @return {Uint8Array} an array of bytes containing the message
     */
    osc.writeBundle = function (bundle, options) {
if (!osc.<span class="apidocCodeKeywordSpan">isValidBundle</span>(bundle)) {
    throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. " +
        "Bundle was: " + JSON.stringify(bundle, null, 2));
}

options = options || osc.defaults;
var bundleCollection = osc.collectBundlePackets(bundle, options);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.isValidMessage" id="apidoc.module.osc.isValidMessage">module osc.isValidMessage</a></h1>


    <h2>
        <a href="#apidoc.element.osc.isValidMessage.isValidMessage" id="apidoc.element.osc.isValidMessage.isValidMessage">
        function <span class="apidocSignatureSpan">osc.</span>isValidMessage
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidMessage = function (msg) {
    return msg.address &amp;&amp; msg.address.indexOf("/") === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} msg a message object containing "address" and "args" properties
 * @param {Object} [options] write options
 * @return {Uint8Array} an array of bytes containing the OSC message
 */
osc.writeMessage = function (msg, options) {
    options = options || osc.defaults;

    if (!osc.<span class="apidocCodeKeywordSpan">isValidMessage</span>(msg)) {
        throw new Error("An OSC message must contain a valid address. Message was: " +
            JSON.stringify(msg, null, 2));
    }

    var msgCollection = osc.collectMessageParts(msg, options);
    return osc.joinParts(msgCollection);
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.joinParts" id="apidoc.module.osc.joinParts">module osc.joinParts</a></h1>


    <h2>
        <a href="#apidoc.element.osc.joinParts.joinParts" id="apidoc.element.osc.joinParts.joinParts">
        function <span class="apidocSignatureSpan">osc.</span>joinParts
        <span class="apidocSignatureSpan">(dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
        offset = 0;

    for (var i = 0; i &lt; parts.length; i++) {
        var part = parts[i];
        osc.copyByteArray(part, buf, offset);
        offset += part.length;
    }

    return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Array} args an array of arguments
 * @param {Object} options options for writing
 * @return {Uint8Array} a buffer containing the OSC-formatted argument type tag and values
 */
osc.writeArguments = function (args, options) {
    var argCollection = osc.collectArguments(args, options);
    return osc.<span class="apidocCodeKeywordSpan">joinParts</span>(argCollection);
};

// Unsupported, non-API function.
osc.joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
        offset = 0;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.jsToNTPTime" id="apidoc.module.osc.jsToNTPTime">module osc.jsToNTPTime</a></h1>


    <h2>
        <a href="#apidoc.element.osc.jsToNTPTime.jsToNTPTime" id="apidoc.element.osc.jsToNTPTime.jsToNTPTime">
        function <span class="apidocSignatureSpan">osc.</span>jsToNTPTime
        <span class="apidocSignatureSpan">(jsTime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsToNTPTime = function (jsTime) {
    var secs = jsTime / 1000,
        secsWhole = Math.floor(secs),
        secsFrac = secs - secsWhole,
        ntpSecs = secsWhole + osc.SECS_70YRS,
        ntpFracs = Math.round(osc.TWO_32 * secsFrac);

    return [ntpSecs, ntpFracs];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * values. The first represents the number of seconds since January 1, 1900; the second, fractions of a second.
     * "Native" JavaScript timestamps are specified as a Number representing milliseconds since January 1, 1970.
     *
     * @param {Object} timeTag time tag object containing either a native JS timestamp (in ms) or a NTP timestamp pair
     * @return {Uint8Array} raw bytes for the written time tag
     */
    osc.writeTimeTag = function (timeTag) {
var raw = timeTag.raw ? timeTag.raw : osc.<span class="apidocCodeKeywordSpan">jsToNTPTime</span>(timeTag.native),
    arr = new Uint8Array(8), // Two Unit32s.
    dv = new DataView(arr.buffer);

osc.writeInt32(raw[0], dv, 0);
osc.writeInt32(raw[1], dv, 4);

return arr;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.nativeBuffer" id="apidoc.module.osc.nativeBuffer">module osc.nativeBuffer</a></h1>


    <h2>
        <a href="#apidoc.element.osc.nativeBuffer.nativeBuffer" id="apidoc.element.osc.nativeBuffer.nativeBuffer">
        function <span class="apidocSignatureSpan">osc.</span>nativeBuffer
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nativeBuffer = function (obj) {
    if (osc.isBufferEnv) {
        return osc.isBuffer(obj) ? obj :
            new Buffer(obj.buffer ? obj : new Uint8Array(obj));
    }

    return osc.isTypedArrayView(obj) ? obj : new Uint8Array(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var p = osc.Port.prototype = Object.create(EventEmitter.prototype);
p.constructor = osc.Port;

p.send = function (oscPacket) {
    var args = Array.prototype.slice.call(arguments),
        encoded = this.encodeOSC(oscPacket),
        buf = osc.<span class="apidocCodeKeywordSpan">nativeBuffer</span>(encoded);

    args[0] = buf;
    this.sendRaw.apply(this, args);
};

p.encodeOSC = function (packet) {
    // TODO gh-39: This is unsafe; we should only access the underlying
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.ntpToJSTime" id="apidoc.module.osc.ntpToJSTime">module osc.ntpToJSTime</a></h1>


    <h2>
        <a href="#apidoc.element.osc.ntpToJSTime.ntpToJSTime" id="apidoc.element.osc.ntpToJSTime.ntpToJSTime">
        function <span class="apidocSignatureSpan">osc.</span>ntpToJSTime
        <span class="apidocSignatureSpan">(secs1900, frac)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ntpToJSTime = function (secs1900, frac) {
    var secs1970 = secs1900 - osc.SECS_70YRS,
        decimals = frac / osc.TWO_32,
        msTime = (secs1970 + decimals) * 1000;

    return msTime;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {DataView} dv the DataView instance to read from
 * @param {Object} offsetState an offset state object containing the current index into dv
 * @param {Object} a time tag object containing both the raw NTP as well as the converted native (i.e. JS/UNIX) time
 */
osc.readTimeTag = function (dv, offsetState) {
    var secs1900 = osc.readPrimitive(dv, "getUint32", 4, offsetState),
        frac = osc.readPrimitive(dv, "getUint32", 4, offsetState),
        native = (secs1900 === 0 &amp;&amp; frac === 1) ? Date.now() : osc.<span class="apidocCodeKeywordSpan">ntpToJSTime</span>(secs1900, frac);

    return {
        raw: [secs1900, frac],
        native: native
    };
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.osc_transports" id="apidoc.module.osc.osc_transports">module osc.osc_transports</a></h1>










    <h2>
        <a href="#apidoc.element.osc.osc_transports.Port" id="apidoc.element.osc.osc_transports.Port">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>Port
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Port = function (options) {
    this.options = options || {};
    this.on("data", this.decodeOSC.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.Relay" id="apidoc.element.osc.osc_transports.Relay">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>Relay
        <span class="apidocSignatureSpan">(port1, port2, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Relay = function (port1, port2, options) {
    var o = this.options = options || {};
    o.raw = false;

    this.port1 = port1;
    this.port2 = port2;

    this.listen();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.SLIPPort" id="apidoc.element.osc.osc_transports.SLIPPort">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>SLIPPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SLIPPort = function (options) {
    var that = this;
    var o = this.options = options || {};
    o.useSLIP = o.useSLIP === undefined ? true : o.useSLIP;

    this.decoder = new slip.Decoder({
        onMessage: this.decodeOSC.bind(this),
        onError: function (err) {
            that.emit("error", err);
        }
    });

    var decodeHandler = o.useSLIP ? this.decodeSLIPData : this.decodeOSC;
    this.on("data", decodeHandler.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.WebSocket" id="apidoc.element.osc.osc_transports.WebSocket">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>WebSocket
        <span class="apidocSignatureSpan">(address, protocols, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocket(address, protocols, options) {
  if (this instanceof WebSocket === false) {
    return new WebSocket(address, protocols, options);
  }

  EventEmitter.call(this);

  if (protocols &amp;&amp; !Array.isArray(protocols) &amp;&amp; 'object' === typeof protocols) {
    // accept the "options" Object as the 2nd argument
    options = protocols;
    protocols = null;
  }

  if ('string' === typeof protocols) {
    protocols = [ protocols ];
  }

  if (!Array.isArray(protocols)) {
    protocols = [];
  }

  this._socket = null;
  this._ultron = null;
  this._closeReceived = false;
  this.bytesReceived = 0;
  this.readyState = null;
  this.supports = {};
  this.extensions = {};
  this._binaryType = 'nodebuffer';

  if (Array.isArray(address)) {
    initAsServerClient.apply(this, address.concat(options));
  } else {
    initAsClient.apply(this, [address, protocols, options]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.WebSocketPort" id="apidoc.element.osc.osc_transports.WebSocketPort">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>WebSocketPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocketPort = function (options) {
    osc.Port.call(this, options);
    this.on("open", this.listen.bind(this));

    this.socket = options.socket;
    if (this.socket) {
        if (this.socket.readyState === 1) {
            osc.WebSocketPort.setupSocketForBinary(this.socket);
            this.emit("open", this.socket);
        } else {
            this.open();
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &lt;/head&gt;
    &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
```

##### Creating an OSC Web Socket Port object:
```javascript
var oscPort = new osc.<span class="apidocCodeKeywordSpan">WebSocketPort</span>({
    url: "ws://localhost:8081" // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.open();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.addDataPart" id="apidoc.element.osc.osc_transports.addDataPart">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>addDataPart
        <span class="apidocSignatureSpan">(dataPart, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addDataPart = function (dataPart, dataCollection) {
    dataCollection.parts.push(dataPart);
    dataCollection.byteLength += dataPart.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    var type = arg.type,
        writer = osc.argumentTypes[type].writer;

    if (writer) {
        var data = osc[writer](arg.value);
        osc.<span class="apidocCodeKeywordSpan">addDataPart</span>(data, dataCollection);
    }

    return arg.type;
};

// Unsupported, non-API function.
osc.collectArguments = function (args, options, dataCollection) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.annotateArguments" id="apidoc.element.osc.osc_transports.annotateArguments">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>annotateArguments
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">annotateArguments = function (args) {
    var annotated = [];

    for (var i = 0; i &lt; args.length; i++) {
        var arg = args[i],
            msgArg;

        if (typeof (arg) === "object" &amp;&amp; arg.type &amp;&amp; arg.value !== undefined) {
            // We've got an explicitly typed argument.
            msgArg = arg;
        } else if (osc.isArray(arg)) {
            // We've got an array of arguments,
            // so they each need to be inferred and expanded.
            msgArg = osc.annotateArguments(arg);
        } else {
            var oscType = osc.inferTypeForArgument(arg);
            msgArg = {
                type: oscType,
                value: arg
            };
        }

        annotated.push(msgArg);
    }

    return annotated;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

dataCollection = dataCollection || {
    byteLength: 0,
    parts: []
};

if (!options.metadata) {
    args = osc.<span class="apidocCodeKeywordSpan">annotateArguments</span>(args);
}

var typeTagString = ",",
    currPartIdx = dataCollection.parts.length;

for (var i = 0; i &lt; args.length; i++) {
    var arg = args[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.byteArray" id="apidoc.element.osc.osc_transports.byteArray">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>byteArray
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">byteArray = function (obj) {
    if (obj instanceof Uint8Array) {
        return obj;
    }

    var buf = obj.buffer ? obj.buffer : obj;

    if (!(buf instanceof ArrayBuffer) &amp;&amp; (typeof buf.length === "undefined" || typeof buf === "string")) {
        throw new Error("Can't wrap a non-array-like object as Uint8Array. Object was: " +
            JSON.stringify(obj, null, 2));
    }


    // TODO gh-39: This is a potentially unsafe algorithm;
    // if we're getting anything other than a TypedArrayView (such as a DataView),
    // we really need to determine the range of the view it is viewing.
    return new Uint8Array(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.emit("error", err);
}

return encoded;
    };

    p.decodeOSC = function (data, packetInfo) {
data = osc.<span class="apidocCodeKeywordSpan">byteArray</span>(data);
this.emit("raw", data, packetInfo);

try {
    var packet = osc.readPacket(data, this.options);
    this.emit("osc", packet, packetInfo);
    osc.firePacketEvents(this, packet, undefined, packetInfo);
} catch (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.collectArguments" id="apidoc.element.osc.osc_transports.collectArguments">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>collectArguments
        <span class="apidocSignatureSpan">(args, options, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectArguments = function (args, options, dataCollection) {
    if (!osc.isArray(args)) {
        args = typeof args === "undefined" ? [] : [args];
    }

    dataCollection = dataCollection || {
        byteLength: 0,
        parts: []
    };

    if (!options.metadata) {
        args = osc.annotateArguments(args);
    }

    var typeTagString = ",",
        currPartIdx = dataCollection.parts.length;

    for (var i = 0; i &lt; args.length; i++) {
        var arg = args[i];
        typeTagString += osc.writeArgument(arg, dataCollection);
    }

    var typeData = osc.writeString(typeTagString);
    dataCollection.byteLength += typeData.byteLength;
    dataCollection.parts.splice(currPartIdx, 0, typeData);

    return dataCollection;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Writes the specified arguments.
 *
 * @param {Array} args an array of arguments
 * @param {Object} options options for writing
 * @return {Uint8Array} a buffer containing the OSC-formatted argument type tag and values
 */
osc.writeArguments = function (args, options) {
    var argCollection = osc.<span class="apidocCodeKeywordSpan">collectArguments</span>(args, options);
    return osc.joinParts(argCollection);
};

// Unsupported, non-API function.
osc.joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.collectBundlePackets" id="apidoc.element.osc.osc_transports.collectBundlePackets">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>collectBundlePackets
        <span class="apidocSignatureSpan">(bundle, options, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectBundlePackets = function (bundle, options, dataCollection) {
    dataCollection = dataCollection || {
        byteLength: 0,
        parts: []
    };

    osc.addDataPart(osc.writeString("#bundle"), dataCollection);
    osc.addDataPart(osc.writeTimeTag(bundle.timeTag), dataCollection);

    for (var i = 0; i &lt; bundle.packets.length; i++) {
        var packet = bundle.packets[i],
            collector = packet.address ? osc.collectMessageParts : osc.collectBundlePackets,
            packetCollection = collector(packet, options);

        dataCollection.byteLength += packetCollection.byteLength;
        osc.addDataPart(osc.writeInt32(packetCollection.byteLength), dataCollection);
        dataCollection.parts = dataCollection.parts.concat(packetCollection.parts);
    }

    return dataCollection;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
osc.writeBundle = function (bundle, options) {
    if (!osc.isValidBundle(bundle)) {
        throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. " +
            "Bundle was: " + JSON.stringify(bundle, null, 2));
    }

    options = options || osc.defaults;
    var bundleCollection = osc.<span class="apidocCodeKeywordSpan">collectBundlePackets</span>(bundle, options);

    return osc.joinParts(bundleCollection);
};

osc.isValidBundle = function (bundle) {
    return bundle.timeTag !== undefined &amp;&amp; bundle.packets !== undefined;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.collectMessageParts" id="apidoc.element.osc.osc_transports.collectMessageParts">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>collectMessageParts
        <span class="apidocSignatureSpan">(msg, options, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectMessageParts = function (msg, options, dataCollection) {
    dataCollection = dataCollection || {
        byteLength: 0,
        parts: []
    };

    osc.addDataPart(osc.writeString(msg.address), dataCollection);
    return osc.collectArguments(msg.args, options, dataCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    options = options || osc.defaults;

    if (!osc.isValidMessage(msg)) {
        throw new Error("An OSC message must contain a valid address. Message was: " +
            JSON.stringify(msg, null, 2));
    }

    var msgCollection = osc.<span class="apidocCodeKeywordSpan">collectMessageParts</span>(msg, options);
    return osc.joinParts(msgCollection);
};

osc.isValidMessage = function (msg) {
    return msg.address &amp;&amp; msg.address.indexOf("/") === 0;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.copyByteArray" id="apidoc.element.osc.osc_transports.copyByteArray">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>copyByteArray
        <span class="apidocSignatureSpan">(source, target, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copyByteArray = function (source, target, offset) {
    if (osc.isTypedArrayView(source) &amp;&amp; osc.isTypedArrayView(target)) {
        target.set(source, offset);
    } else {
        var start = offset === undefined ? 0 : offset,
            len = Math.min(target.length - offset, source.length);

        for (var i = 0, j = start; i &lt; len; i++, j++) {
            target[j] = source[i];
        }
    }

    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
osc.joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
        offset = 0;

    for (var i = 0; i &lt; parts.length; i++) {
        var part = parts[i];
        osc.<span class="apidocCodeKeywordSpan">copyByteArray</span>(part, buf, offset);
        offset += part.length;
    }

    return buf;
};

// Unsupported, non-API function.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.dataView" id="apidoc.element.osc.osc_transports.dataView">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>dataView
        <span class="apidocSignatureSpan">(obj, offset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dataView = function (obj, offset, length) {
    if (obj.buffer) {
        return new DataView(obj.buffer, offset, length);
    }

    if (obj instanceof ArrayBuffer) {
        return new DataView(obj, offset, length);
    }

    return new DataView(new Uint8Array(obj), offset, length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} [options] read options
 * @param {Object} [offsetState] an offsetState object that stores the current offset into dv
 * @return {Object} the OSC message, formatted as a JavaScript object containing "address" and "args" properties
 */
osc.readMessage = function (data, options, offsetState) {
    options = options || osc.defaults;

    var dv = osc.<span class="apidocCodeKeywordSpan">dataView</span>(data, data.byteOffset, data.byteLength);
    offsetState = offsetState || {
        idx: 0
    };

    var address = osc.readString(dv, offsetState);
    return osc.readMessageContents(address, dv, options, offsetState);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.fireBundleEvents" id="apidoc.element.osc.osc_transports.fireBundleEvents">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>fireBundleEvents
        <span class="apidocSignatureSpan">(port, bundle, timeTag, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fireBundleEvents = function (port, bundle, timeTag, packetInfo) {
    port.emit("bundle", bundle, timeTag, packetInfo);
    for (var i = 0; i &lt; bundle.packets.length; i++) {
        var packet = bundle.packets[i];
        osc.firePacketEvents(port, packet, bundle.timeTag, packetInfo);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
"use strict";

// Unsupported, non-API function.
osc.firePacketEvents = function (port, packet, timeTag, packetInfo) {
    if (packet.address) {
        port.emit("message", packet, timeTag, packetInfo);
    } else {
        osc.<span class="apidocCodeKeywordSpan">fireBundleEvents</span>(port, packet, timeTag, packetInfo);
    }
};

// Unsupported, non-API function.
osc.fireBundleEvents = function (port, bundle, timeTag, packetInfo) {
    port.emit("bundle", bundle, timeTag, packetInfo);
    for (var i = 0; i &lt; bundle.packets.length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.fireClosedPortSendError" id="apidoc.element.osc.osc_transports.fireClosedPortSendError">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>fireClosedPortSendError
        <span class="apidocSignatureSpan">(port, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fireClosedPortSendError = function (port, msg) {
    msg = msg || "Can't send packets on a closed osc.Port object. Please open (or reopen) this Port by calling open().";

    port.emit("error", msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.firePacketEvents" id="apidoc.element.osc.osc_transports.firePacketEvents">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>firePacketEvents
        <span class="apidocSignatureSpan">(port, packet, timeTag, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">firePacketEvents = function (port, packet, timeTag, packetInfo) {
    if (packet.address) {
        port.emit("message", packet, timeTag, packetInfo);
    } else {
        osc.fireBundleEvents(port, packet, timeTag, packetInfo);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };

    // Unsupported, non-API function.
    osc.fireBundleEvents = function (port, bundle, timeTag, packetInfo) {
port.emit("bundle", bundle, timeTag, packetInfo);
for (var i = 0; i &lt; bundle.packets.length; i++) {
    var packet = bundle.packets[i];
    osc.<span class="apidocCodeKeywordSpan">firePacketEvents</span>(port, packet, bundle.timeTag, packetInfo);
}
    };

    osc.fireClosedPortSendError = function (port, msg) {
msg = msg || "Can't send packets on a closed osc.Port object. Please open (or reopen) this Port by calling open()."
;;

port.emit("error", msg);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.inferTypeForArgument" id="apidoc.element.osc.osc_transports.inferTypeForArgument">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>inferTypeForArgument
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inferTypeForArgument = function (arg) {
    var type = typeof arg;

    // TODO: This is freaking hideous.
    switch (type) {
        case "boolean":
            return arg ? "T" : "F";
        case "string":
            return "s";
        case "number":
            return "f";
        case "undefined":
            return "N";
        case "object":
            if (arg === null) {
                return "N";
            } else if (arg instanceof Uint8Array ||
                arg instanceof ArrayBuffer) {
                return "b";
            } else if (typeof arg.high === "number" &amp;&amp; typeof arg.low === "number") {
                return "h";
            }
            break;
    }

    throw new Error("Can't infer OSC argument type for value: " +
        JSON.stringify(arg, null, 2));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // We've got an explicitly typed argument.
    msgArg = arg;
} else if (osc.isArray(arg)) {
    // We've got an array of arguments,
    // so they each need to be inferred and expanded.
    msgArg = osc.annotateArguments(arg);
} else {
    var oscType = osc.<span class="apidocCodeKeywordSpan">inferTypeForArgument</span>(arg);
    msgArg = {
        type: oscType,
        value: arg
    };
}

annotated.push(msgArg);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.isArray" id="apidoc.element.osc.osc_transports.isArray">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>isArray
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (obj) {
    return obj &amp;&amp; Object.prototype.toString.call(obj) === "[object Array]";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

typeTag += "]";

return typeTag;
    };

    osc.writeArgument = function (arg, dataCollection) {
if (osc.<span class="apidocCodeKeywordSpan">isArray</span>(arg)) {
    return osc.writeArrayArguments(arg, dataCollection);
}

var type = arg.type,
    writer = osc.argumentTypes[type].writer;

if (writer) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.isBuffer" id="apidoc.element.osc.osc_transports.isBuffer">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>isBuffer
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBuffer = function (obj) {
    return osc.isBufferEnv &amp;&amp; obj instanceof Buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Array-like or Array-wrapping} obj an array-like or array-wrapping object
 * @returns {Buffer|Uint8Array} a buffer object
 */
// Unsupported, non-API function.
osc.nativeBuffer = function (obj) {
    if (osc.isBufferEnv) {
        return osc.<span class="apidocCodeKeywordSpan">isBuffer</span>(obj) ? obj :
            new Buffer(obj.buffer ? obj : new Uint8Array(obj));
    }

    return osc.isTypedArrayView(obj) ? obj : new Uint8Array(obj);
};

// Unsupported, non-API function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.isTypedArrayView" id="apidoc.element.osc.osc_transports.isTypedArrayView">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>isTypedArrayView
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isTypedArrayView = function (obj) {
    return obj.buffer &amp;&amp; obj.buffer instanceof ArrayBuffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Unsupported, non-API function.
osc.nativeBuffer = function (obj) {
    if (osc.isBufferEnv) {
        return osc.isBuffer(obj) ? obj :
            new Buffer(obj.buffer ? obj : new Uint8Array(obj));
    }

    return osc.<span class="apidocCodeKeywordSpan">isTypedArrayView</span>(obj) ? obj : new Uint8Array(obj);
};

// Unsupported, non-API function
osc.copyByteArray = function (source, target, offset) {
    if (osc.isTypedArrayView(source) &amp;&amp; osc.isTypedArrayView(target)) {
        target.set(source, offset);
    } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.isValidBundle" id="apidoc.element.osc.osc_transports.isValidBundle">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>isValidBundle
        <span class="apidocSignatureSpan">(bundle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidBundle = function (bundle) {
    return bundle.timeTag !== undefined &amp;&amp; bundle.packets !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * Writes an OSC bundle.
     *
     * @param {Object} a bundle object containing "timeTag" and "packets" properties
     * @param {object} [options] write options
     * @return {Uint8Array} an array of bytes containing the message
     */
    osc.writeBundle = function (bundle, options) {
if (!osc.<span class="apidocCodeKeywordSpan">isValidBundle</span>(bundle)) {
    throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. " +
        "Bundle was: " + JSON.stringify(bundle, null, 2));
}

options = options || osc.defaults;
var bundleCollection = osc.collectBundlePackets(bundle, options);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.isValidMessage" id="apidoc.element.osc.osc_transports.isValidMessage">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>isValidMessage
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidMessage = function (msg) {
    return msg.address &amp;&amp; msg.address.indexOf("/") === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} msg a message object containing "address" and "args" properties
 * @param {Object} [options] write options
 * @return {Uint8Array} an array of bytes containing the OSC message
 */
osc.writeMessage = function (msg, options) {
    options = options || osc.defaults;

    if (!osc.<span class="apidocCodeKeywordSpan">isValidMessage</span>(msg)) {
        throw new Error("An OSC message must contain a valid address. Message was: " +
            JSON.stringify(msg, null, 2));
    }

    var msgCollection = osc.collectMessageParts(msg, options);
    return osc.joinParts(msgCollection);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.joinParts" id="apidoc.element.osc.osc_transports.joinParts">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>joinParts
        <span class="apidocSignatureSpan">(dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
        offset = 0;

    for (var i = 0; i &lt; parts.length; i++) {
        var part = parts[i];
        osc.copyByteArray(part, buf, offset);
        offset += part.length;
    }

    return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Array} args an array of arguments
 * @param {Object} options options for writing
 * @return {Uint8Array} a buffer containing the OSC-formatted argument type tag and values
 */
osc.writeArguments = function (args, options) {
    var argCollection = osc.collectArguments(args, options);
    return osc.<span class="apidocCodeKeywordSpan">joinParts</span>(argCollection);
};

// Unsupported, non-API function.
osc.joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
        offset = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.jsToNTPTime" id="apidoc.element.osc.osc_transports.jsToNTPTime">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>jsToNTPTime
        <span class="apidocSignatureSpan">(jsTime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsToNTPTime = function (jsTime) {
    var secs = jsTime / 1000,
        secsWhole = Math.floor(secs),
        secsFrac = secs - secsWhole,
        ntpSecs = secsWhole + osc.SECS_70YRS,
        ntpFracs = Math.round(osc.TWO_32 * secsFrac);

    return [ntpSecs, ntpFracs];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * values. The first represents the number of seconds since January 1, 1900; the second, fractions of a second.
     * "Native" JavaScript timestamps are specified as a Number representing milliseconds since January 1, 1970.
     *
     * @param {Object} timeTag time tag object containing either a native JS timestamp (in ms) or a NTP timestamp pair
     * @return {Uint8Array} raw bytes for the written time tag
     */
    osc.writeTimeTag = function (timeTag) {
var raw = timeTag.raw ? timeTag.raw : osc.<span class="apidocCodeKeywordSpan">jsToNTPTime</span>(timeTag.native),
    arr = new Uint8Array(8), // Two Unit32s.
    dv = new DataView(arr.buffer);

osc.writeInt32(raw[0], dv, 0);
osc.writeInt32(raw[1], dv, 4);

return arr;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.nativeBuffer" id="apidoc.element.osc.osc_transports.nativeBuffer">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>nativeBuffer
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nativeBuffer = function (obj) {
    if (osc.isBufferEnv) {
        return osc.isBuffer(obj) ? obj :
            new Buffer(obj.buffer ? obj : new Uint8Array(obj));
    }

    return osc.isTypedArrayView(obj) ? obj : new Uint8Array(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var p = osc.Port.prototype = Object.create(EventEmitter.prototype);
p.constructor = osc.Port;

p.send = function (oscPacket) {
    var args = Array.prototype.slice.call(arguments),
        encoded = this.encodeOSC(oscPacket),
        buf = osc.<span class="apidocCodeKeywordSpan">nativeBuffer</span>(encoded);

    args[0] = buf;
    this.sendRaw.apply(this, args);
};

p.encodeOSC = function (packet) {
    // TODO gh-39: This is unsafe; we should only access the underlying
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.ntpToJSTime" id="apidoc.element.osc.osc_transports.ntpToJSTime">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>ntpToJSTime
        <span class="apidocSignatureSpan">(secs1900, frac)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ntpToJSTime = function (secs1900, frac) {
    var secs1970 = secs1900 - osc.SECS_70YRS,
        decimals = frac / osc.TWO_32,
        msTime = (secs1970 + decimals) * 1000;

    return msTime;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {DataView} dv the DataView instance to read from
 * @param {Object} offsetState an offset state object containing the current index into dv
 * @param {Object} a time tag object containing both the raw NTP as well as the converted native (i.e. JS/UNIX) time
 */
osc.readTimeTag = function (dv, offsetState) {
    var secs1900 = osc.readPrimitive(dv, "getUint32", 4, offsetState),
        frac = osc.readPrimitive(dv, "getUint32", 4, offsetState),
        native = (secs1900 === 0 &amp;&amp; frac === 1) ? Date.now() : osc.<span class="apidocCodeKeywordSpan">ntpToJSTime</span>(secs1900, frac);

    return {
        raw: [secs1900, frac],
        native: native
    };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readArgument" id="apidoc.element.osc.osc_transports.readArgument">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readArgument
        <span class="apidocSignatureSpan">(argType, typeTagString, dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArgument = function (argType, typeTagString, dv, options, offsetState) {
    var typeSpec = osc.argumentTypes[argType];
    if (!typeSpec) {
        throw new Error("'" + argType + "' is not a valid OSC type tag. Type tag string was: " + typeTagString);
    }

    var argReader = typeSpec.reader,
        arg = osc[argReader](dv, offsetState);

    if (options.metadata) {
        arg = {
            type: argType,
            value: arg
        };
    }

    return arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                "without a matching close array tag ('[]'). Type tag was: " + typeTagString);
        }

        var typesInArray = fromArrayOpen.slice(0, endArrayIdx);
        arg = osc.readArgumentsIntoArray([], typesInArray, typeTagString, dv, options, offsetState);
        i += endArrayIdx + 2;
    } else {
        arg = osc.<span class="apidocCodeKeywordSpan">readArgument</span>(argType, typeTagString, dv, options, offsetState);
        i++;
    }

    arr.push(arg);
}

return arr;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readArguments" id="apidoc.element.osc.osc_transports.readArguments">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readArguments
        <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArguments = function (dv, options, offsetState) {
    var typeTagString = osc.readString(dv, offsetState);
    if (typeTagString.indexOf(",") !== 0) {
        // Despite what the OSC 1.0 spec says,
        // it just doesn't make sense to handle messages without type tags.
        // scsynth appears to read such messages as if they have a single
        // Uint8 argument. sclang throws an error if the type tag is omitted.
        throw new Error("A malformed type tag string was found while reading " +
            "the arguments of an OSC message. String was: " +
            typeTagString, " at offset: " + offsetState.idx);
    }

    var argTypes = typeTagString.substring(1).split(""),
        args = [];

    osc.readArgumentsIntoArray(args, argTypes, typeTagString, dv, options, offsetState);

    return args;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Unsupported, non-API function.
osc.readMessageContents = function (address, dv, options, offsetState) {
    if (address.indexOf("/") !== 0) {
        throw new Error("A malformed OSC address was found while reading " +
            "an OSC message. String was: " + address);
    }

    var args = osc.<span class="apidocCodeKeywordSpan">readArguments</span>(dv, options, offsetState);

    return {
        address: address,
        args: args.length === 1 &amp;&amp; options.unpackSingleArgs ? args[0] : args
    };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readArgumentsIntoArray" id="apidoc.element.osc.osc_transports.readArgumentsIntoArray">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readArgumentsIntoArray
        <span class="apidocSignatureSpan">(arr, argTypes, typeTagString, dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArgumentsIntoArray = function (arr, argTypes, typeTagString, dv, options, offsetState) {
    var i = 0;

    while (i &lt; argTypes.length) {
        var argType = argTypes[i],
            arg;

        if (argType === "[") {
            var fromArrayOpen = argTypes.slice(i + 1),
                endArrayIdx = fromArrayOpen.indexOf("]");

            if (endArrayIdx &lt; 0) {
                throw new Error("Invalid argument type tag: an open array type tag ('[') was found " +
                    "without a matching close array tag ('[]'). Type tag was: " + typeTagString);
            }

            var typesInArray = fromArrayOpen.slice(0, endArrayIdx);
            arg = osc.readArgumentsIntoArray([], typesInArray, typeTagString, dv, options, offsetState);
            i += endArrayIdx + 2;
        } else {
            arg = osc.readArgument(argType, typeTagString, dv, options, offsetState);
            i++;
        }

        arr.push(arg);
    }

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            "the arguments of an OSC message. String was: " +
            typeTagString, " at offset: " + offsetState.idx);
    }

    var argTypes = typeTagString.substring(1).split(""),
        args = [];

    osc.<span class="apidocCodeKeywordSpan">readArgumentsIntoArray</span>(args, argTypes, typeTagString, dv, options, offsetState
);

    return args;
};

// Unsupported, non-API function.
osc.readArgument = function (argType, typeTagString, dv, options, offsetState) {
    var typeSpec = osc.argumentTypes[argType];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readBlob" id="apidoc.element.osc.osc_transports.readBlob">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readBlob
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBlob = function (dv, offsetState) {
    var len = osc.readInt32(dv, offsetState),
        paddedLen = (len + 3) &amp; ~0x03,
        blob = new Uint8Array(dv.buffer, offsetState.idx, len);

    offsetState.idx += paddedLen;

    return blob;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readBundle" id="apidoc.element.osc.osc_transports.readBundle">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readBundle
        <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBundle = function (dv, options, offsetState) {
    return osc.readPacket(dv, options, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readBundleContents" id="apidoc.element.osc.osc_transports.readBundleContents">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readBundleContents
        <span class="apidocSignatureSpan">(dv, options, offsetState, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBundleContents = function (dv, options, offsetState, len) {
    var timeTag = osc.readTimeTag(dv, offsetState),
        packets = [];

    while (offsetState.idx &lt; len) {
        var packetSize = osc.readInt32(dv, offsetState),
            packetLen = offsetState.idx + packetSize,
            packet = osc.readPacket(dv, options, offsetState, packetLen);

        packets.push(packet);
    }

    return {
        timeTag: timeTag,
        packets: packets
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        idx: 0
    };

    var header = osc.readString(dv, offsetState),
        firstChar = header[0];

    if (firstChar === "#") {
        return osc.<span class="apidocCodeKeywordSpan">readBundleContents</span>(dv, options, offsetState, len);
    } else if (firstChar === "/") {
        return osc.readMessageContents(header, dv, options, offsetState);
    }

    throw new Error("The header of an OSC packet didn't contain an OSC address or a #bundle string." +
        " Header was: " + header);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readChar32" id="apidoc.element.osc.osc_transports.readChar32">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readChar32
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readChar32 = function (dv, offsetState) {
    var charCode = osc.readPrimitive(dv, "getUint32", 4, offsetState);
    return String.fromCharCode(charCode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readColor" id="apidoc.element.osc.osc_transports.readColor">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readColor
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readColor = function (dv, offsetState) {
    var bytes = new Uint8Array(dv.buffer, offsetState.idx, 4),
        alpha = bytes[3] / 255;

    offsetState.idx += 4;

    return {
        r: bytes[0],
        g: bytes[1],
        b: bytes[2],
        a: alpha
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readFalse" id="apidoc.element.osc.osc_transports.readFalse">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readFalse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFalse = function () {
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readFloat32" id="apidoc.element.osc.osc_transports.readFloat32">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readFloat32
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFloat32 = function (dv, offsetState) {
    return osc.readPrimitive(dv, "getFloat32", 4, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readFloat64" id="apidoc.element.osc.osc_transports.readFloat64">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readFloat64
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFloat64 = function (dv, offsetState) {
    return osc.readPrimitive(dv, "getFloat64", 8, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readImpulse" id="apidoc.element.osc.osc_transports.readImpulse">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readImpulse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readImpulse = function () {
    return 1.0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readInt32" id="apidoc.element.osc.osc_transports.readInt32">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readInt32
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt32 = function (dv, offsetState) {
    return osc.readPrimitive(dv, "getInt32", 4, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Reads an OSC blob ("b") (i.e. a Uint8Array).
 *
 * @param {DataView} dv a DataView instance to read from
 * @param {Object} offsetState an offsetState object used to store the current offset index into dv
 * @return {Uint8Array} the data that was read
 */
osc.readBlob = function (dv, offsetState) {
    var len = osc.<span class="apidocCodeKeywordSpan">readInt32</span>(dv, offsetState),
        paddedLen = (len + 3) &amp; ~0x03,
        blob = new Uint8Array(dv.buffer, offsetState.idx, len);

    offsetState.idx += paddedLen;

    return blob;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readInt64" id="apidoc.element.osc.osc_transports.readInt64">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readInt64
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt64 = function (dv, offsetState) {
    var high = osc.readPrimitive(dv, "getInt32", 4, offsetState),
        low = osc.readPrimitive(dv, "getInt32", 4, offsetState);

    if (Long) {
        return new Long(low, high);
    } else {
        return {
            high: high,
            low: low,
            unsigned: false
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readMIDIBytes" id="apidoc.element.osc.osc_transports.readMIDIBytes">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readMIDIBytes
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readMIDIBytes = function (dv, offsetState) {
    var midi = new Uint8Array(dv.buffer, offsetState.idx, 4);
    offsetState.idx += 4;

    return midi;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readMessage" id="apidoc.element.osc.osc_transports.readMessage">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readMessage
        <span class="apidocSignatureSpan">(data, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readMessage = function (data, options, offsetState) {
    options = options || osc.defaults;

    var dv = osc.dataView(data, data.byteOffset, data.byteLength);
    offsetState = offsetState || {
        idx: 0
    };

    var address = osc.readString(dv, offsetState);
    return osc.readMessageContents(address, dv, options, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readMessageContents" id="apidoc.element.osc.osc_transports.readMessageContents">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readMessageContents
        <span class="apidocSignatureSpan">(address, dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readMessageContents = function (address, dv, options, offsetState) {
    if (address.indexOf("/") !== 0) {
        throw new Error("A malformed OSC address was found while reading " +
            "an OSC message. String was: " + address);
    }

    var args = osc.readArguments(dv, options, offsetState);

    return {
        address: address,
        args: args.length === 1 &amp;&amp; options.unpackSingleArgs ? args[0] : args
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    var dv = osc.dataView(data, data.byteOffset, data.byteLength);
    offsetState = offsetState || {
        idx: 0
    };

    var address = osc.readString(dv, offsetState);
    return osc.<span class="apidocCodeKeywordSpan">readMessageContents</span>(address, dv, options, offsetState);
};

// Unsupported, non-API function.
osc.readMessageContents = function (address, dv, options, offsetState) {
    if (address.indexOf("/") !== 0) {
        throw new Error("A malformed OSC address was found while reading " +
            "an OSC message. String was: " + address);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readNull" id="apidoc.element.osc.osc_transports.readNull">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readNull
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readNull = function () {
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readPacket" id="apidoc.element.osc.osc_transports.readPacket">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readPacket
        <span class="apidocSignatureSpan">(data, options, offsetState, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readPacket = function (data, options, offsetState, len) {
    var dv = osc.dataView(data, data.byteOffset, data.byteLength);

    len = len === undefined ? dv.byteLength : len;
    offsetState = offsetState || {
        idx: 0
    };

    var header = osc.readString(dv, offsetState),
        firstChar = header[0];

    if (firstChar === "#") {
        return osc.readBundleContents(dv, options, offsetState, len);
    } else if (firstChar === "/") {
        return osc.readMessageContents(header, dv, options, offsetState);
    }

    throw new Error("The header of an OSC packet didn't contain an OSC address or a #bundle string." +
        " Header was: " + header);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
they should be caught and handled using
&lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;.

```javascript
var msg;

try {
    msg = osc.<span class="apidocCodeKeywordSpan">readPacket</span>(rawPacket);
} catch (error) {
    console.log("An error occurred: ", error.message);
}
```

The osc.js Low-Level API
------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readPrimitive" id="apidoc.element.osc.osc_transports.readPrimitive">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readPrimitive
        <span class="apidocSignatureSpan">(dv, readerName, numBytes, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readPrimitive = function (dv, readerName, numBytes, offsetState) {
    var val = dv[readerName](offsetState.idx, false);
    offsetState.idx += numBytes;

    return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Reads an OSC int32 ("i") value.
 *
 * @param {DataView} dv a DataView containing the raw bytes
 * @param {Object} offsetState an offsetState object used to store the current offset index into dv
 * @return {Number} the number that was read
 */
osc.readInt32 = function (dv, offsetState) {
    return osc.<span class="apidocCodeKeywordSpan">readPrimitive</span>(dv, "getInt32", 4, offsetState);
};

/**
 * Writes an OSC int32 ("i") value.
 *
 * @param {Number} val the number to write
 * @param {DataView} [dv] a DataView instance to write the number into
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readString" id="apidoc.element.osc.osc_transports.readString">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readString
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readString = function (dv, offsetState) {
    var charCodes = [],
        idx = offsetState.idx;

    for (; idx &lt; dv.byteLength; idx++) {
        var charCode = dv.getUint8(idx);
        if (charCode !== 0) {
            charCodes.push(charCode);
        } else {
            idx++;
            break;
        }
    }

    // Round to the nearest 4-byte block.
    idx = (idx + 3) &amp; ~0x03;
    offsetState.idx = idx;

    return String.fromCharCode.apply(null, charCodes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {DataView} dv a DataView instance to read from
 * @param {Object} offsetState the offsetState object that stores the current offset into dv
 * @param {Oobject} [options] read options
 * @return {Array} an array of the OSC arguments that were read
 */
osc.readArguments = function (dv, options, offsetState) {
    var typeTagString = osc.<span class="apidocCodeKeywordSpan">readString</span>(dv, offsetState);
    if (typeTagString.indexOf(",") !== 0) {
        // Despite what the OSC 1.0 spec says,
        // it just doesn't make sense to handle messages without type tags.
        // scsynth appears to read such messages as if they have a single
        // Uint8 argument. sclang throws an error if the type tag is omitted.
        throw new Error("A malformed type tag string was found while reading " +
            "the arguments of an OSC message. String was: " +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readTimeTag" id="apidoc.element.osc.osc_transports.readTimeTag">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readTimeTag
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readTimeTag = function (dv, offsetState) {
    var secs1900 = osc.readPrimitive(dv, "getUint32", 4, offsetState),
        frac = osc.readPrimitive(dv, "getUint32", 4, offsetState),
        native = (secs1900 === 0 &amp;&amp; frac === 1) ? Date.now() : osc.ntpToJSTime(secs1900, frac);

    return {
        raw: [secs1900, frac],
        native: native
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    osc.isValidBundle = function (bundle) {
return bundle.timeTag !== undefined &amp;&amp; bundle.packets !== undefined;
    };

    // Unsupported, non-API function.
    osc.readBundleContents = function (dv, options, offsetState, len) {
var timeTag = osc.<span class="apidocCodeKeywordSpan">readTimeTag</span>(dv, offsetState),
    packets = [];

while (offsetState.idx &lt; len) {
    var packetSize = osc.readInt32(dv, offsetState),
        packetLen = offsetState.idx + packetSize,
        packet = osc.readPacket(dv, options, offsetState, packetLen);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.readTrue" id="apidoc.element.osc.osc_transports.readTrue">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>readTrue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readTrue = function () {
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.relay" id="apidoc.element.osc.osc_transports.relay">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>relay
        <span class="apidocSignatureSpan">(from, to, eventName, sendFnName, transformFn, sendArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">relay = function (from, to, eventName, sendFnName, transformFn, sendArgs) {
    eventName = eventName || "message";
    sendFnName = sendFnName || "send";
    transformFn = transformFn || function () {};
    sendArgs = sendArgs ? [null].concat(sendArgs) : [];

    var listener = function (data) {
        sendArgs[0] = data;
        data = transformFn(data);
        to[sendFnName].apply(to, sendArgs);
    };

    from.on(eventName, listener);

    return {
        eventName: eventName,
        listener: listener
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// Unsupported, non-API function.
osc.relayPorts = function (from, to, o) {
    var eventName = o.raw ? "raw" : "osc",
        sendFnName = o.raw ? "sendRaw" : "send";

    return osc.<span class="apidocCodeKeywordSpan">relay</span>(from, to, eventName, sendFnName, o.transform);
};

// Unsupported, non-API function.
osc.stopRelaying = function (from, relaySpec) {
    from.removeListener(relaySpec.eventName, relaySpec.listener);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.relayPorts" id="apidoc.element.osc.osc_transports.relayPorts">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>relayPorts
        <span class="apidocSignatureSpan">(from, to, o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">relayPorts = function (from, to, o) {
    var eventName = o.raw ? "raw" : "osc",
        sendFnName = o.raw ? "sendRaw" : "send";

    return osc.relay(from, to, eventName, sendFnName, o.transform);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.close();
}

this.port1Spec = osc.<span class="apidocCodeKeywordSpan">relayPorts</span>(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
// Users are still responsible for closing the underlying ports
// if necessary.
var closeListener = this.close.bind(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.stopRelaying" id="apidoc.element.osc.osc_transports.stopRelaying">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>stopRelaying
        <span class="apidocSignatureSpan">(from, relaySpec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopRelaying = function (from, relaySpec) {
    from.removeListener(relaySpec.eventName, relaySpec.listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // if necessary.
    var closeListener = this.close.bind(this);
    this.port1.on("close", closeListener);
    this.port2.on("close", closeListener);
};

p.close = function () {
    osc.<span class="apidocCodeKeywordSpan">stopRelaying</span>(this.port1, this.port1Spec);
    osc.stopRelaying(this.port2, this.port2Spec);
    this.emit("close", this.port1, this.port2);
};


// If we're in a require-compatible environment, export ourselves.
if (typeof module !== "undefined" &amp;&amp; module.exports) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.timeTag" id="apidoc.element.osc.osc_transports.timeTag">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>timeTag
        <span class="apidocSignatureSpan">(secs, now)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeTag = function (secs, now) {
    secs = secs || 0;
    now = now || Date.now();

    var nowSecs = now / 1000,
        nowWhole = Math.floor(nowSecs),
        nowFracs = nowSecs - nowWhole,
        secsWhole = Math.floor(secs),
        secsFracs = secs - secsWhole,
        fracs = nowFracs + secsFracs;

    if (fracs &gt; 1) {
        var fracsWhole = Math.floor(fracs),
            fracsFracs = fracs - fracsWhole;

        secsWhole += fracsWhole;
        fracs = fracsFracs;
    }

    var ntpSecs = nowWhole + secsWhole + osc.SECS_70YRS,
        ntpFracs = Math.round(osc.TWO_32 * fracs);

    return {
        raw: [ntpSecs, ntpFracs]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

##### Sending OSC bundles:
```javascript
oscPort.on("ready", function () {
oscPort.send({
    timeTag: osc.<span class="apidocCodeKeywordSpan">timeTag</span>(60), // Schedules this bundle 60 seconds from now.
    packets: [
        {
            address: "/carrier/frequency",
            args: 440
        },
        {
            address: "/carrier/amplitude"
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writeArgument" id="apidoc.element.osc.osc_transports.writeArgument">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeArgument
        <span class="apidocSignatureSpan">(arg, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArgument = function (arg, dataCollection) {
    if (osc.isArray(arg)) {
        return osc.writeArrayArguments(arg, dataCollection);
    }

    var type = arg.type,
        writer = osc.argumentTypes[type].writer;

    if (writer) {
        var data = osc[writer](arg.value);
        osc.addDataPart(data, dataCollection);
    }

    return arg.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

osc.writeArrayArguments = function (args, dataCollection) {
    var typeTag = "[";

    for (var i = 0; i &lt; args.length; i++) {
        var arg = args[i];
        typeTag += osc.<span class="apidocCodeKeywordSpan">writeArgument</span>(arg, dataCollection);
    }

    typeTag += "]";

    return typeTag;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writeArguments" id="apidoc.element.osc.osc_transports.writeArguments">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeArguments
        <span class="apidocSignatureSpan">(args, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArguments = function (args, options) {
    var argCollection = osc.collectArguments(args, options);
    return osc.joinParts(argCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writeArrayArguments" id="apidoc.element.osc.osc_transports.writeArrayArguments">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeArrayArguments
        <span class="apidocSignatureSpan">(args, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArrayArguments = function (args, dataCollection) {
    var typeTag = "[";

    for (var i = 0; i &lt; args.length; i++) {
        var arg = args[i];
        typeTag += osc.writeArgument(arg, dataCollection);
    }

    typeTag += "]";

    return typeTag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
typeTag += "]";

return typeTag;
    };

    osc.writeArgument = function (arg, dataCollection) {
if (osc.isArray(arg)) {
    return osc.<span class="apidocCodeKeywordSpan">writeArrayArguments</span>(arg, dataCollection);
}

var type = arg.type,
    writer = osc.argumentTypes[type].writer;

if (writer) {
    var data = osc[writer](arg.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writeBlob" id="apidoc.element.osc.osc_transports.writeBlob">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeBlob
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeBlob = function (data) {
    data = osc.byteArray(data);

    var len = data.byteLength,
        paddedLen = (len + 3) &amp; ~0x03,
        offset = 4, // Extra 4 bytes is for the size.
        blobLen = paddedLen + offset,
        arr = new Uint8Array(blobLen),
        dv = new DataView(arr.buffer);

    // Write the size.
    osc.writeInt32(len, dv);

    // Since we're writing to a real ArrayBuffer,
    // we don't need to pad the remaining bytes.
    arr.set(data, offset);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writeBundle" id="apidoc.element.osc.osc_transports.writeBundle">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeBundle
        <span class="apidocSignatureSpan">(bundle, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeBundle = function (bundle, options) {
    if (!osc.isValidBundle(bundle)) {
        throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. " +
            "Bundle was: " + JSON.stringify(bundle, null, 2));
    }

    options = options || osc.defaults;
    var bundleCollection = osc.collectBundlePackets(bundle, options);

    return osc.joinParts(bundleCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} [options] write options
 * @return {Uint8Array} an array of bytes containing the message
 */
osc.writePacket = function (packet, options) {
    if (osc.isValidMessage(packet)) {
        return osc.writeMessage(packet, options);
    } else if (osc.isValidBundle(packet)) {
        return osc.<span class="apidocCodeKeywordSpan">writeBundle</span>(packet, options);
    } else {
        throw new Error("The specified packet was not recognized as a valid OSC message or bundle." +
            " Packet was: " + JSON.stringify(packet, null, 2));
    }
};

// Unsupported, non-API.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writeChar32" id="apidoc.element.osc.osc_transports.writeChar32">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeChar32
        <span class="apidocSignatureSpan">(str, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeChar32 = function (str, dv, offset) {
    var charCode = str.charCodeAt(0);
    if (charCode === undefined || charCode &lt; -1) {
        return undefined;
    }

    return osc.writePrimitive(charCode, dv, "setUint32", 4, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writeColor" id="apidoc.element.osc.osc_transports.writeColor">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeColor
        <span class="apidocSignatureSpan">(color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeColor = function (color) {
    var alpha = Math.round(color.a * 255),
        arr = new Uint8Array([color.r, color.g, color.b, alpha]);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writeFloat32" id="apidoc.element.osc.osc_transports.writeFloat32">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeFloat32
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFloat32 = function (val, dv, offset) {
    return osc.writePrimitive(val, dv, "setFloat32", 4, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writeFloat64" id="apidoc.element.osc.osc_transports.writeFloat64">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeFloat64
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFloat64 = function (val, dv, offset) {
    return osc.writePrimitive(val, dv, "setFloat64", 8, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writeInt32" id="apidoc.element.osc.osc_transports.writeInt32">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeInt32
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt32 = function (val, dv, offset) {
    return osc.writePrimitive(val, dv, "setInt32", 4, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        paddedLen = (len + 3) &amp; ~0x03,
        offset = 4, // Extra 4 bytes is for the size.
        blobLen = paddedLen + offset,
        arr = new Uint8Array(blobLen),
        dv = new DataView(arr.buffer);

    // Write the size.
    osc.<span class="apidocCodeKeywordSpan">writeInt32</span>(len, dv);

    // Since we're writing to a real ArrayBuffer,
    // we don't need to pad the remaining bytes.
    arr.set(data, offset);

    return arr;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writeInt64" id="apidoc.element.osc.osc_transports.writeInt64">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeInt64
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt64 = function (val, dv, offset) {
    var arr = new Uint8Array(8);
    arr.set(osc.writePrimitive(val.high, dv, "setInt32", 4, offset), 0);
    arr.set(osc.writePrimitive(val.low,  dv, "setInt32", 4, offset + 4), 4);
    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writeMIDIBytes" id="apidoc.element.osc.osc_transports.writeMIDIBytes">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeMIDIBytes
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeMIDIBytes = function (bytes) {
    bytes = osc.byteArray(bytes);

    var arr = new Uint8Array(4);
    arr.set(bytes);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writeMessage" id="apidoc.element.osc.osc_transports.writeMessage">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeMessage
        <span class="apidocSignatureSpan">(msg, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeMessage = function (msg, options) {
    options = options || osc.defaults;

    if (!osc.isValidMessage(msg)) {
        throw new Error("An OSC message must contain a valid address. Message was: " +
            JSON.stringify(msg, null, 2));
    }

    var msgCollection = osc.collectMessageParts(msg, options);
    return osc.joinParts(msgCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Object} a bundle or message object
 * @param {Object} [options] write options
 * @return {Uint8Array} an array of bytes containing the message
 */
osc.writePacket = function (packet, options) {
    if (osc.isValidMessage(packet)) {
        return osc.<span class="apidocCodeKeywordSpan">writeMessage</span>(packet, options);
    } else if (osc.isValidBundle(packet)) {
        return osc.writeBundle(packet, options);
    } else {
        throw new Error("The specified packet was not recognized as a valid OSC message or bundle." +
            " Packet was: " + JSON.stringify(packet, null, 2));
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writePacket" id="apidoc.element.osc.osc_transports.writePacket">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writePacket
        <span class="apidocSignatureSpan">(packet, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writePacket = function (packet, options) {
    if (osc.isValidMessage(packet)) {
        return osc.writeMessage(packet, options);
    } else if (osc.isValidBundle(packet)) {
        return osc.writeBundle(packet, options);
    } else {
        throw new Error("The specified packet was not recognized as a valid OSC message or bundle." +
            " Packet was: " + JSON.stringify(packet, null, 2));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &lt;code&gt;options&lt;/code&gt;: (optional) An options object, described below; &lt;br /&gt;
        &lt;code&gt;offsetState&lt;/code&gt;: (optional) an offset state object containing an &lt;code&gt;idx&lt;/
code&gt; property that specifies the offset index into &lt;code&gt;data&lt;/code&gt;; &lt;br /&gt;
        &lt;code&gt;length&lt;/code&gt; the length (in bytes) to read from &lt;code&gt;data&lt;/code&gt;
    &lt;/td&gt;
    &lt;td&gt;An osc.js message or bundle object&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;code&gt;osc.<span class="apidocCodeKeywordSpan">writePacket</span>()&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;Writes an OSC message or bundle object to a binary array.&lt;/td&gt;
    &lt;td&gt;
        &lt;code&gt;packate&lt;/code&gt;: An osc.js message or bundle object;&lt;br /&gt;
        &lt;code&gt;options&lt;/code&gt;: (optional) An options object, described below&lt;br /&gt;
    &lt;/td&gt;
    &lt;td&gt;A &lt;code&gt;Uint8Array&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writePrimitive" id="apidoc.element.osc.osc_transports.writePrimitive">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writePrimitive
        <span class="apidocSignatureSpan">(val, dv, writerName, numBytes, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writePrimitive = function (val, dv, writerName, numBytes, offset) {
    offset = offset === undefined ? 0 : offset;

    var arr;
    if (!dv) {
        arr = new Uint8Array(numBytes);
        dv = new DataView(arr.buffer);
    } else {
        arr = new Uint8Array(dv.buffer);
    }

    dv[writerName](offset, val, false);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Writes an OSC int32 ("i") value.
 *
 * @param {Number} val the number to write
 * @param {DataView} [dv] a DataView instance to write the number into
 * @param {Number} [offset] an offset into dv
 */
osc.writeInt32 = function (val, dv, offset) {
    return osc.<span class="apidocCodeKeywordSpan">writePrimitive</span>(val, dv, "setInt32", 4, offset);
};

/**
 * Reads an OSC int64 ("h") value.
 *
 * @param {DataView} dv a DataView containing the raw bytes
 * @param {Object} offsetState an offsetState object used to store the current offset index into dv
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writeString" id="apidoc.element.osc.osc_transports.writeString">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeString
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeString = function (str) {
    var terminated = str + "\u0000",
        len = terminated.length,
        paddedLen = (len + 3) &amp; ~0x03,
        arr = new Uint8Array(paddedLen);

    for (var i = 0; i &lt; terminated.length; i++) {
        var charCode = terminated.charCodeAt(i);
        arr[i] = charCode;
    }

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        currPartIdx = dataCollection.parts.length;

    for (var i = 0; i &lt; args.length; i++) {
        var arg = args[i];
        typeTagString += osc.writeArgument(arg, dataCollection);
    }

    var typeData = osc.<span class="apidocCodeKeywordSpan">writeString</span>(typeTagString);
    dataCollection.byteLength += typeData.byteLength;
    dataCollection.parts.splice(currPartIdx, 0, typeData);

    return dataCollection;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc_transports.writeTimeTag" id="apidoc.element.osc.osc_transports.writeTimeTag">
        function <span class="apidocSignatureSpan">osc.osc_transports.</span>writeTimeTag
        <span class="apidocSignatureSpan">(timeTag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeTimeTag = function (timeTag) {
    var raw = timeTag.raw ? timeTag.raw : osc.jsToNTPTime(timeTag.native),
        arr = new Uint8Array(8), // Two Unit32s.
        dv = new DataView(arr.buffer);

    osc.writeInt32(raw[0], dv, 0);
    osc.writeInt32(raw[1], dv, 4);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    osc.collectBundlePackets = function (bundle, options, dataCollection) {
        dataCollection = dataCollection || {
byteLength: 0,
parts: []
        };

        osc.addDataPart(osc.writeString("#bundle"), dataCollection);
        osc.addDataPart(osc.<span class="apidocCodeKeywordSpan">writeTimeTag</span>(bundle.timeTag), dataCollection);

        for (var i = 0; i &lt; bundle.packets.length; i++) {
var packet = bundle.packets[i],
    collector = packet.address ? osc.collectMessageParts : osc.collectBundlePackets,
    packetCollection = collector(packet, options);

dataCollection.byteLength += packetCollection.byteLength;
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readArgument" id="apidoc.module.osc.readArgument">module osc.readArgument</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readArgument.readArgument" id="apidoc.element.osc.readArgument.readArgument">
        function <span class="apidocSignatureSpan">osc.</span>readArgument
        <span class="apidocSignatureSpan">(argType, typeTagString, dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArgument = function (argType, typeTagString, dv, options, offsetState) {
    var typeSpec = osc.argumentTypes[argType];
    if (!typeSpec) {
        throw new Error("'" + argType + "' is not a valid OSC type tag. Type tag string was: " + typeTagString);
    }

    var argReader = typeSpec.reader,
        arg = osc[argReader](dv, offsetState);

    if (options.metadata) {
        arg = {
            type: argType,
            value: arg
        };
    }

    return arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                "without a matching close array tag ('[]'). Type tag was: " + typeTagString);
        }

        var typesInArray = fromArrayOpen.slice(0, endArrayIdx);
        arg = osc.readArgumentsIntoArray([], typesInArray, typeTagString, dv, options, offsetState);
        i += endArrayIdx + 2;
    } else {
        arg = osc.<span class="apidocCodeKeywordSpan">readArgument</span>(argType, typeTagString, dv, options, offsetState);
        i++;
    }

    arr.push(arg);
}

return arr;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readArguments" id="apidoc.module.osc.readArguments">module osc.readArguments</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readArguments.readArguments" id="apidoc.element.osc.readArguments.readArguments">
        function <span class="apidocSignatureSpan">osc.</span>readArguments
        <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArguments = function (dv, options, offsetState) {
    var typeTagString = osc.readString(dv, offsetState);
    if (typeTagString.indexOf(",") !== 0) {
        // Despite what the OSC 1.0 spec says,
        // it just doesn't make sense to handle messages without type tags.
        // scsynth appears to read such messages as if they have a single
        // Uint8 argument. sclang throws an error if the type tag is omitted.
        throw new Error("A malformed type tag string was found while reading " +
            "the arguments of an OSC message. String was: " +
            typeTagString, " at offset: " + offsetState.idx);
    }

    var argTypes = typeTagString.substring(1).split(""),
        args = [];

    osc.readArgumentsIntoArray(args, argTypes, typeTagString, dv, options, offsetState);

    return args;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Unsupported, non-API function.
osc.readMessageContents = function (address, dv, options, offsetState) {
    if (address.indexOf("/") !== 0) {
        throw new Error("A malformed OSC address was found while reading " +
            "an OSC message. String was: " + address);
    }

    var args = osc.<span class="apidocCodeKeywordSpan">readArguments</span>(dv, options, offsetState);

    return {
        address: address,
        args: args.length === 1 &amp;&amp; options.unpackSingleArgs ? args[0] : args
    };
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readArgumentsIntoArray" id="apidoc.module.osc.readArgumentsIntoArray">module osc.readArgumentsIntoArray</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readArgumentsIntoArray.readArgumentsIntoArray" id="apidoc.element.osc.readArgumentsIntoArray.readArgumentsIntoArray">
        function <span class="apidocSignatureSpan">osc.</span>readArgumentsIntoArray
        <span class="apidocSignatureSpan">(arr, argTypes, typeTagString, dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArgumentsIntoArray = function (arr, argTypes, typeTagString, dv, options, offsetState) {
    var i = 0;

    while (i &lt; argTypes.length) {
        var argType = argTypes[i],
            arg;

        if (argType === "[") {
            var fromArrayOpen = argTypes.slice(i + 1),
                endArrayIdx = fromArrayOpen.indexOf("]");

            if (endArrayIdx &lt; 0) {
                throw new Error("Invalid argument type tag: an open array type tag ('[') was found " +
                    "without a matching close array tag ('[]'). Type tag was: " + typeTagString);
            }

            var typesInArray = fromArrayOpen.slice(0, endArrayIdx);
            arg = osc.readArgumentsIntoArray([], typesInArray, typeTagString, dv, options, offsetState);
            i += endArrayIdx + 2;
        } else {
            arg = osc.readArgument(argType, typeTagString, dv, options, offsetState);
            i++;
        }

        arr.push(arg);
    }

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            "the arguments of an OSC message. String was: " +
            typeTagString, " at offset: " + offsetState.idx);
    }

    var argTypes = typeTagString.substring(1).split(""),
        args = [];

    osc.<span class="apidocCodeKeywordSpan">readArgumentsIntoArray</span>(args, argTypes, typeTagString, dv, options, offsetState
);

    return args;
};

// Unsupported, non-API function.
osc.readArgument = function (argType, typeTagString, dv, options, offsetState) {
    var typeSpec = osc.argumentTypes[argType];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readBlob" id="apidoc.module.osc.readBlob">module osc.readBlob</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readBlob.readBlob" id="apidoc.element.osc.readBlob.readBlob">
        function <span class="apidocSignatureSpan">osc.</span>readBlob
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBlob = function (dv, offsetState) {
    var len = osc.readInt32(dv, offsetState),
        paddedLen = (len + 3) &amp; ~0x03,
        blob = new Uint8Array(dv.buffer, offsetState.idx, len);

    offsetState.idx += paddedLen;

    return blob;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readBundle" id="apidoc.module.osc.readBundle">module osc.readBundle</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readBundle.readBundle" id="apidoc.element.osc.readBundle.readBundle">
        function <span class="apidocSignatureSpan">osc.</span>readBundle
        <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBundle = function (dv, options, offsetState) {
    return osc.readPacket(dv, options, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readBundleContents" id="apidoc.module.osc.readBundleContents">module osc.readBundleContents</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readBundleContents.readBundleContents" id="apidoc.element.osc.readBundleContents.readBundleContents">
        function <span class="apidocSignatureSpan">osc.</span>readBundleContents
        <span class="apidocSignatureSpan">(dv, options, offsetState, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBundleContents = function (dv, options, offsetState, len) {
    var timeTag = osc.readTimeTag(dv, offsetState),
        packets = [];

    while (offsetState.idx &lt; len) {
        var packetSize = osc.readInt32(dv, offsetState),
            packetLen = offsetState.idx + packetSize,
            packet = osc.readPacket(dv, options, offsetState, packetLen);

        packets.push(packet);
    }

    return {
        timeTag: timeTag,
        packets: packets
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        idx: 0
    };

    var header = osc.readString(dv, offsetState),
        firstChar = header[0];

    if (firstChar === "#") {
        return osc.<span class="apidocCodeKeywordSpan">readBundleContents</span>(dv, options, offsetState, len);
    } else if (firstChar === "/") {
        return osc.readMessageContents(header, dv, options, offsetState);
    }

    throw new Error("The header of an OSC packet didn't contain an OSC address or a #bundle string." +
        " Header was: " + header);
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readChar32" id="apidoc.module.osc.readChar32">module osc.readChar32</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readChar32.readChar32" id="apidoc.element.osc.readChar32.readChar32">
        function <span class="apidocSignatureSpan">osc.</span>readChar32
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readChar32 = function (dv, offsetState) {
    var charCode = osc.readPrimitive(dv, "getUint32", 4, offsetState);
    return String.fromCharCode(charCode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readColor" id="apidoc.module.osc.readColor">module osc.readColor</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readColor.readColor" id="apidoc.element.osc.readColor.readColor">
        function <span class="apidocSignatureSpan">osc.</span>readColor
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readColor = function (dv, offsetState) {
    var bytes = new Uint8Array(dv.buffer, offsetState.idx, 4),
        alpha = bytes[3] / 255;

    offsetState.idx += 4;

    return {
        r: bytes[0],
        g: bytes[1],
        b: bytes[2],
        a: alpha
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readFalse" id="apidoc.module.osc.readFalse">module osc.readFalse</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readFalse.readFalse" id="apidoc.element.osc.readFalse.readFalse">
        function <span class="apidocSignatureSpan">osc.</span>readFalse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFalse = function () {
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readFloat32" id="apidoc.module.osc.readFloat32">module osc.readFloat32</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readFloat32.readFloat32" id="apidoc.element.osc.readFloat32.readFloat32">
        function <span class="apidocSignatureSpan">osc.</span>readFloat32
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFloat32 = function (dv, offsetState) {
    return osc.readPrimitive(dv, "getFloat32", 4, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readFloat64" id="apidoc.module.osc.readFloat64">module osc.readFloat64</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readFloat64.readFloat64" id="apidoc.element.osc.readFloat64.readFloat64">
        function <span class="apidocSignatureSpan">osc.</span>readFloat64
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFloat64 = function (dv, offsetState) {
    return osc.readPrimitive(dv, "getFloat64", 8, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readImpulse" id="apidoc.module.osc.readImpulse">module osc.readImpulse</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readImpulse.readImpulse" id="apidoc.element.osc.readImpulse.readImpulse">
        function <span class="apidocSignatureSpan">osc.</span>readImpulse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readImpulse = function () {
    return 1.0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readInt32" id="apidoc.module.osc.readInt32">module osc.readInt32</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readInt32.readInt32" id="apidoc.element.osc.readInt32.readInt32">
        function <span class="apidocSignatureSpan">osc.</span>readInt32
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt32 = function (dv, offsetState) {
    return osc.readPrimitive(dv, "getInt32", 4, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Reads an OSC blob ("b") (i.e. a Uint8Array).
 *
 * @param {DataView} dv a DataView instance to read from
 * @param {Object} offsetState an offsetState object used to store the current offset index into dv
 * @return {Uint8Array} the data that was read
 */
osc.readBlob = function (dv, offsetState) {
    var len = osc.<span class="apidocCodeKeywordSpan">readInt32</span>(dv, offsetState),
        paddedLen = (len + 3) &amp; ~0x03,
        blob = new Uint8Array(dv.buffer, offsetState.idx, len);

    offsetState.idx += paddedLen;

    return blob;
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readInt64" id="apidoc.module.osc.readInt64">module osc.readInt64</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readInt64.readInt64" id="apidoc.element.osc.readInt64.readInt64">
        function <span class="apidocSignatureSpan">osc.</span>readInt64
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt64 = function (dv, offsetState) {
    var high = osc.readPrimitive(dv, "getInt32", 4, offsetState),
        low = osc.readPrimitive(dv, "getInt32", 4, offsetState);

    if (Long) {
        return new Long(low, high);
    } else {
        return {
            high: high,
            low: low,
            unsigned: false
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readMIDIBytes" id="apidoc.module.osc.readMIDIBytes">module osc.readMIDIBytes</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readMIDIBytes.readMIDIBytes" id="apidoc.element.osc.readMIDIBytes.readMIDIBytes">
        function <span class="apidocSignatureSpan">osc.</span>readMIDIBytes
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readMIDIBytes = function (dv, offsetState) {
    var midi = new Uint8Array(dv.buffer, offsetState.idx, 4);
    offsetState.idx += 4;

    return midi;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readMessage" id="apidoc.module.osc.readMessage">module osc.readMessage</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readMessage.readMessage" id="apidoc.element.osc.readMessage.readMessage">
        function <span class="apidocSignatureSpan">osc.</span>readMessage
        <span class="apidocSignatureSpan">(data, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readMessage = function (data, options, offsetState) {
    options = options || osc.defaults;

    var dv = osc.dataView(data, data.byteOffset, data.byteLength);
    offsetState = offsetState || {
        idx: 0
    };

    var address = osc.readString(dv, offsetState);
    return osc.readMessageContents(address, dv, options, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readMessageContents" id="apidoc.module.osc.readMessageContents">module osc.readMessageContents</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readMessageContents.readMessageContents" id="apidoc.element.osc.readMessageContents.readMessageContents">
        function <span class="apidocSignatureSpan">osc.</span>readMessageContents
        <span class="apidocSignatureSpan">(address, dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readMessageContents = function (address, dv, options, offsetState) {
    if (address.indexOf("/") !== 0) {
        throw new Error("A malformed OSC address was found while reading " +
            "an OSC message. String was: " + address);
    }

    var args = osc.readArguments(dv, options, offsetState);

    return {
        address: address,
        args: args.length === 1 &amp;&amp; options.unpackSingleArgs ? args[0] : args
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    var dv = osc.dataView(data, data.byteOffset, data.byteLength);
    offsetState = offsetState || {
        idx: 0
    };

    var address = osc.readString(dv, offsetState);
    return osc.<span class="apidocCodeKeywordSpan">readMessageContents</span>(address, dv, options, offsetState);
};

// Unsupported, non-API function.
osc.readMessageContents = function (address, dv, options, offsetState) {
    if (address.indexOf("/") !== 0) {
        throw new Error("A malformed OSC address was found while reading " +
            "an OSC message. String was: " + address);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readNull" id="apidoc.module.osc.readNull">module osc.readNull</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readNull.readNull" id="apidoc.element.osc.readNull.readNull">
        function <span class="apidocSignatureSpan">osc.</span>readNull
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readNull = function () {
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readPacket" id="apidoc.module.osc.readPacket">module osc.readPacket</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readPacket.readPacket" id="apidoc.element.osc.readPacket.readPacket">
        function <span class="apidocSignatureSpan">osc.</span>readPacket
        <span class="apidocSignatureSpan">(data, options, offsetState, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readPacket = function (data, options, offsetState, len) {
    var dv = osc.dataView(data, data.byteOffset, data.byteLength);

    len = len === undefined ? dv.byteLength : len;
    offsetState = offsetState || {
        idx: 0
    };

    var header = osc.readString(dv, offsetState),
        firstChar = header[0];

    if (firstChar === "#") {
        return osc.readBundleContents(dv, options, offsetState, len);
    } else if (firstChar === "/") {
        return osc.readMessageContents(header, dv, options, offsetState);
    }

    throw new Error("The header of an OSC packet didn't contain an OSC address or a #bundle string." +
        " Header was: " + header);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
they should be caught and handled using
&lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;.

```javascript
var msg;

try {
    msg = osc.<span class="apidocCodeKeywordSpan">readPacket</span>(rawPacket);
} catch (error) {
    console.log("An error occurred: ", error.message);
}
```

The osc.js Low-Level API
------------------------
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readPrimitive" id="apidoc.module.osc.readPrimitive">module osc.readPrimitive</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readPrimitive.readPrimitive" id="apidoc.element.osc.readPrimitive.readPrimitive">
        function <span class="apidocSignatureSpan">osc.</span>readPrimitive
        <span class="apidocSignatureSpan">(dv, readerName, numBytes, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readPrimitive = function (dv, readerName, numBytes, offsetState) {
    var val = dv[readerName](offsetState.idx, false);
    offsetState.idx += numBytes;

    return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Reads an OSC int32 ("i") value.
 *
 * @param {DataView} dv a DataView containing the raw bytes
 * @param {Object} offsetState an offsetState object used to store the current offset index into dv
 * @return {Number} the number that was read
 */
osc.readInt32 = function (dv, offsetState) {
    return osc.<span class="apidocCodeKeywordSpan">readPrimitive</span>(dv, "getInt32", 4, offsetState);
};

/**
 * Writes an OSC int32 ("i") value.
 *
 * @param {Number} val the number to write
 * @param {DataView} [dv] a DataView instance to write the number into
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readString" id="apidoc.module.osc.readString">module osc.readString</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readString.readString" id="apidoc.element.osc.readString.readString">
        function <span class="apidocSignatureSpan">osc.</span>readString
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readString = function (dv, offsetState) {
    var charCodes = [],
        idx = offsetState.idx;

    for (; idx &lt; dv.byteLength; idx++) {
        var charCode = dv.getUint8(idx);
        if (charCode !== 0) {
            charCodes.push(charCode);
        } else {
            idx++;
            break;
        }
    }

    // Round to the nearest 4-byte block.
    idx = (idx + 3) &amp; ~0x03;
    offsetState.idx = idx;

    return String.fromCharCode.apply(null, charCodes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {DataView} dv a DataView instance to read from
 * @param {Object} offsetState the offsetState object that stores the current offset into dv
 * @param {Oobject} [options] read options
 * @return {Array} an array of the OSC arguments that were read
 */
osc.readArguments = function (dv, options, offsetState) {
    var typeTagString = osc.<span class="apidocCodeKeywordSpan">readString</span>(dv, offsetState);
    if (typeTagString.indexOf(",") !== 0) {
        // Despite what the OSC 1.0 spec says,
        // it just doesn't make sense to handle messages without type tags.
        // scsynth appears to read such messages as if they have a single
        // Uint8 argument. sclang throws an error if the type tag is omitted.
        throw new Error("A malformed type tag string was found while reading " +
            "the arguments of an OSC message. String was: " +
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readTimeTag" id="apidoc.module.osc.readTimeTag">module osc.readTimeTag</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readTimeTag.readTimeTag" id="apidoc.element.osc.readTimeTag.readTimeTag">
        function <span class="apidocSignatureSpan">osc.</span>readTimeTag
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readTimeTag = function (dv, offsetState) {
    var secs1900 = osc.readPrimitive(dv, "getUint32", 4, offsetState),
        frac = osc.readPrimitive(dv, "getUint32", 4, offsetState),
        native = (secs1900 === 0 &amp;&amp; frac === 1) ? Date.now() : osc.ntpToJSTime(secs1900, frac);

    return {
        raw: [secs1900, frac],
        native: native
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    osc.isValidBundle = function (bundle) {
return bundle.timeTag !== undefined &amp;&amp; bundle.packets !== undefined;
    };

    // Unsupported, non-API function.
    osc.readBundleContents = function (dv, options, offsetState, len) {
var timeTag = osc.<span class="apidocCodeKeywordSpan">readTimeTag</span>(dv, offsetState),
    packets = [];

while (offsetState.idx &lt; len) {
    var packetSize = osc.readInt32(dv, offsetState),
        packetLen = offsetState.idx + packetSize,
        packet = osc.readPacket(dv, options, offsetState, packetLen);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.readTrue" id="apidoc.module.osc.readTrue">module osc.readTrue</a></h1>


    <h2>
        <a href="#apidoc.element.osc.readTrue.readTrue" id="apidoc.element.osc.readTrue.readTrue">
        function <span class="apidocSignatureSpan">osc.</span>readTrue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readTrue = function () {
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.relay" id="apidoc.module.osc.relay">module osc.relay</a></h1>


    <h2>
        <a href="#apidoc.element.osc.relay.relay" id="apidoc.element.osc.relay.relay">
        function <span class="apidocSignatureSpan">osc.</span>relay
        <span class="apidocSignatureSpan">(from, to, eventName, sendFnName, transformFn, sendArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">relay = function (from, to, eventName, sendFnName, transformFn, sendArgs) {
    eventName = eventName || "message";
    sendFnName = sendFnName || "send";
    transformFn = transformFn || function () {};
    sendArgs = sendArgs ? [null].concat(sendArgs) : [];

    var listener = function (data) {
        sendArgs[0] = data;
        data = transformFn(data);
        to[sendFnName].apply(to, sendArgs);
    };

    from.on(eventName, listener);

    return {
        eventName: eventName,
        listener: listener
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// Unsupported, non-API function.
osc.relayPorts = function (from, to, o) {
    var eventName = o.raw ? "raw" : "osc",
        sendFnName = o.raw ? "sendRaw" : "send";

    return osc.<span class="apidocCodeKeywordSpan">relay</span>(from, to, eventName, sendFnName, o.transform);
};

// Unsupported, non-API function.
osc.stopRelaying = function (from, relaySpec) {
    from.removeListener(relaySpec.eventName, relaySpec.listener);
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.relayPorts" id="apidoc.module.osc.relayPorts">module osc.relayPorts</a></h1>


    <h2>
        <a href="#apidoc.element.osc.relayPorts.relayPorts" id="apidoc.element.osc.relayPorts.relayPorts">
        function <span class="apidocSignatureSpan">osc.</span>relayPorts
        <span class="apidocSignatureSpan">(from, to, o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">relayPorts = function (from, to, o) {
    var eventName = o.raw ? "raw" : "osc",
        sendFnName = o.raw ? "sendRaw" : "send";

    return osc.relay(from, to, eventName, sendFnName, o.transform);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };

    p.listen = function () {
if (this.port1Spec &amp;&amp; this.port2Spec) {
    this.close();
}

this.port1Spec = osc.<span class="apidocCodeKeywordSpan">relayPorts</span>(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
// Users are still responsible for closing the underlying ports
// if necessary.
var closeListener = this.close.bind(this);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.stopRelaying" id="apidoc.module.osc.stopRelaying">module osc.stopRelaying</a></h1>


    <h2>
        <a href="#apidoc.element.osc.stopRelaying.stopRelaying" id="apidoc.element.osc.stopRelaying.stopRelaying">
        function <span class="apidocSignatureSpan">osc.</span>stopRelaying
        <span class="apidocSignatureSpan">(from, relaySpec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopRelaying = function (from, relaySpec) {
    from.removeListener(relaySpec.eventName, relaySpec.listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // if necessary.
    var closeListener = this.close.bind(this);
    this.port1.on("close", closeListener);
    this.port2.on("close", closeListener);
};

p.close = function () {
    osc.<span class="apidocCodeKeywordSpan">stopRelaying</span>(this.port1, this.port1Spec);
    osc.stopRelaying(this.port2, this.port2Spec);
    this.emit("close", this.port1, this.port2);
};


// If we're in a require-compatible environment, export ourselves.
if (typeof module !== "undefined" &amp;&amp; module.exports) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.timeTag" id="apidoc.module.osc.timeTag">module osc.timeTag</a></h1>


    <h2>
        <a href="#apidoc.element.osc.timeTag.timeTag" id="apidoc.element.osc.timeTag.timeTag">
        function <span class="apidocSignatureSpan">osc.</span>timeTag
        <span class="apidocSignatureSpan">(secs, now)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeTag = function (secs, now) {
    secs = secs || 0;
    now = now || Date.now();

    var nowSecs = now / 1000,
        nowWhole = Math.floor(nowSecs),
        nowFracs = nowSecs - nowWhole,
        secsWhole = Math.floor(secs),
        secsFracs = secs - secsWhole,
        fracs = nowFracs + secsFracs;

    if (fracs &gt; 1) {
        var fracsWhole = Math.floor(fracs),
            fracsFracs = fracs - fracsWhole;

        secsWhole += fracsWhole;
        fracs = fracsFracs;
    }

    var ntpSecs = nowWhole + secsWhole + osc.SECS_70YRS,
        ntpFracs = Math.round(osc.TWO_32 * fracs);

    return {
        raw: [ntpSecs, ntpFracs]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

##### Sending OSC bundles:
```javascript
oscPort.on("ready", function () {
oscPort.send({
    timeTag: osc.<span class="apidocCodeKeywordSpan">timeTag</span>(60), // Schedules this bundle 60 seconds from now.
    packets: [
        {
            address: "/carrier/frequency",
            args: 440
        },
        {
            address: "/carrier/amplitude"
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writeArgument" id="apidoc.module.osc.writeArgument">module osc.writeArgument</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writeArgument.writeArgument" id="apidoc.element.osc.writeArgument.writeArgument">
        function <span class="apidocSignatureSpan">osc.</span>writeArgument
        <span class="apidocSignatureSpan">(arg, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArgument = function (arg, dataCollection) {
    if (osc.isArray(arg)) {
        return osc.writeArrayArguments(arg, dataCollection);
    }

    var type = arg.type,
        writer = osc.argumentTypes[type].writer;

    if (writer) {
        var data = osc[writer](arg.value);
        osc.addDataPart(data, dataCollection);
    }

    return arg.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

osc.writeArrayArguments = function (args, dataCollection) {
    var typeTag = "[";

    for (var i = 0; i &lt; args.length; i++) {
        var arg = args[i];
        typeTag += osc.<span class="apidocCodeKeywordSpan">writeArgument</span>(arg, dataCollection);
    }

    typeTag += "]";

    return typeTag;
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writeArguments" id="apidoc.module.osc.writeArguments">module osc.writeArguments</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writeArguments.writeArguments" id="apidoc.element.osc.writeArguments.writeArguments">
        function <span class="apidocSignatureSpan">osc.</span>writeArguments
        <span class="apidocSignatureSpan">(args, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArguments = function (args, options) {
    var argCollection = osc.collectArguments(args, options);
    return osc.joinParts(argCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writeArrayArguments" id="apidoc.module.osc.writeArrayArguments">module osc.writeArrayArguments</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writeArrayArguments.writeArrayArguments" id="apidoc.element.osc.writeArrayArguments.writeArrayArguments">
        function <span class="apidocSignatureSpan">osc.</span>writeArrayArguments
        <span class="apidocSignatureSpan">(args, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArrayArguments = function (args, dataCollection) {
    var typeTag = "[";

    for (var i = 0; i &lt; args.length; i++) {
        var arg = args[i];
        typeTag += osc.writeArgument(arg, dataCollection);
    }

    typeTag += "]";

    return typeTag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
typeTag += "]";

return typeTag;
    };

    osc.writeArgument = function (arg, dataCollection) {
if (osc.isArray(arg)) {
    return osc.<span class="apidocCodeKeywordSpan">writeArrayArguments</span>(arg, dataCollection);
}

var type = arg.type,
    writer = osc.argumentTypes[type].writer;

if (writer) {
    var data = osc[writer](arg.value);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writeBlob" id="apidoc.module.osc.writeBlob">module osc.writeBlob</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writeBlob.writeBlob" id="apidoc.element.osc.writeBlob.writeBlob">
        function <span class="apidocSignatureSpan">osc.</span>writeBlob
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeBlob = function (data) {
    data = osc.byteArray(data);

    var len = data.byteLength,
        paddedLen = (len + 3) &amp; ~0x03,
        offset = 4, // Extra 4 bytes is for the size.
        blobLen = paddedLen + offset,
        arr = new Uint8Array(blobLen),
        dv = new DataView(arr.buffer);

    // Write the size.
    osc.writeInt32(len, dv);

    // Since we're writing to a real ArrayBuffer,
    // we don't need to pad the remaining bytes.
    arr.set(data, offset);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writeBundle" id="apidoc.module.osc.writeBundle">module osc.writeBundle</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writeBundle.writeBundle" id="apidoc.element.osc.writeBundle.writeBundle">
        function <span class="apidocSignatureSpan">osc.</span>writeBundle
        <span class="apidocSignatureSpan">(bundle, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeBundle = function (bundle, options) {
    if (!osc.isValidBundle(bundle)) {
        throw new Error("An OSC bundle must contain 'timeTag' and 'packets' properties. " +
            "Bundle was: " + JSON.stringify(bundle, null, 2));
    }

    options = options || osc.defaults;
    var bundleCollection = osc.collectBundlePackets(bundle, options);

    return osc.joinParts(bundleCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} [options] write options
 * @return {Uint8Array} an array of bytes containing the message
 */
osc.writePacket = function (packet, options) {
    if (osc.isValidMessage(packet)) {
        return osc.writeMessage(packet, options);
    } else if (osc.isValidBundle(packet)) {
        return osc.<span class="apidocCodeKeywordSpan">writeBundle</span>(packet, options);
    } else {
        throw new Error("The specified packet was not recognized as a valid OSC message or bundle." +
            " Packet was: " + JSON.stringify(packet, null, 2));
    }
};

// Unsupported, non-API.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writeChar32" id="apidoc.module.osc.writeChar32">module osc.writeChar32</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writeChar32.writeChar32" id="apidoc.element.osc.writeChar32.writeChar32">
        function <span class="apidocSignatureSpan">osc.</span>writeChar32
        <span class="apidocSignatureSpan">(str, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeChar32 = function (str, dv, offset) {
    var charCode = str.charCodeAt(0);
    if (charCode === undefined || charCode &lt; -1) {
        return undefined;
    }

    return osc.writePrimitive(charCode, dv, "setUint32", 4, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writeColor" id="apidoc.module.osc.writeColor">module osc.writeColor</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writeColor.writeColor" id="apidoc.element.osc.writeColor.writeColor">
        function <span class="apidocSignatureSpan">osc.</span>writeColor
        <span class="apidocSignatureSpan">(color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeColor = function (color) {
    var alpha = Math.round(color.a * 255),
        arr = new Uint8Array([color.r, color.g, color.b, alpha]);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writeFloat32" id="apidoc.module.osc.writeFloat32">module osc.writeFloat32</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writeFloat32.writeFloat32" id="apidoc.element.osc.writeFloat32.writeFloat32">
        function <span class="apidocSignatureSpan">osc.</span>writeFloat32
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFloat32 = function (val, dv, offset) {
    return osc.writePrimitive(val, dv, "setFloat32", 4, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writeFloat64" id="apidoc.module.osc.writeFloat64">module osc.writeFloat64</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writeFloat64.writeFloat64" id="apidoc.element.osc.writeFloat64.writeFloat64">
        function <span class="apidocSignatureSpan">osc.</span>writeFloat64
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFloat64 = function (val, dv, offset) {
    return osc.writePrimitive(val, dv, "setFloat64", 8, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writeInt32" id="apidoc.module.osc.writeInt32">module osc.writeInt32</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writeInt32.writeInt32" id="apidoc.element.osc.writeInt32.writeInt32">
        function <span class="apidocSignatureSpan">osc.</span>writeInt32
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt32 = function (val, dv, offset) {
    return osc.writePrimitive(val, dv, "setInt32", 4, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        paddedLen = (len + 3) &amp; ~0x03,
        offset = 4, // Extra 4 bytes is for the size.
        blobLen = paddedLen + offset,
        arr = new Uint8Array(blobLen),
        dv = new DataView(arr.buffer);

    // Write the size.
    osc.<span class="apidocCodeKeywordSpan">writeInt32</span>(len, dv);

    // Since we're writing to a real ArrayBuffer,
    // we don't need to pad the remaining bytes.
    arr.set(data, offset);

    return arr;
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writeInt64" id="apidoc.module.osc.writeInt64">module osc.writeInt64</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writeInt64.writeInt64" id="apidoc.element.osc.writeInt64.writeInt64">
        function <span class="apidocSignatureSpan">osc.</span>writeInt64
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt64 = function (val, dv, offset) {
    var arr = new Uint8Array(8);
    arr.set(osc.writePrimitive(val.high, dv, "setInt32", 4, offset), 0);
    arr.set(osc.writePrimitive(val.low,  dv, "setInt32", 4, offset + 4), 4);
    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writeMIDIBytes" id="apidoc.module.osc.writeMIDIBytes">module osc.writeMIDIBytes</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writeMIDIBytes.writeMIDIBytes" id="apidoc.element.osc.writeMIDIBytes.writeMIDIBytes">
        function <span class="apidocSignatureSpan">osc.</span>writeMIDIBytes
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeMIDIBytes = function (bytes) {
    bytes = osc.byteArray(bytes);

    var arr = new Uint8Array(4);
    arr.set(bytes);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writeMessage" id="apidoc.module.osc.writeMessage">module osc.writeMessage</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writeMessage.writeMessage" id="apidoc.element.osc.writeMessage.writeMessage">
        function <span class="apidocSignatureSpan">osc.</span>writeMessage
        <span class="apidocSignatureSpan">(msg, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeMessage = function (msg, options) {
    options = options || osc.defaults;

    if (!osc.isValidMessage(msg)) {
        throw new Error("An OSC message must contain a valid address. Message was: " +
            JSON.stringify(msg, null, 2));
    }

    var msgCollection = osc.collectMessageParts(msg, options);
    return osc.joinParts(msgCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Object} a bundle or message object
 * @param {Object} [options] write options
 * @return {Uint8Array} an array of bytes containing the message
 */
osc.writePacket = function (packet, options) {
    if (osc.isValidMessage(packet)) {
        return osc.<span class="apidocCodeKeywordSpan">writeMessage</span>(packet, options);
    } else if (osc.isValidBundle(packet)) {
        return osc.writeBundle(packet, options);
    } else {
        throw new Error("The specified packet was not recognized as a valid OSC message or bundle." +
            " Packet was: " + JSON.stringify(packet, null, 2));
    }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writePacket" id="apidoc.module.osc.writePacket">module osc.writePacket</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writePacket.writePacket" id="apidoc.element.osc.writePacket.writePacket">
        function <span class="apidocSignatureSpan">osc.</span>writePacket
        <span class="apidocSignatureSpan">(packet, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writePacket = function (packet, options) {
    if (osc.isValidMessage(packet)) {
        return osc.writeMessage(packet, options);
    } else if (osc.isValidBundle(packet)) {
        return osc.writeBundle(packet, options);
    } else {
        throw new Error("The specified packet was not recognized as a valid OSC message or bundle." +
            " Packet was: " + JSON.stringify(packet, null, 2));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &lt;code&gt;options&lt;/code&gt;: (optional) An options object, described below; &lt;br /&gt;
        &lt;code&gt;offsetState&lt;/code&gt;: (optional) an offset state object containing an &lt;code&gt;idx&lt;/
code&gt; property that specifies the offset index into &lt;code&gt;data&lt;/code&gt;; &lt;br /&gt;
        &lt;code&gt;length&lt;/code&gt; the length (in bytes) to read from &lt;code&gt;data&lt;/code&gt;
    &lt;/td&gt;
    &lt;td&gt;An osc.js message or bundle object&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;code&gt;osc.<span class="apidocCodeKeywordSpan">writePacket</span>()&lt;/code&gt;&lt;/td&gt;
    &lt;td&gt;Writes an OSC message or bundle object to a binary array.&lt;/td&gt;
    &lt;td&gt;
        &lt;code&gt;packate&lt;/code&gt;: An osc.js message or bundle object;&lt;br /&gt;
        &lt;code&gt;options&lt;/code&gt;: (optional) An options object, described below&lt;br /&gt;
    &lt;/td&gt;
    &lt;td&gt;A &lt;code&gt;Uint8Array&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writePrimitive" id="apidoc.module.osc.writePrimitive">module osc.writePrimitive</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writePrimitive.writePrimitive" id="apidoc.element.osc.writePrimitive.writePrimitive">
        function <span class="apidocSignatureSpan">osc.</span>writePrimitive
        <span class="apidocSignatureSpan">(val, dv, writerName, numBytes, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writePrimitive = function (val, dv, writerName, numBytes, offset) {
    offset = offset === undefined ? 0 : offset;

    var arr;
    if (!dv) {
        arr = new Uint8Array(numBytes);
        dv = new DataView(arr.buffer);
    } else {
        arr = new Uint8Array(dv.buffer);
    }

    dv[writerName](offset, val, false);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Writes an OSC int32 ("i") value.
 *
 * @param {Number} val the number to write
 * @param {DataView} [dv] a DataView instance to write the number into
 * @param {Number} [offset] an offset into dv
 */
osc.writeInt32 = function (val, dv, offset) {
    return osc.<span class="apidocCodeKeywordSpan">writePrimitive</span>(val, dv, "setInt32", 4, offset);
};

/**
 * Reads an OSC int64 ("h") value.
 *
 * @param {DataView} dv a DataView containing the raw bytes
 * @param {Object} offsetState an offsetState object used to store the current offset index into dv
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writeString" id="apidoc.module.osc.writeString">module osc.writeString</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writeString.writeString" id="apidoc.element.osc.writeString.writeString">
        function <span class="apidocSignatureSpan">osc.</span>writeString
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeString = function (str) {
    var terminated = str + "\u0000",
        len = terminated.length,
        paddedLen = (len + 3) &amp; ~0x03,
        arr = new Uint8Array(paddedLen);

    for (var i = 0; i &lt; terminated.length; i++) {
        var charCode = terminated.charCodeAt(i);
        arr[i] = charCode;
    }

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        currPartIdx = dataCollection.parts.length;

    for (var i = 0; i &lt; args.length; i++) {
        var arg = args[i];
        typeTagString += osc.writeArgument(arg, dataCollection);
    }

    var typeData = osc.<span class="apidocCodeKeywordSpan">writeString</span>(typeTagString);
    dataCollection.byteLength += typeData.byteLength;
    dataCollection.parts.splice(currPartIdx, 0, typeData);

    return dataCollection;
};

/**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.writeTimeTag" id="apidoc.module.osc.writeTimeTag">module osc.writeTimeTag</a></h1>


    <h2>
        <a href="#apidoc.element.osc.writeTimeTag.writeTimeTag" id="apidoc.element.osc.writeTimeTag.writeTimeTag">
        function <span class="apidocSignatureSpan">osc.</span>writeTimeTag
        <span class="apidocSignatureSpan">(timeTag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeTimeTag = function (timeTag) {
    var raw = timeTag.raw ? timeTag.raw : osc.jsToNTPTime(timeTag.native),
        arr = new Uint8Array(8), // Two Unit32s.
        dv = new DataView(arr.buffer);

    osc.writeInt32(raw[0], dv, 0);
    osc.writeInt32(raw[1], dv, 4);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    osc.collectBundlePackets = function (bundle, options, dataCollection) {
        dataCollection = dataCollection || {
byteLength: 0,
parts: []
        };

        osc.addDataPart(osc.writeString("#bundle"), dataCollection);
        osc.addDataPart(osc.<span class="apidocCodeKeywordSpan">writeTimeTag</span>(bundle.timeTag), dataCollection);

        for (var i = 0; i &lt; bundle.packets.length; i++) {
var packet = bundle.packets[i],
    collector = packet.address ? osc.collectMessageParts : osc.collectBundlePackets,
    packetCollection = collector(packet, options);

dataCollection.byteLength += packetCollection.byteLength;
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>