<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/colinbdclark/osc.js"

    >osc (v2.2.0)</a>
</h1>
<h4>A JavaScript Open Sound Control (OSC) library that works in Node.js and the browser.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc">module osc</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">osc.</span>isBufferEnv</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">osc.</span>isCommonJS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">osc.</span>isElectron</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">osc.</span>isNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port">
            function <span class="apidocSignatureSpan">osc.</span>Port
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay">
            function <span class="apidocSignatureSpan">osc.</span>Relay
            <span class="apidocSignatureSpan">(port1, port2, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SLIPPort">
            function <span class="apidocSignatureSpan">osc.</span>SLIPPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort">
            function <span class="apidocSignatureSpan">osc.</span>SerialPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort">
            function <span class="apidocSignatureSpan">osc.</span>TCPSocketPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort">
            function <span class="apidocSignatureSpan">osc.</span>UDPPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket
            <span class="apidocSignatureSpan">(address, protocols, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver
            <span class="apidocSignatureSpan">(extensions, maxPayload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender
            <span class="apidocSignatureSpan">(socket, extensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Server">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket.Server
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort">
            function <span class="apidocSignatureSpan">osc.</span>WebSocketPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.addDataPart">
            function <span class="apidocSignatureSpan">osc.</span>addDataPart
            <span class="apidocSignatureSpan">(dataPart, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.annotateArguments">
            function <span class="apidocSignatureSpan">osc.</span>annotateArguments
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.byteArray">
            function <span class="apidocSignatureSpan">osc.</span>byteArray
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.collectArguments">
            function <span class="apidocSignatureSpan">osc.</span>collectArguments
            <span class="apidocSignatureSpan">(args, options, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.collectBundlePackets">
            function <span class="apidocSignatureSpan">osc.</span>collectBundlePackets
            <span class="apidocSignatureSpan">(bundle, options, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.collectMessageParts">
            function <span class="apidocSignatureSpan">osc.</span>collectMessageParts
            <span class="apidocSignatureSpan">(msg, options, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.copyByteArray">
            function <span class="apidocSignatureSpan">osc.</span>copyByteArray
            <span class="apidocSignatureSpan">(source, target, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.dataView">
            function <span class="apidocSignatureSpan">osc.</span>dataView
            <span class="apidocSignatureSpan">(obj, offset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.fireBundleEvents">
            function <span class="apidocSignatureSpan">osc.</span>fireBundleEvents
            <span class="apidocSignatureSpan">(port, bundle, timeTag, packetInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.fireClosedPortSendError">
            function <span class="apidocSignatureSpan">osc.</span>fireClosedPortSendError
            <span class="apidocSignatureSpan">(port, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.firePacketEvents">
            function <span class="apidocSignatureSpan">osc.</span>firePacketEvents
            <span class="apidocSignatureSpan">(port, packet, timeTag, packetInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.inferTypeForArgument">
            function <span class="apidocSignatureSpan">osc.</span>inferTypeForArgument
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.isArray">
            function <span class="apidocSignatureSpan">osc.</span>isArray
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.isBuffer">
            function <span class="apidocSignatureSpan">osc.</span>isBuffer
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.isTypedArrayView">
            function <span class="apidocSignatureSpan">osc.</span>isTypedArrayView
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.isValidBundle">
            function <span class="apidocSignatureSpan">osc.</span>isValidBundle
            <span class="apidocSignatureSpan">(bundle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.isValidMessage">
            function <span class="apidocSignatureSpan">osc.</span>isValidMessage
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.joinParts">
            function <span class="apidocSignatureSpan">osc.</span>joinParts
            <span class="apidocSignatureSpan">(dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.jsToNTPTime">
            function <span class="apidocSignatureSpan">osc.</span>jsToNTPTime
            <span class="apidocSignatureSpan">(jsTime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.nativeBuffer">
            function <span class="apidocSignatureSpan">osc.</span>nativeBuffer
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.ntpToJSTime">
            function <span class="apidocSignatureSpan">osc.</span>ntpToJSTime
            <span class="apidocSignatureSpan">(secs1900, frac)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readArgument">
            function <span class="apidocSignatureSpan">osc.</span>readArgument
            <span class="apidocSignatureSpan">(argType, typeTagString, dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readArguments">
            function <span class="apidocSignatureSpan">osc.</span>readArguments
            <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readArgumentsIntoArray">
            function <span class="apidocSignatureSpan">osc.</span>readArgumentsIntoArray
            <span class="apidocSignatureSpan">(arr, argTypes, typeTagString, dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readBlob">
            function <span class="apidocSignatureSpan">osc.</span>readBlob
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readBundle">
            function <span class="apidocSignatureSpan">osc.</span>readBundle
            <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readBundleContents">
            function <span class="apidocSignatureSpan">osc.</span>readBundleContents
            <span class="apidocSignatureSpan">(dv, options, offsetState, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readChar32">
            function <span class="apidocSignatureSpan">osc.</span>readChar32
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readColor">
            function <span class="apidocSignatureSpan">osc.</span>readColor
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readFalse">
            function <span class="apidocSignatureSpan">osc.</span>readFalse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readFloat32">
            function <span class="apidocSignatureSpan">osc.</span>readFloat32
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readFloat64">
            function <span class="apidocSignatureSpan">osc.</span>readFloat64
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readImpulse">
            function <span class="apidocSignatureSpan">osc.</span>readImpulse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readInt32">
            function <span class="apidocSignatureSpan">osc.</span>readInt32
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readInt64">
            function <span class="apidocSignatureSpan">osc.</span>readInt64
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readMIDIBytes">
            function <span class="apidocSignatureSpan">osc.</span>readMIDIBytes
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readMessage">
            function <span class="apidocSignatureSpan">osc.</span>readMessage
            <span class="apidocSignatureSpan">(data, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readMessageContents">
            function <span class="apidocSignatureSpan">osc.</span>readMessageContents
            <span class="apidocSignatureSpan">(address, dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readNull">
            function <span class="apidocSignatureSpan">osc.</span>readNull
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readPacket">
            function <span class="apidocSignatureSpan">osc.</span>readPacket
            <span class="apidocSignatureSpan">(data, options, offsetState, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readPrimitive">
            function <span class="apidocSignatureSpan">osc.</span>readPrimitive
            <span class="apidocSignatureSpan">(dv, readerName, numBytes, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readString">
            function <span class="apidocSignatureSpan">osc.</span>readString
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readTimeTag">
            function <span class="apidocSignatureSpan">osc.</span>readTimeTag
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.readTrue">
            function <span class="apidocSignatureSpan">osc.</span>readTrue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.relay">
            function <span class="apidocSignatureSpan">osc.</span>relay
            <span class="apidocSignatureSpan">(from, to, eventName, sendFnName, transformFn, sendArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.relayPorts">
            function <span class="apidocSignatureSpan">osc.</span>relayPorts
            <span class="apidocSignatureSpan">(from, to, o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.stopRelaying">
            function <span class="apidocSignatureSpan">osc.</span>stopRelaying
            <span class="apidocSignatureSpan">(from, relaySpec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.timeTag">
            function <span class="apidocSignatureSpan">osc.</span>timeTag
            <span class="apidocSignatureSpan">(secs, now)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeArgument">
            function <span class="apidocSignatureSpan">osc.</span>writeArgument
            <span class="apidocSignatureSpan">(arg, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeArguments">
            function <span class="apidocSignatureSpan">osc.</span>writeArguments
            <span class="apidocSignatureSpan">(args, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeArrayArguments">
            function <span class="apidocSignatureSpan">osc.</span>writeArrayArguments
            <span class="apidocSignatureSpan">(args, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeBlob">
            function <span class="apidocSignatureSpan">osc.</span>writeBlob
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeBundle">
            function <span class="apidocSignatureSpan">osc.</span>writeBundle
            <span class="apidocSignatureSpan">(bundle, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeChar32">
            function <span class="apidocSignatureSpan">osc.</span>writeChar32
            <span class="apidocSignatureSpan">(str, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeColor">
            function <span class="apidocSignatureSpan">osc.</span>writeColor
            <span class="apidocSignatureSpan">(color)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeFloat32">
            function <span class="apidocSignatureSpan">osc.</span>writeFloat32
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeFloat64">
            function <span class="apidocSignatureSpan">osc.</span>writeFloat64
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeInt32">
            function <span class="apidocSignatureSpan">osc.</span>writeInt32
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeInt64">
            function <span class="apidocSignatureSpan">osc.</span>writeInt64
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeMIDIBytes">
            function <span class="apidocSignatureSpan">osc.</span>writeMIDIBytes
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeMessage">
            function <span class="apidocSignatureSpan">osc.</span>writeMessage
            <span class="apidocSignatureSpan">(msg, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writePacket">
            function <span class="apidocSignatureSpan">osc.</span>writePacket
            <span class="apidocSignatureSpan">(packet, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writePrimitive">
            function <span class="apidocSignatureSpan">osc.</span>writePrimitive
            <span class="apidocSignatureSpan">(val, dv, writerName, numBytes, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeString">
            function <span class="apidocSignatureSpan">osc.</span>writeString
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.writeTimeTag">
            function <span class="apidocSignatureSpan">osc.</span>writeTimeTag
            <span class="apidocSignatureSpan">(timeTag)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.</span>SECS_70YRS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.</span>TWO_32</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan"></span>osc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>Port.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>Relay.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>SLIPPort.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>SerialPort.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>TCPSocketPort.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>UDPPort.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>WebSocket.Server.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>WebSocket.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>WebSocketPort.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>argumentTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.</span>defaults</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.Port">module osc.Port</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port.Port">
            function <span class="apidocSignatureSpan">osc.</span>Port
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.Port.prototype">module osc.Port.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port.prototype.constructor">
            function <span class="apidocSignatureSpan">osc.Port.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port.prototype.decodeOSC">
            function <span class="apidocSignatureSpan">osc.Port.prototype.</span>decodeOSC
            <span class="apidocSignatureSpan">(data, packetInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port.prototype.encodeOSC">
            function <span class="apidocSignatureSpan">osc.Port.prototype.</span>encodeOSC
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Port.prototype.send">
            function <span class="apidocSignatureSpan">osc.Port.prototype.</span>send
            <span class="apidocSignatureSpan">(oscPacket)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.Relay">module osc.Relay</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay.Relay">
            function <span class="apidocSignatureSpan">osc.</span>Relay
            <span class="apidocSignatureSpan">(port1, port2, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.Relay.prototype">module osc.Relay.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay.prototype.close">
            function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay.prototype.constructor">
            function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>constructor
            <span class="apidocSignatureSpan">(port1, port2, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay.prototype.listen">
            function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.Relay.prototype.open">
            function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.SLIPPort">module osc.SLIPPort</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SLIPPort.SLIPPort">
            function <span class="apidocSignatureSpan">osc.</span>SLIPPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.SLIPPort.prototype">module osc.SLIPPort.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SLIPPort.prototype.constructor">
            function <span class="apidocSignatureSpan">osc.SLIPPort.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SLIPPort.prototype.decodeSLIPData">
            function <span class="apidocSignatureSpan">osc.SLIPPort.prototype.</span>decodeSLIPData
            <span class="apidocSignatureSpan">(data, packetInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SLIPPort.prototype.encodeOSC">
            function <span class="apidocSignatureSpan">osc.SLIPPort.prototype.</span>encodeOSC
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.SerialPort">module osc.SerialPort</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.SerialPort">
            function <span class="apidocSignatureSpan">osc.</span>SerialPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.SerialPort.prototype">module osc.SerialPort.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.close">
            function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.constructor">
            function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.listen">
            function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.open">
            function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.SerialPort.prototype.sendRaw">
            function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>sendRaw
            <span class="apidocSignatureSpan">(encoded)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.TCPSocketPort">module osc.TCPSocketPort</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.TCPSocketPort">
            function <span class="apidocSignatureSpan">osc.</span>TCPSocketPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.TCPSocketPort.prototype">module osc.TCPSocketPort.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.close">
            function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.constructor">
            function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.listen">
            function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.open">
            function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>open
            <span class="apidocSignatureSpan">(address, port)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.TCPSocketPort.prototype.sendRaw">
            function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>sendRaw
            <span class="apidocSignatureSpan">(encoded)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.UDPPort">module osc.UDPPort</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.UDPPort">
            function <span class="apidocSignatureSpan">osc.</span>UDPPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.setupMulticast">
            function <span class="apidocSignatureSpan">osc.UDPPort.</span>setupMulticast
            <span class="apidocSignatureSpan">(that)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.UDPPort.prototype">module osc.UDPPort.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.close">
            function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.constructor">
            function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.listen">
            function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.open">
            function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.UDPPort.prototype.sendRaw">
            function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>sendRaw
            <span class="apidocSignatureSpan">(encoded, address, port)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket">module osc.WebSocket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.WebSocket">
            function <span class="apidocSignatureSpan">osc.</span>WebSocket
            <span class="apidocSignatureSpan">(address, protocols, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>Receiver
            <span class="apidocSignatureSpan">(extensions, maxPayload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>Sender
            <span class="apidocSignatureSpan">(socket, extensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Server">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>Server
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.buildHostHeader">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>buildHostHeader
            <span class="apidocSignatureSpan">(isSecure, hostname, port)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.connect">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>connect
            <span class="apidocSignatureSpan">(address, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.createConnection">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>createConnection
            <span class="apidocSignatureSpan">(address, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.createServer">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>createServer
            <span class="apidocSignatureSpan">(options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.super_">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.WebSocket.</span>CLOSED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.WebSocket.</span>CLOSING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.WebSocket.</span>CONNECTING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.WebSocket.</span>OPEN</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver">module osc.WebSocket.Receiver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.Receiver">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>Receiver
            <span class="apidocSignatureSpan">(extensions, maxPayload)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Receiver.prototype">module osc.WebSocket.Receiver.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.add">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>add
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.allocateFromPool">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>allocateFromPool
            <span class="apidocSignatureSpan">(length, isFragmented)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.applyExtensions">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>applyExtensions
            <span class="apidocSignatureSpan">(messageBuffer, fin, compressed, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.cleanup">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>cleanup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.endPacket">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>endPacket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.error">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>error
            <span class="apidocSignatureSpan">(reason, protocolErrorCode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.expectData">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>expectData
            <span class="apidocSignatureSpan">(length, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.expectHeader">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>expectHeader
            <span class="apidocSignatureSpan">(length, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.flush">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.maxPayloadExceeded">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>maxPayloadExceeded
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.processPacket">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>processPacket
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.reset">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Receiver.prototype.unmask">
            function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>unmask
            <span class="apidocSignatureSpan">(mask, buf, binary)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Sender">module osc.WebSocket.Sender</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.Sender">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>Sender
            <span class="apidocSignatureSpan">(socket, extensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.super_">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Sender.prototype">module osc.WebSocket.Sender.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.applyExtensions">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>applyExtensions
            <span class="apidocSignatureSpan">(data, fin, compress, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.close">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>close
            <span class="apidocSignatureSpan">(code, data, mask, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.flush">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.frameAndSend">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>frameAndSend
            <span class="apidocSignatureSpan">(opcode, data, finalFragment, maskData, compressed, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.ping">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>ping
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.pong">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>pong
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Sender.prototype.send">
            function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>send
            <span class="apidocSignatureSpan">(data, options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Server">module osc.WebSocket.Server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Server.Server">
            function <span class="apidocSignatureSpan">osc.WebSocket.</span>Server
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Server.super_">
            function <span class="apidocSignatureSpan">osc.WebSocket.Server.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.Server.prototype">module osc.WebSocket.Server.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Server.prototype.close">
            function <span class="apidocSignatureSpan">osc.WebSocket.Server.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.Server.prototype.handleUpgrade">
            function <span class="apidocSignatureSpan">osc.WebSocket.Server.prototype.</span>handleUpgrade
            <span class="apidocSignatureSpan">(req, socket, upgradeHead, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocket.prototype">module osc.WebSocket.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.addEventListener">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>addEventListener
            <span class="apidocSignatureSpan">(method, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.close">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>close
            <span class="apidocSignatureSpan">(code, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.pause">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.ping">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>ping
            <span class="apidocSignatureSpan">(data, options, dontFailWhenClosed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.pong">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>pong
            <span class="apidocSignatureSpan">(data, options, dontFailWhenClosed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.resume">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.send">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>send
            <span class="apidocSignatureSpan">(data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.stream">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>stream
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocket.prototype.terminate">
            function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>terminate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>CLOSED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>CLOSING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>CONNECTING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>OPEN</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocketPort">module osc.WebSocketPort</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.WebSocketPort">
            function <span class="apidocSignatureSpan">osc.</span>WebSocketPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.setupSocketForBinary">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.</span>setupSocketForBinary
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.WebSocketPort.prototype">module osc.WebSocketPort.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.close">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>close
            <span class="apidocSignatureSpan">(code, reason)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.constructor">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.listen">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>listen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.open">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.WebSocketPort.prototype.sendRaw">
            function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>sendRaw
            <span class="apidocSignatureSpan">(encoded)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.osc.osc">module osc.osc</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">osc.osc.</span>isBufferEnv</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">osc.osc.</span>isCommonJS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">osc.osc.</span>isElectron</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">osc.osc.</span>isNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.Port">
            function <span class="apidocSignatureSpan">osc.osc.</span>Port
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.Relay">
            function <span class="apidocSignatureSpan">osc.osc.</span>Relay
            <span class="apidocSignatureSpan">(port1, port2, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.SLIPPort">
            function <span class="apidocSignatureSpan">osc.osc.</span>SLIPPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.WebSocket">
            function <span class="apidocSignatureSpan">osc.osc.</span>WebSocket
            <span class="apidocSignatureSpan">(address, protocols, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.WebSocketPort">
            function <span class="apidocSignatureSpan">osc.osc.</span>WebSocketPort
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.addDataPart">
            function <span class="apidocSignatureSpan">osc.osc.</span>addDataPart
            <span class="apidocSignatureSpan">(dataPart, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.annotateArguments">
            function <span class="apidocSignatureSpan">osc.osc.</span>annotateArguments
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.byteArray">
            function <span class="apidocSignatureSpan">osc.osc.</span>byteArray
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.collectArguments">
            function <span class="apidocSignatureSpan">osc.osc.</span>collectArguments
            <span class="apidocSignatureSpan">(args, options, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.collectBundlePackets">
            function <span class="apidocSignatureSpan">osc.osc.</span>collectBundlePackets
            <span class="apidocSignatureSpan">(bundle, options, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.collectMessageParts">
            function <span class="apidocSignatureSpan">osc.osc.</span>collectMessageParts
            <span class="apidocSignatureSpan">(msg, options, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.copyByteArray">
            function <span class="apidocSignatureSpan">osc.osc.</span>copyByteArray
            <span class="apidocSignatureSpan">(source, target, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.dataView">
            function <span class="apidocSignatureSpan">osc.osc.</span>dataView
            <span class="apidocSignatureSpan">(obj, offset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.fireBundleEvents">
            function <span class="apidocSignatureSpan">osc.osc.</span>fireBundleEvents
            <span class="apidocSignatureSpan">(port, bundle, timeTag, packetInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.fireClosedPortSendError">
            function <span class="apidocSignatureSpan">osc.osc.</span>fireClosedPortSendError
            <span class="apidocSignatureSpan">(port, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.firePacketEvents">
            function <span class="apidocSignatureSpan">osc.osc.</span>firePacketEvents
            <span class="apidocSignatureSpan">(port, packet, timeTag, packetInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.inferTypeForArgument">
            function <span class="apidocSignatureSpan">osc.osc.</span>inferTypeForArgument
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.isArray">
            function <span class="apidocSignatureSpan">osc.osc.</span>isArray
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.isBuffer">
            function <span class="apidocSignatureSpan">osc.osc.</span>isBuffer
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.isTypedArrayView">
            function <span class="apidocSignatureSpan">osc.osc.</span>isTypedArrayView
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.isValidBundle">
            function <span class="apidocSignatureSpan">osc.osc.</span>isValidBundle
            <span class="apidocSignatureSpan">(bundle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.isValidMessage">
            function <span class="apidocSignatureSpan">osc.osc.</span>isValidMessage
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.joinParts">
            function <span class="apidocSignatureSpan">osc.osc.</span>joinParts
            <span class="apidocSignatureSpan">(dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.jsToNTPTime">
            function <span class="apidocSignatureSpan">osc.osc.</span>jsToNTPTime
            <span class="apidocSignatureSpan">(jsTime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.nativeBuffer">
            function <span class="apidocSignatureSpan">osc.osc.</span>nativeBuffer
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.ntpToJSTime">
            function <span class="apidocSignatureSpan">osc.osc.</span>ntpToJSTime
            <span class="apidocSignatureSpan">(secs1900, frac)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readArgument">
            function <span class="apidocSignatureSpan">osc.osc.</span>readArgument
            <span class="apidocSignatureSpan">(argType, typeTagString, dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readArguments">
            function <span class="apidocSignatureSpan">osc.osc.</span>readArguments
            <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readArgumentsIntoArray">
            function <span class="apidocSignatureSpan">osc.osc.</span>readArgumentsIntoArray
            <span class="apidocSignatureSpan">(arr, argTypes, typeTagString, dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readBlob">
            function <span class="apidocSignatureSpan">osc.osc.</span>readBlob
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readBundle">
            function <span class="apidocSignatureSpan">osc.osc.</span>readBundle
            <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readBundleContents">
            function <span class="apidocSignatureSpan">osc.osc.</span>readBundleContents
            <span class="apidocSignatureSpan">(dv, options, offsetState, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readChar32">
            function <span class="apidocSignatureSpan">osc.osc.</span>readChar32
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readColor">
            function <span class="apidocSignatureSpan">osc.osc.</span>readColor
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readFalse">
            function <span class="apidocSignatureSpan">osc.osc.</span>readFalse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readFloat32">
            function <span class="apidocSignatureSpan">osc.osc.</span>readFloat32
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readFloat64">
            function <span class="apidocSignatureSpan">osc.osc.</span>readFloat64
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readImpulse">
            function <span class="apidocSignatureSpan">osc.osc.</span>readImpulse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readInt32">
            function <span class="apidocSignatureSpan">osc.osc.</span>readInt32
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readInt64">
            function <span class="apidocSignatureSpan">osc.osc.</span>readInt64
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readMIDIBytes">
            function <span class="apidocSignatureSpan">osc.osc.</span>readMIDIBytes
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readMessage">
            function <span class="apidocSignatureSpan">osc.osc.</span>readMessage
            <span class="apidocSignatureSpan">(data, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readMessageContents">
            function <span class="apidocSignatureSpan">osc.osc.</span>readMessageContents
            <span class="apidocSignatureSpan">(address, dv, options, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readNull">
            function <span class="apidocSignatureSpan">osc.osc.</span>readNull
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readPacket">
            function <span class="apidocSignatureSpan">osc.osc.</span>readPacket
            <span class="apidocSignatureSpan">(data, options, offsetState, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readPrimitive">
            function <span class="apidocSignatureSpan">osc.osc.</span>readPrimitive
            <span class="apidocSignatureSpan">(dv, readerName, numBytes, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readString">
            function <span class="apidocSignatureSpan">osc.osc.</span>readString
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readTimeTag">
            function <span class="apidocSignatureSpan">osc.osc.</span>readTimeTag
            <span class="apidocSignatureSpan">(dv, offsetState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.readTrue">
            function <span class="apidocSignatureSpan">osc.osc.</span>readTrue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.relay">
            function <span class="apidocSignatureSpan">osc.osc.</span>relay
            <span class="apidocSignatureSpan">(from, to, eventName, sendFnName, transformFn, sendArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.relayPorts">
            function <span class="apidocSignatureSpan">osc.osc.</span>relayPorts
            <span class="apidocSignatureSpan">(from, to, o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.stopRelaying">
            function <span class="apidocSignatureSpan">osc.osc.</span>stopRelaying
            <span class="apidocSignatureSpan">(from, relaySpec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.timeTag">
            function <span class="apidocSignatureSpan">osc.osc.</span>timeTag
            <span class="apidocSignatureSpan">(secs, now)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writeArgument">
            function <span class="apidocSignatureSpan">osc.osc.</span>writeArgument
            <span class="apidocSignatureSpan">(arg, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writeArguments">
            function <span class="apidocSignatureSpan">osc.osc.</span>writeArguments
            <span class="apidocSignatureSpan">(args, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writeArrayArguments">
            function <span class="apidocSignatureSpan">osc.osc.</span>writeArrayArguments
            <span class="apidocSignatureSpan">(args, dataCollection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writeBlob">
            function <span class="apidocSignatureSpan">osc.osc.</span>writeBlob
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writeBundle">
            function <span class="apidocSignatureSpan">osc.osc.</span>writeBundle
            <span class="apidocSignatureSpan">(bundle, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writeChar32">
            function <span class="apidocSignatureSpan">osc.osc.</span>writeChar32
            <span class="apidocSignatureSpan">(str, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writeColor">
            function <span class="apidocSignatureSpan">osc.osc.</span>writeColor
            <span class="apidocSignatureSpan">(color)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writeFloat32">
            function <span class="apidocSignatureSpan">osc.osc.</span>writeFloat32
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writeFloat64">
            function <span class="apidocSignatureSpan">osc.osc.</span>writeFloat64
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writeInt32">
            function <span class="apidocSignatureSpan">osc.osc.</span>writeInt32
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writeInt64">
            function <span class="apidocSignatureSpan">osc.osc.</span>writeInt64
            <span class="apidocSignatureSpan">(val, dv, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writeMIDIBytes">
            function <span class="apidocSignatureSpan">osc.osc.</span>writeMIDIBytes
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writeMessage">
            function <span class="apidocSignatureSpan">osc.osc.</span>writeMessage
            <span class="apidocSignatureSpan">(msg, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writePacket">
            function <span class="apidocSignatureSpan">osc.osc.</span>writePacket
            <span class="apidocSignatureSpan">(packet, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writePrimitive">
            function <span class="apidocSignatureSpan">osc.osc.</span>writePrimitive
            <span class="apidocSignatureSpan">(val, dv, writerName, numBytes, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writeString">
            function <span class="apidocSignatureSpan">osc.osc.</span>writeString
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.osc.osc.writeTimeTag">
            function <span class="apidocSignatureSpan">osc.osc.</span>writeTimeTag
            <span class="apidocSignatureSpan">(timeTag)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.osc.</span>SECS_70YRS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">osc.osc.</span>TWO_32</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.osc.</span>argumentTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">osc.osc.</span>defaults</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc" id="apidoc.module.osc">module osc</a></h1>










    <h2>
        <a href="#apidoc.element.osc.Port" id="apidoc.element.osc.Port">
        function <span class="apidocSignatureSpan">osc.</span>Port
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Port = function (options) {
    this.options = options || {};
    this.on(&#x22;data&#x22;, this.decodeOSC.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Relay" id="apidoc.element.osc.Relay">
        function <span class="apidocSignatureSpan">osc.</span>Relay
        <span class="apidocSignatureSpan">(port1, port2, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Relay = function (port1, port2, options) {
    var o = this.options = options || {};
    o.raw = false;

    this.port1 = port1;
    this.port2 = port2;

    this.listen();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SLIPPort" id="apidoc.element.osc.SLIPPort">
        function <span class="apidocSignatureSpan">osc.</span>SLIPPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SLIPPort = function (options) {
    var that = this;
    var o = this.options = options || {};
    o.useSLIP = o.useSLIP === undefined ? true : o.useSLIP;

    this.decoder = new slip.Decoder({
        onMessage: this.decodeOSC.bind(this),
        onError: function (err) {
            that.emit(&#x22;error&#x22;, err);
        }
    });

    var decodeHandler = o.useSLIP ? this.decodeSLIPData : this.decodeOSC;
    this.on(&#x22;data&#x22;, decodeHandler.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SerialPort" id="apidoc.element.osc.SerialPort">
        function <span class="apidocSignatureSpan">osc.</span>SerialPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SerialPort = function (options) {
    this.on(&#x22;open&#x22;, this.listen.bind(this));
    osc.SLIPPort.call(this, options);
    this.options.bitrate = this.options.bitrate || 9600;

    this.serialPort = options.serialPort;
    if (this.serialPort) {
        this.emit(&#x22;open&#x22;, this.serialPort);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
}
```

#### Connecting to the serial port and listening for OSC messages
```javascript
// Instantiate a new OSC Serial Port.
var serialPort = new osc.<span class="apidocCodeKeywordSpan">SerialPort</span>({
    devicePath: &#x22;/dev/cu.usbmodem22131&#x22;
});

// Listen for the message event and map the OSC message to the synth.
serialPort.on(&#x22;message&#x22;, function (oscMsg) {
    console.log(&#x22;An OSC message was received!&#x22;, oscMsg);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort" id="apidoc.element.osc.TCPSocketPort">
        function <span class="apidocSignatureSpan">osc.</span>TCPSocketPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TCPSocketPort = function (options) {
    osc.SLIPPort.call(this, options);

    var o = this.options;
    o.localAddress = o.localAddress || &#x22;127.0.0.1&#x22;;
    o.localPort = o.localPort !== undefined ? o.localPort : 57121;

    this.on(&#x22;open&#x22;, this.listen.bind(this));
    this.socket = options.socket;

    if (this.socket) {
        this.emit(&#x22;open&#x22;, this.socket);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort" id="apidoc.element.osc.UDPPort">
        function <span class="apidocSignatureSpan">osc.</span>UDPPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UDPPort = function (options) {
    osc.Port.call(this, options);

    this.options.localAddress = this.options.localAddress || &#x22;127.0.0.1&#x22;;
    this.options.localPort = this.options.localPort !== undefined ?
        this.options.localPort : 57121;

    this.options.remoteAddress = this.options.remoteAddress || &#x22;127.0.0.1&#x22;;
    this.options.remotePort = this.options.remotePort !== undefined ?
        this.options.remotePort : 57121;

    this.on(&#x22;open&#x22;, this.listen.bind(this));

    this.socket = options.socket;
    if (this.socket) {
        this.emit(&#x22;open&#x22;, this.socket);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3c;/tr&#x3e;
&#x3c;/table&#x3e;

#### Sample Code

```javascript
// Create an osc.js UDP Port listening on port 57121.
var udpPort = new osc.<span class="apidocCodeKeywordSpan">UDPPort</span>({
localAddress: &#x22;0.0.0.0&#x22;,
localPort: 57121
});

// Listen for incoming OSC bundles.
udpPort.on(&#x22;bundle&#x22;, function (oscBundle, timeTag, info) {
console.log(&#x22;An OSC bundle just arrived for time tag&#x22;, timeTag, &#x22;:&#x22;, oscBundle);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket" id="apidoc.element.osc.WebSocket">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket
        <span class="apidocSignatureSpan">(address, protocols, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocket(address, protocols, options) {
  if (this instanceof WebSocket === false) {
    return new WebSocket(address, protocols, options);
  }

  EventEmitter.call(this);

  if (protocols &#x26;&#x26; !Array.isArray(protocols) &#x26;&#x26; &#x27;object&#x27; === typeof protocols) {
    // accept the &#x22;options&#x22; Object as the 2nd argument
    options = protocols;
    protocols = null;
  }

  if (&#x27;string&#x27; === typeof protocols) {
    protocols = [ protocols ];
  }

  if (!Array.isArray(protocols)) {
    protocols = [];
  }

  this._socket = null;
  this._ultron = null;
  this._closeReceived = false;
  this.bytesReceived = 0;
  this.readyState = null;
  this.supports = {};
  this.extensions = {};
  this._binaryType = &#x27;nodebuffer&#x27;;

  if (Array.isArray(address)) {
    initAsServerClient.apply(this, address.concat(options));
  } else {
    initAsClient.apply(this, [address, protocols, options]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };

    var p = osc.WebSocketPort.prototype = Object.create(osc.Port.prototype);
    p.constructor = osc.WebSocketPort;

    p.open = function () {
if (!this.socket || this.socket.readyState &#x3e; 1) {
    this.socket = new osc.<span class="apidocCodeKeywordSpan">WebSocket</span>(this.options.url);
}

osc.WebSocketPort.setupSocketForBinary(this.socket);

var that = this;
this.socket.onopen = function () {
    that.emit(&#x22;open&#x22;, that.socket);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver" id="apidoc.element.osc.WebSocket.Receiver">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Receiver
        <span class="apidocSignatureSpan">(extensions, maxPayload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Receiver(extensions, maxPayload) {
  if (this instanceof Receiver === false) {
    throw new TypeError(&#x22;Classes can&#x27;t be function-called&#x22;);
  }
  if(typeof extensions===&#x27;number&#x27;){
    maxPayload=extensions;
    extensions={};
  }


  // memory pool for fragmented messages
  var fragmentedPoolPrevUsed = -1;
  this.fragmentedBufferPool = new BufferPool(1024, function(db, length) {
    return db.used + length;
  }, function(db) {
    return fragmentedPoolPrevUsed = fragmentedPoolPrevUsed &#x3e;= 0 ?
      Math.ceil((fragmentedPoolPrevUsed + db.used) / 2) :
      db.used;
  });

  // memory pool for unfragmented messages
  var unfragmentedPoolPrevUsed = -1;
  this.unfragmentedBufferPool = new BufferPool(1024, function(db, length) {
    return db.used + length;
  }, function(db) {
    return unfragmentedPoolPrevUsed = unfragmentedPoolPrevUsed &#x3e;= 0 ?
      Math.ceil((unfragmentedPoolPrevUsed + db.used) / 2) :
      db.used;
  });
  this.extensions = extensions || {};
  this.maxPayload = maxPayload || 0;
  this.currentPayloadLength = 0;
  this.state = {
    activeFragmentedOperation: null,
    lastFragment: false,
    masked: false,
    opcode: 0,
    fragmentedOperation: false
  };
  this.overflow = [];
  this.headerBuffer = new Buffer(10);
  this.expectOffset = 0;
  this.expectBuffer = null;
  this.expectHandler = null;
  this.currentMessage = [];
  this.currentMessageLength = 0;
  this.messageHandlers = [];
  this.expectHeader(2, this.processPacket);
  this.dead = false;
  this.processing = false;

  this.onerror = function() {};
  this.ontext = function() {};
  this.onbinary = function() {};
  this.onclose = function() {};
  this.onping = function() {};
  this.onpong = function() {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender" id="apidoc.element.osc.WebSocket.Sender">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Sender
        <span class="apidocSignatureSpan">(socket, extensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Sender(socket, extensions) {
  if (this instanceof Sender === false) {
    throw new TypeError(&#x22;Classes can&#x27;t be function-called&#x22;);
  }

  events.EventEmitter.call(this);

  this._socket = socket;
  this.extensions = extensions || {};
  this.firstFragment = true;
  this.compress = false;
  this.messageHandlers = [];
  this.processing = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Server" id="apidoc.element.osc.WebSocket.Server">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket.Server
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketServer(options, callback) {
  if (this instanceof WebSocketServer === false) {
    return new WebSocketServer(options, callback);
  }

  events.EventEmitter.call(this);

  options = new Options({
    host: &#x27;0.0.0.0&#x27;,
    port: null,
    server: null,
    verifyClient: null,
    handleProtocols: null,
    path: null,
    noServer: false,
    disableHixie: false,
    clientTracking: true,
    perMessageDeflate: true,
    maxPayload: 100 * 1024 * 1024
  }).merge(options);

  if (!options.isDefinedAndNonNull(&#x27;port&#x27;) &#x26;&#x26; !options.isDefinedAndNonNull(&#x27;server&#x27;) &#x26;&#x26; !options.value.noServer) {
    throw new TypeError(&#x27;`port` or a `server` must be provided&#x27;);
  }

  var self = this;

  if (options.isDefinedAndNonNull(&#x27;port&#x27;)) {
    this._server = http.createServer(function (req, res) {
      var body = http.STATUS_CODES[426];
      res.writeHead(426, {
        &#x27;Content-Length&#x27;: body.length,
        &#x27;Content-Type&#x27;: &#x27;text/plain&#x27;
      });
      res.end(body);
    });
    this._server.allowHalfOpen = false;
    this._server.listen(options.value.port, options.value.host, callback);
    this._closeServer = function() { if (self._server) self._server.close(); };
  }
  else if (options.value.server) {
    this._server = options.value.server;
    if (options.value.path) {
      // take note of the path, to avoid collisions when multiple websocket servers are
      // listening on the same http server
      if (this._server._webSocketPaths &#x26;&#x26; options.value.server._webSocketPaths[options.value.path]) {
        throw new Error(&#x27;two instances of WebSocketServer cannot listen on the same http server path&#x27;);
      }
      if (typeof this._server._webSocketPaths !== &#x27;object&#x27;) {
        this._server._webSocketPaths = {};
      }
      this._server._webSocketPaths[options.value.path] = 1;
    }
  }
  if (this._server) {
    this._onceServerListening = function() { self.emit(&#x27;listening&#x27;); };
    this._server.once(&#x27;listening&#x27;, this._onceServerListening);
  }

  if (typeof this._server != &#x27;undefined&#x27;) {
    this._onServerError = function(error) { self.emit(&#x27;error&#x27;, error) };
    this._server.on(&#x27;error&#x27;, this._onServerError);
    this._onServerUpgrade = function(req, socket, upgradeHead) {
      //copy upgradeHead to avoid retention of large slab buffers used in node core
      var head = new Buffer(upgradeHead.length);
      upgradeHead.copy(head);

      self.handleUpgrade(req, socket, head, function(client) {
        self.emit(&#x27;connection&#x27;+req.url, client);
        self.emit(&#x27;connection&#x27;, client);
      });
    };
    this._server.on(&#x27;upgrade&#x27;, this._onServerUpgrade);
  }

  this.options = options.value;
  this.path = options.value.path;
  this.clients = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort" id="apidoc.element.osc.WebSocketPort">
        function <span class="apidocSignatureSpan">osc.</span>WebSocketPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocketPort = function (options) {
    osc.Port.call(this, options);
    this.on(&#x22;open&#x22;, this.listen.bind(this));

    this.socket = options.socket;
    if (this.socket) {
        if (this.socket.readyState === 1) {
            osc.WebSocketPort.setupSocketForBinary(this.socket);
            this.emit(&#x22;open&#x22;, this.socket);
        } else {
            this.open();
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x3c;/head&#x3e;
    &#x3c;body&#x3e;&#x3c;/body&#x3e;
&#x3c;/html&#x3e;
```

##### Creating an OSC Web Socket Port object:
```javascript
var oscPort = new osc.<span class="apidocCodeKeywordSpan">WebSocketPort</span>({
    url: &#x22;ws://localhost:8081&#x22; // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.open();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.addDataPart" id="apidoc.element.osc.addDataPart">
        function <span class="apidocSignatureSpan">osc.</span>addDataPart
        <span class="apidocSignatureSpan">(dataPart, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addDataPart = function (dataPart, dataCollection) {
    dataCollection.parts.push(dataPart);
    dataCollection.byteLength += dataPart.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    var type = arg.type,
        writer = osc.argumentTypes[type].writer;

    if (writer) {
        var data = osc[writer](arg.value);
        osc.<span class="apidocCodeKeywordSpan">addDataPart</span>(data, dataCollection);
    }

    return arg.type;
};

// Unsupported, non-API function.
osc.collectArguments = function (args, options, dataCollection) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.annotateArguments" id="apidoc.element.osc.annotateArguments">
        function <span class="apidocSignatureSpan">osc.</span>annotateArguments
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">annotateArguments = function (args) {
    var annotated = [];

    for (var i = 0; i &#x3c; args.length; i++) {
        var arg = args[i],
            msgArg;

        if (typeof (arg) === &#x22;object&#x22; &#x26;&#x26; arg.type &#x26;&#x26; arg.value !== undefined) {
            // We&#x27;ve got an explicitly typed argument.
            msgArg = arg;
        } else if (osc.isArray(arg)) {
            // We&#x27;ve got an array of arguments,
            // so they each need to be inferred and expanded.
            msgArg = osc.annotateArguments(arg);
        } else {
            var oscType = osc.inferTypeForArgument(arg);
            msgArg = {
                type: oscType,
                value: arg
            };
        }

        annotated.push(msgArg);
    }

    return annotated;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

dataCollection = dataCollection || {
    byteLength: 0,
    parts: []
};

if (!options.metadata) {
    args = osc.<span class="apidocCodeKeywordSpan">annotateArguments</span>(args);
}

var typeTagString = &#x22;,&#x22;,
    currPartIdx = dataCollection.parts.length;

for (var i = 0; i &#x3c; args.length; i++) {
    var arg = args[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.byteArray" id="apidoc.element.osc.byteArray">
        function <span class="apidocSignatureSpan">osc.</span>byteArray
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">byteArray = function (obj) {
    if (obj instanceof Uint8Array) {
        return obj;
    }

    var buf = obj.buffer ? obj.buffer : obj;

    if (!(buf instanceof ArrayBuffer) &#x26;&#x26; (typeof buf.length === &#x22;undefined&#x22; || typeof buf === &#x22;string&#x22;)) {
        throw new Error(&#x22;Can&#x27;t wrap a non-array-like object as Uint8Array. Object was: &#x22; +
            JSON.stringify(obj, null, 2));
    }


    // TODO gh-39: This is a potentially unsafe algorithm;
    // if we&#x27;re getting anything other than a TypedArrayView (such as a DataView),
    // we really need to determine the range of the view it is viewing.
    return new Uint8Array(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    /**
     * Writes a raw collection of bytes to a new ArrayBuffer.
     *
     * @param {Array-like} data a collection of octets
     * @return {ArrayBuffer} a buffer containing the OSC-formatted blob
     */
    osc.writeBlob = function (data) {
data = osc.<span class="apidocCodeKeywordSpan">byteArray</span>(data);

var len = data.byteLength,
    paddedLen = (len + 3) &#x26; ~0x03,
    offset = 4, // Extra 4 bytes is for the size.
    blobLen = paddedLen + offset,
    arr = new Uint8Array(blobLen),
    dv = new DataView(arr.buffer);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.collectArguments" id="apidoc.element.osc.collectArguments">
        function <span class="apidocSignatureSpan">osc.</span>collectArguments
        <span class="apidocSignatureSpan">(args, options, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectArguments = function (args, options, dataCollection) {
    if (!osc.isArray(args)) {
        args = typeof args === &#x22;undefined&#x22; ? [] : [args];
    }

    dataCollection = dataCollection || {
        byteLength: 0,
        parts: []
    };

    if (!options.metadata) {
        args = osc.annotateArguments(args);
    }

    var typeTagString = &#x22;,&#x22;,
        currPartIdx = dataCollection.parts.length;

    for (var i = 0; i &#x3c; args.length; i++) {
        var arg = args[i];
        typeTagString += osc.writeArgument(arg, dataCollection);
    }

    var typeData = osc.writeString(typeTagString);
    dataCollection.byteLength += typeData.byteLength;
    dataCollection.parts.splice(currPartIdx, 0, typeData);

    return dataCollection;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Writes the specified arguments.
 *
 * @param {Array} args an array of arguments
 * @param {Object} options options for writing
 * @return {Uint8Array} a buffer containing the OSC-formatted argument type tag and values
 */
osc.writeArguments = function (args, options) {
    var argCollection = osc.<span class="apidocCodeKeywordSpan">collectArguments</span>(args, options);
    return osc.joinParts(argCollection);
};

// Unsupported, non-API function.
osc.joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.collectBundlePackets" id="apidoc.element.osc.collectBundlePackets">
        function <span class="apidocSignatureSpan">osc.</span>collectBundlePackets
        <span class="apidocSignatureSpan">(bundle, options, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectBundlePackets = function (bundle, options, dataCollection) {
    dataCollection = dataCollection || {
        byteLength: 0,
        parts: []
    };

    osc.addDataPart(osc.writeString(&#x22;#bundle&#x22;), dataCollection);
    osc.addDataPart(osc.writeTimeTag(bundle.timeTag), dataCollection);

    for (var i = 0; i &#x3c; bundle.packets.length; i++) {
        var packet = bundle.packets[i],
            collector = packet.address ? osc.collectMessageParts : osc.collectBundlePackets,
            packetCollection = collector(packet, options);

        dataCollection.byteLength += packetCollection.byteLength;
        osc.addDataPart(osc.writeInt32(packetCollection.byteLength), dataCollection);
        dataCollection.parts = dataCollection.parts.concat(packetCollection.parts);
    }

    return dataCollection;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
osc.writeBundle = function (bundle, options) {
    if (!osc.isValidBundle(bundle)) {
        throw new Error(&#x22;An OSC bundle must contain &#x27;timeTag&#x27; and &#x27;packets&#x27; properties. &#x22; +
            &#x22;Bundle was: &#x22; + JSON.stringify(bundle, null, 2));
    }

    options = options || osc.defaults;
    var bundleCollection = osc.<span class="apidocCodeKeywordSpan">collectBundlePackets</span>(bundle, options);

    return osc.joinParts(bundleCollection);
};

osc.isValidBundle = function (bundle) {
    return bundle.timeTag !== undefined &#x26;&#x26; bundle.packets !== undefined;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.collectMessageParts" id="apidoc.element.osc.collectMessageParts">
        function <span class="apidocSignatureSpan">osc.</span>collectMessageParts
        <span class="apidocSignatureSpan">(msg, options, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectMessageParts = function (msg, options, dataCollection) {
    dataCollection = dataCollection || {
        byteLength: 0,
        parts: []
    };

    osc.addDataPart(osc.writeString(msg.address), dataCollection);
    return osc.collectArguments(msg.args, options, dataCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    options = options || osc.defaults;

    if (!osc.isValidMessage(msg)) {
        throw new Error(&#x22;An OSC message must contain a valid address. Message was: &#x22; +
            JSON.stringify(msg, null, 2));
    }

    var msgCollection = osc.<span class="apidocCodeKeywordSpan">collectMessageParts</span>(msg, options);
    return osc.joinParts(msgCollection);
};

osc.isValidMessage = function (msg) {
    return msg.address &#x26;&#x26; msg.address.indexOf(&#x22;/&#x22;) === 0;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.copyByteArray" id="apidoc.element.osc.copyByteArray">
        function <span class="apidocSignatureSpan">osc.</span>copyByteArray
        <span class="apidocSignatureSpan">(source, target, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copyByteArray = function (source, target, offset) {
    if (osc.isTypedArrayView(source) &#x26;&#x26; osc.isTypedArrayView(target)) {
        target.set(source, offset);
    } else {
        var start = offset === undefined ? 0 : offset,
            len = Math.min(target.length - offset, source.length);

        for (var i = 0, j = start; i &#x3c; len; i++, j++) {
            target[j] = source[i];
        }
    }

    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
osc.joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
        offset = 0;

    for (var i = 0; i &#x3c; parts.length; i++) {
        var part = parts[i];
        osc.<span class="apidocCodeKeywordSpan">copyByteArray</span>(part, buf, offset);
        offset += part.length;
    }

    return buf;
};

// Unsupported, non-API function.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.dataView" id="apidoc.element.osc.dataView">
        function <span class="apidocSignatureSpan">osc.</span>dataView
        <span class="apidocSignatureSpan">(obj, offset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dataView = function (obj, offset, length) {
    if (obj.buffer) {
        return new DataView(obj.buffer, offset, length);
    }

    if (obj instanceof ArrayBuffer) {
        return new DataView(obj, offset, length);
    }

    return new DataView(new Uint8Array(obj), offset, length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} [options] read options
 * @param {Object} [offsetState] an offsetState object that stores the current offset into dv
 * @return {Object} the OSC message, formatted as a JavaScript object containing &#x22;address&#x22; and &#x22;args&#x22; properties
 */
osc.readMessage = function (data, options, offsetState) {
    options = options || osc.defaults;

    var dv = osc.<span class="apidocCodeKeywordSpan">dataView</span>(data, data.byteOffset, data.byteLength);
    offsetState = offsetState || {
        idx: 0
    };

    var address = osc.readString(dv, offsetState);
    return osc.readMessageContents(address, dv, options, offsetState);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.fireBundleEvents" id="apidoc.element.osc.fireBundleEvents">
        function <span class="apidocSignatureSpan">osc.</span>fireBundleEvents
        <span class="apidocSignatureSpan">(port, bundle, timeTag, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fireBundleEvents = function (port, bundle, timeTag, packetInfo) {
    port.emit(&#x22;bundle&#x22;, bundle, timeTag, packetInfo);
    for (var i = 0; i &#x3c; bundle.packets.length; i++) {
        var packet = bundle.packets[i];
        osc.firePacketEvents(port, packet, bundle.timeTag, packetInfo);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x22;use strict&#x22;;

// Unsupported, non-API function.
osc.firePacketEvents = function (port, packet, timeTag, packetInfo) {
    if (packet.address) {
        port.emit(&#x22;message&#x22;, packet, timeTag, packetInfo);
    } else {
        osc.<span class="apidocCodeKeywordSpan">fireBundleEvents</span>(port, packet, timeTag, packetInfo);
    }
};

// Unsupported, non-API function.
osc.fireBundleEvents = function (port, bundle, timeTag, packetInfo) {
    port.emit(&#x22;bundle&#x22;, bundle, timeTag, packetInfo);
    for (var i = 0; i &#x3c; bundle.packets.length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.fireClosedPortSendError" id="apidoc.element.osc.fireClosedPortSendError">
        function <span class="apidocSignatureSpan">osc.</span>fireClosedPortSendError
        <span class="apidocSignatureSpan">(port, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fireClosedPortSendError = function (port, msg) {
    msg = msg || &#x22;Can&#x27;t send packets on a closed osc.Port object. Please open (or reopen) this Port by calling open().&#x22;;

    port.emit(&#x22;error&#x22;, msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    p.listen = function () {
osc.listenToTransport(this, chrome.serial, &#x22;connectionId&#x22;);
    };

    p.sendRaw = function (encoded) {
if (!this.connectionId) {
    osc.<span class="apidocCodeKeywordSpan">fireClosedPortSendError</span>(this);
    return;
}

var that = this;

// TODO gh-39: This is unsafe; we should only access the underlying
// buffer within the range of its view.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.firePacketEvents" id="apidoc.element.osc.firePacketEvents">
        function <span class="apidocSignatureSpan">osc.</span>firePacketEvents
        <span class="apidocSignatureSpan">(port, packet, timeTag, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">firePacketEvents = function (port, packet, timeTag, packetInfo) {
    if (packet.address) {
        port.emit(&#x22;message&#x22;, packet, timeTag, packetInfo);
    } else {
        osc.fireBundleEvents(port, packet, timeTag, packetInfo);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };

    // Unsupported, non-API function.
    osc.fireBundleEvents = function (port, bundle, timeTag, packetInfo) {
port.emit(&#x22;bundle&#x22;, bundle, timeTag, packetInfo);
for (var i = 0; i &#x3c; bundle.packets.length; i++) {
    var packet = bundle.packets[i];
    osc.<span class="apidocCodeKeywordSpan">firePacketEvents</span>(port, packet, bundle.timeTag, packetInfo);
}
    };

    osc.fireClosedPortSendError = function (port, msg) {
msg = msg || &#x22;Can&#x27;t send packets on a closed osc.Port object. Please open (or reopen) this Port by calling open().&#x22
;;

port.emit(&#x22;error&#x22;, msg);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.inferTypeForArgument" id="apidoc.element.osc.inferTypeForArgument">
        function <span class="apidocSignatureSpan">osc.</span>inferTypeForArgument
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inferTypeForArgument = function (arg) {
    var type = typeof arg;

    // TODO: This is freaking hideous.
    switch (type) {
        case &#x22;boolean&#x22;:
            return arg ? &#x22;T&#x22; : &#x22;F&#x22;;
        case &#x22;string&#x22;:
            return &#x22;s&#x22;;
        case &#x22;number&#x22;:
            return &#x22;f&#x22;;
        case &#x22;undefined&#x22;:
            return &#x22;N&#x22;;
        case &#x22;object&#x22;:
            if (arg === null) {
                return &#x22;N&#x22;;
            } else if (arg instanceof Uint8Array ||
                arg instanceof ArrayBuffer) {
                return &#x22;b&#x22;;
            } else if (typeof arg.high === &#x22;number&#x22; &#x26;&#x26; typeof arg.low === &#x22;number&#x22;) {
                return &#x22;h&#x22;;
            }
            break;
    }

    throw new Error(&#x22;Can&#x27;t infer OSC argument type for value: &#x22; +
        JSON.stringify(arg, null, 2));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // We&#x27;ve got an explicitly typed argument.
    msgArg = arg;
} else if (osc.isArray(arg)) {
    // We&#x27;ve got an array of arguments,
    // so they each need to be inferred and expanded.
    msgArg = osc.annotateArguments(arg);
} else {
    var oscType = osc.<span class="apidocCodeKeywordSpan">inferTypeForArgument</span>(arg);
    msgArg = {
        type: oscType,
        value: arg
    };
}

annotated.push(msgArg);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.isArray" id="apidoc.element.osc.isArray">
        function <span class="apidocSignatureSpan">osc.</span>isArray
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (obj) {
    return obj &#x26;&#x26; Object.prototype.toString.call(obj) === &#x22;[object Array]&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

typeTag += &#x22;]&#x22;;

return typeTag;
    };

    osc.writeArgument = function (arg, dataCollection) {
if (osc.<span class="apidocCodeKeywordSpan">isArray</span>(arg)) {
    return osc.writeArrayArguments(arg, dataCollection);
}

var type = arg.type,
    writer = osc.argumentTypes[type].writer;

if (writer) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.isBuffer" id="apidoc.element.osc.isBuffer">
        function <span class="apidocSignatureSpan">osc.</span>isBuffer
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBuffer = function (obj) {
    return osc.isBufferEnv &#x26;&#x26; obj instanceof Buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Array-like or Array-wrapping} obj an array-like or array-wrapping object
 * @returns {Buffer|Uint8Array} a buffer object
 */
// Unsupported, non-API function.
osc.nativeBuffer = function (obj) {
    if (osc.isBufferEnv) {
        return osc.<span class="apidocCodeKeywordSpan">isBuffer</span>(obj) ? obj :
            new Buffer(obj.buffer ? obj : new Uint8Array(obj));
    }

    return osc.isTypedArrayView(obj) ? obj : new Uint8Array(obj);
};

// Unsupported, non-API function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.isTypedArrayView" id="apidoc.element.osc.isTypedArrayView">
        function <span class="apidocSignatureSpan">osc.</span>isTypedArrayView
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isTypedArrayView = function (obj) {
    return obj.buffer &#x26;&#x26; obj.buffer instanceof ArrayBuffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Unsupported, non-API function.
osc.nativeBuffer = function (obj) {
    if (osc.isBufferEnv) {
        return osc.isBuffer(obj) ? obj :
            new Buffer(obj.buffer ? obj : new Uint8Array(obj));
    }

    return osc.<span class="apidocCodeKeywordSpan">isTypedArrayView</span>(obj) ? obj : new Uint8Array(obj);
};

// Unsupported, non-API function
osc.copyByteArray = function (source, target, offset) {
    if (osc.isTypedArrayView(source) &#x26;&#x26; osc.isTypedArrayView(target)) {
        target.set(source, offset);
    } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.isValidBundle" id="apidoc.element.osc.isValidBundle">
        function <span class="apidocSignatureSpan">osc.</span>isValidBundle
        <span class="apidocSignatureSpan">(bundle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidBundle = function (bundle) {
    return bundle.timeTag !== undefined &#x26;&#x26; bundle.packets !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * Writes an OSC bundle.
     *
     * @param {Object} a bundle object containing &#x22;timeTag&#x22; and &#x22;packets&#x22; properties
     * @param {object} [options] write options
     * @return {Uint8Array} an array of bytes containing the message
     */
    osc.writeBundle = function (bundle, options) {
if (!osc.<span class="apidocCodeKeywordSpan">isValidBundle</span>(bundle)) {
    throw new Error(&#x22;An OSC bundle must contain &#x27;timeTag&#x27; and &#x27;packets&#x27; properties. &#x22; +
        &#x22;Bundle was: &#x22; + JSON.stringify(bundle, null, 2));
}

options = options || osc.defaults;
var bundleCollection = osc.collectBundlePackets(bundle, options);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.isValidMessage" id="apidoc.element.osc.isValidMessage">
        function <span class="apidocSignatureSpan">osc.</span>isValidMessage
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidMessage = function (msg) {
    return msg.address &#x26;&#x26; msg.address.indexOf(&#x22;/&#x22;) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} msg a message object containing &#x22;address&#x22; and &#x22;args&#x22; properties
 * @param {Object} [options] write options
 * @return {Uint8Array} an array of bytes containing the OSC message
 */
osc.writeMessage = function (msg, options) {
    options = options || osc.defaults;

    if (!osc.<span class="apidocCodeKeywordSpan">isValidMessage</span>(msg)) {
        throw new Error(&#x22;An OSC message must contain a valid address. Message was: &#x22; +
            JSON.stringify(msg, null, 2));
    }

    var msgCollection = osc.collectMessageParts(msg, options);
    return osc.joinParts(msgCollection);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.joinParts" id="apidoc.element.osc.joinParts">
        function <span class="apidocSignatureSpan">osc.</span>joinParts
        <span class="apidocSignatureSpan">(dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
        offset = 0;

    for (var i = 0; i &#x3c; parts.length; i++) {
        var part = parts[i];
        osc.copyByteArray(part, buf, offset);
        offset += part.length;
    }

    return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Array} args an array of arguments
 * @param {Object} options options for writing
 * @return {Uint8Array} a buffer containing the OSC-formatted argument type tag and values
 */
osc.writeArguments = function (args, options) {
    var argCollection = osc.collectArguments(args, options);
    return osc.<span class="apidocCodeKeywordSpan">joinParts</span>(argCollection);
};

// Unsupported, non-API function.
osc.joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
        offset = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.jsToNTPTime" id="apidoc.element.osc.jsToNTPTime">
        function <span class="apidocSignatureSpan">osc.</span>jsToNTPTime
        <span class="apidocSignatureSpan">(jsTime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsToNTPTime = function (jsTime) {
    var secs = jsTime / 1000,
        secsWhole = Math.floor(secs),
        secsFrac = secs - secsWhole,
        ntpSecs = secsWhole + osc.SECS_70YRS,
        ntpFracs = Math.round(osc.TWO_32 * secsFrac);

    return [ntpSecs, ntpFracs];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * values. The first represents the number of seconds since January 1, 1900; the second, fractions of a second.
     * &#x22;Native&#x22; JavaScript timestamps are specified as a Number representing milliseconds since January 1, 1970.
     *
     * @param {Object} timeTag time tag object containing either a native JS timestamp (in ms) or a NTP timestamp pair
     * @return {Uint8Array} raw bytes for the written time tag
     */
    osc.writeTimeTag = function (timeTag) {
var raw = timeTag.raw ? timeTag.raw : osc.<span class="apidocCodeKeywordSpan">jsToNTPTime</span>(timeTag.native),
    arr = new Uint8Array(8), // Two Unit32s.
    dv = new DataView(arr.buffer);

osc.writeInt32(raw[0], dv, 0);
osc.writeInt32(raw[1], dv, 4);

return arr;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.nativeBuffer" id="apidoc.element.osc.nativeBuffer">
        function <span class="apidocSignatureSpan">osc.</span>nativeBuffer
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nativeBuffer = function (obj) {
    if (osc.isBufferEnv) {
        return osc.isBuffer(obj) ? obj :
            new Buffer(obj.buffer ? obj : new Uint8Array(obj));
    }

    return osc.isTypedArrayView(obj) ? obj : new Uint8Array(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var p = osc.Port.prototype = Object.create(EventEmitter.prototype);
p.constructor = osc.Port;

p.send = function (oscPacket) {
    var args = Array.prototype.slice.call(arguments),
        encoded = this.encodeOSC(oscPacket),
        buf = osc.<span class="apidocCodeKeywordSpan">nativeBuffer</span>(encoded);

    args[0] = buf;
    this.sendRaw.apply(this, args);
};

p.encodeOSC = function (packet) {
    // TODO gh-39: This is unsafe; we should only access the underlying
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.ntpToJSTime" id="apidoc.element.osc.ntpToJSTime">
        function <span class="apidocSignatureSpan">osc.</span>ntpToJSTime
        <span class="apidocSignatureSpan">(secs1900, frac)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ntpToJSTime = function (secs1900, frac) {
    var secs1970 = secs1900 - osc.SECS_70YRS,
        decimals = frac / osc.TWO_32,
        msTime = (secs1970 + decimals) * 1000;

    return msTime;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {DataView} dv the DataView instance to read from
 * @param {Object} offsetState an offset state object containing the current index into dv
 * @param {Object} a time tag object containing both the raw NTP as well as the converted native (i.e. JS/UNIX) time
 */
osc.readTimeTag = function (dv, offsetState) {
    var secs1900 = osc.readPrimitive(dv, &#x22;getUint32&#x22;, 4, offsetState),
        frac = osc.readPrimitive(dv, &#x22;getUint32&#x22;, 4, offsetState),
        native = (secs1900 === 0 &#x26;&#x26; frac === 1) ? Date.now() : osc.<span class="apidocCodeKeywordSpan">ntpToJSTime</span
>(secs1900, frac);

    return {
        raw: [secs1900, frac],
        native: native
    };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readArgument" id="apidoc.element.osc.readArgument">
        function <span class="apidocSignatureSpan">osc.</span>readArgument
        <span class="apidocSignatureSpan">(argType, typeTagString, dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArgument = function (argType, typeTagString, dv, options, offsetState) {
    var typeSpec = osc.argumentTypes[argType];
    if (!typeSpec) {
        throw new Error(&#x22;&#x27;&#x22; + argType + &#x22;&#x27; is not a valid OSC type tag. Type tag string was: &#x22; + typeTagString);
    }

    var argReader = typeSpec.reader,
        arg = osc[argReader](dv, offsetState);

    if (options.metadata) {
        arg = {
            type: argType,
            value: arg
        };
    }

    return arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                &#x22;without a matching close array tag (&#x27;[]&#x27;). Type tag was: &#x22; + typeTagString);
        }

        var typesInArray = fromArrayOpen.slice(0, endArrayIdx);
        arg = osc.readArgumentsIntoArray([], typesInArray, typeTagString, dv, options, offsetState);
        i += endArrayIdx + 2;
    } else {
        arg = osc.<span class="apidocCodeKeywordSpan">readArgument</span>(argType, typeTagString, dv, options, offsetState);
        i++;
    }

    arr.push(arg);
}

return arr;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readArguments" id="apidoc.element.osc.readArguments">
        function <span class="apidocSignatureSpan">osc.</span>readArguments
        <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArguments = function (dv, options, offsetState) {
    var typeTagString = osc.readString(dv, offsetState);
    if (typeTagString.indexOf(&#x22;,&#x22;) !== 0) {
        // Despite what the OSC 1.0 spec says,
        // it just doesn&#x27;t make sense to handle messages without type tags.
        // scsynth appears to read such messages as if they have a single
        // Uint8 argument. sclang throws an error if the type tag is omitted.
        throw new Error(&#x22;A malformed type tag string was found while reading &#x22; +
            &#x22;the arguments of an OSC message. String was: &#x22; +
            typeTagString, &#x22; at offset: &#x22; + offsetState.idx);
    }

    var argTypes = typeTagString.substring(1).split(&#x22;&#x22;),
        args = [];

    osc.readArgumentsIntoArray(args, argTypes, typeTagString, dv, options, offsetState);

    return args;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Unsupported, non-API function.
osc.readMessageContents = function (address, dv, options, offsetState) {
    if (address.indexOf(&#x22;/&#x22;) !== 0) {
        throw new Error(&#x22;A malformed OSC address was found while reading &#x22; +
            &#x22;an OSC message. String was: &#x22; + address);
    }

    var args = osc.<span class="apidocCodeKeywordSpan">readArguments</span>(dv, options, offsetState);

    return {
        address: address,
        args: args.length === 1 &#x26;&#x26; options.unpackSingleArgs ? args[0] : args
    };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readArgumentsIntoArray" id="apidoc.element.osc.readArgumentsIntoArray">
        function <span class="apidocSignatureSpan">osc.</span>readArgumentsIntoArray
        <span class="apidocSignatureSpan">(arr, argTypes, typeTagString, dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArgumentsIntoArray = function (arr, argTypes, typeTagString, dv, options, offsetState) {
    var i = 0;

    while (i &#x3c; argTypes.length) {
        var argType = argTypes[i],
            arg;

        if (argType === &#x22;[&#x22;) {
            var fromArrayOpen = argTypes.slice(i + 1),
                endArrayIdx = fromArrayOpen.indexOf(&#x22;]&#x22;);

            if (endArrayIdx &#x3c; 0) {
                throw new Error(&#x22;Invalid argument type tag: an open array type tag (&#x27;[&#x27;) was found &#x22; +
                    &#x22;without a matching close array tag (&#x27;[]&#x27;). Type tag was: &#x22; + typeTagString);
            }

            var typesInArray = fromArrayOpen.slice(0, endArrayIdx);
            arg = osc.readArgumentsIntoArray([], typesInArray, typeTagString, dv, options, offsetState);
            i += endArrayIdx + 2;
        } else {
            arg = osc.readArgument(argType, typeTagString, dv, options, offsetState);
            i++;
        }

        arr.push(arg);
    }

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            &#x22;the arguments of an OSC message. String was: &#x22; +
            typeTagString, &#x22; at offset: &#x22; + offsetState.idx);
    }

    var argTypes = typeTagString.substring(1).split(&#x22;&#x22;),
        args = [];

    osc.<span class="apidocCodeKeywordSpan">readArgumentsIntoArray</span>(args, argTypes, typeTagString, dv, options, offsetState
);

    return args;
};

// Unsupported, non-API function.
osc.readArgument = function (argType, typeTagString, dv, options, offsetState) {
    var typeSpec = osc.argumentTypes[argType];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readBlob" id="apidoc.element.osc.readBlob">
        function <span class="apidocSignatureSpan">osc.</span>readBlob
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBlob = function (dv, offsetState) {
    var len = osc.readInt32(dv, offsetState),
        paddedLen = (len + 3) &#x26; ~0x03,
        blob = new Uint8Array(dv.buffer, offsetState.idx, len);

    offsetState.idx += paddedLen;

    return blob;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readBundle" id="apidoc.element.osc.readBundle">
        function <span class="apidocSignatureSpan">osc.</span>readBundle
        <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBundle = function (dv, options, offsetState) {
    return osc.readPacket(dv, options, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readBundleContents" id="apidoc.element.osc.readBundleContents">
        function <span class="apidocSignatureSpan">osc.</span>readBundleContents
        <span class="apidocSignatureSpan">(dv, options, offsetState, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBundleContents = function (dv, options, offsetState, len) {
    var timeTag = osc.readTimeTag(dv, offsetState),
        packets = [];

    while (offsetState.idx &#x3c; len) {
        var packetSize = osc.readInt32(dv, offsetState),
            packetLen = offsetState.idx + packetSize,
            packet = osc.readPacket(dv, options, offsetState, packetLen);

        packets.push(packet);
    }

    return {
        timeTag: timeTag,
        packets: packets
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        idx: 0
    };

    var header = osc.readString(dv, offsetState),
        firstChar = header[0];

    if (firstChar === &#x22;#&#x22;) {
        return osc.<span class="apidocCodeKeywordSpan">readBundleContents</span>(dv, options, offsetState, len);
    } else if (firstChar === &#x22;/&#x22;) {
        return osc.readMessageContents(header, dv, options, offsetState);
    }

    throw new Error(&#x22;The header of an OSC packet didn&#x27;t contain an OSC address or a #bundle string.&#x22; +
        &#x22; Header was: &#x22; + header);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readChar32" id="apidoc.element.osc.readChar32">
        function <span class="apidocSignatureSpan">osc.</span>readChar32
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readChar32 = function (dv, offsetState) {
    var charCode = osc.readPrimitive(dv, &#x22;getUint32&#x22;, 4, offsetState);
    return String.fromCharCode(charCode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readColor" id="apidoc.element.osc.readColor">
        function <span class="apidocSignatureSpan">osc.</span>readColor
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readColor = function (dv, offsetState) {
    var bytes = new Uint8Array(dv.buffer, offsetState.idx, 4),
        alpha = bytes[3] / 255;

    offsetState.idx += 4;

    return {
        r: bytes[0],
        g: bytes[1],
        b: bytes[2],
        a: alpha
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readFalse" id="apidoc.element.osc.readFalse">
        function <span class="apidocSignatureSpan">osc.</span>readFalse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFalse = function () {
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readFloat32" id="apidoc.element.osc.readFloat32">
        function <span class="apidocSignatureSpan">osc.</span>readFloat32
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFloat32 = function (dv, offsetState) {
    return osc.readPrimitive(dv, &#x22;getFloat32&#x22;, 4, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readFloat64" id="apidoc.element.osc.readFloat64">
        function <span class="apidocSignatureSpan">osc.</span>readFloat64
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFloat64 = function (dv, offsetState) {
    return osc.readPrimitive(dv, &#x22;getFloat64&#x22;, 8, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readImpulse" id="apidoc.element.osc.readImpulse">
        function <span class="apidocSignatureSpan">osc.</span>readImpulse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readImpulse = function () {
    return 1.0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readInt32" id="apidoc.element.osc.readInt32">
        function <span class="apidocSignatureSpan">osc.</span>readInt32
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt32 = function (dv, offsetState) {
    return osc.readPrimitive(dv, &#x22;getInt32&#x22;, 4, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Reads an OSC blob (&#x22;b&#x22;) (i.e. a Uint8Array).
 *
 * @param {DataView} dv a DataView instance to read from
 * @param {Object} offsetState an offsetState object used to store the current offset index into dv
 * @return {Uint8Array} the data that was read
 */
osc.readBlob = function (dv, offsetState) {
    var len = osc.<span class="apidocCodeKeywordSpan">readInt32</span>(dv, offsetState),
        paddedLen = (len + 3) &#x26; ~0x03,
        blob = new Uint8Array(dv.buffer, offsetState.idx, len);

    offsetState.idx += paddedLen;

    return blob;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readInt64" id="apidoc.element.osc.readInt64">
        function <span class="apidocSignatureSpan">osc.</span>readInt64
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt64 = function (dv, offsetState) {
    var high = osc.readPrimitive(dv, &#x22;getInt32&#x22;, 4, offsetState),
        low = osc.readPrimitive(dv, &#x22;getInt32&#x22;, 4, offsetState);

    if (Long) {
        return new Long(low, high);
    } else {
        return {
            high: high,
            low: low,
            unsigned: false
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readMIDIBytes" id="apidoc.element.osc.readMIDIBytes">
        function <span class="apidocSignatureSpan">osc.</span>readMIDIBytes
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readMIDIBytes = function (dv, offsetState) {
    var midi = new Uint8Array(dv.buffer, offsetState.idx, 4);
    offsetState.idx += 4;

    return midi;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readMessage" id="apidoc.element.osc.readMessage">
        function <span class="apidocSignatureSpan">osc.</span>readMessage
        <span class="apidocSignatureSpan">(data, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readMessage = function (data, options, offsetState) {
    options = options || osc.defaults;

    var dv = osc.dataView(data, data.byteOffset, data.byteLength);
    offsetState = offsetState || {
        idx: 0
    };

    var address = osc.readString(dv, offsetState);
    return osc.readMessageContents(address, dv, options, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readMessageContents" id="apidoc.element.osc.readMessageContents">
        function <span class="apidocSignatureSpan">osc.</span>readMessageContents
        <span class="apidocSignatureSpan">(address, dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readMessageContents = function (address, dv, options, offsetState) {
    if (address.indexOf(&#x22;/&#x22;) !== 0) {
        throw new Error(&#x22;A malformed OSC address was found while reading &#x22; +
            &#x22;an OSC message. String was: &#x22; + address);
    }

    var args = osc.readArguments(dv, options, offsetState);

    return {
        address: address,
        args: args.length === 1 &#x26;&#x26; options.unpackSingleArgs ? args[0] : args
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    var dv = osc.dataView(data, data.byteOffset, data.byteLength);
    offsetState = offsetState || {
        idx: 0
    };

    var address = osc.readString(dv, offsetState);
    return osc.<span class="apidocCodeKeywordSpan">readMessageContents</span>(address, dv, options, offsetState);
};

// Unsupported, non-API function.
osc.readMessageContents = function (address, dv, options, offsetState) {
    if (address.indexOf(&#x22;/&#x22;) !== 0) {
        throw new Error(&#x22;A malformed OSC address was found while reading &#x22; +
            &#x22;an OSC message. String was: &#x22; + address);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readNull" id="apidoc.element.osc.readNull">
        function <span class="apidocSignatureSpan">osc.</span>readNull
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readNull = function () {
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readPacket" id="apidoc.element.osc.readPacket">
        function <span class="apidocSignatureSpan">osc.</span>readPacket
        <span class="apidocSignatureSpan">(data, options, offsetState, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readPacket = function (data, options, offsetState, len) {
    var dv = osc.dataView(data, data.byteOffset, data.byteLength);

    len = len === undefined ? dv.byteLength : len;
    offsetState = offsetState || {
        idx: 0
    };

    var header = osc.readString(dv, offsetState),
        firstChar = header[0];

    if (firstChar === &#x22;#&#x22;) {
        return osc.readBundleContents(dv, options, offsetState, len);
    } else if (firstChar === &#x22;/&#x22;) {
        return osc.readMessageContents(header, dv, options, offsetState);
    }

    throw new Error(&#x22;The header of an OSC packet didn&#x27;t contain an OSC address or a #bundle string.&#x22; +
        &#x22; Header was: &#x22; + header);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
they should be caught and handled using
&#x3c;code&#x3e;try&#x3c;/code&#x3e;/&#x3c;code&#x3e;catch&#x3c;/code&#x3e;.

```javascript
var msg;

try {
    msg = osc.<span class="apidocCodeKeywordSpan">readPacket</span>(rawPacket);
} catch (error) {
    console.log(&#x22;An error occurred: &#x22;, error.message);
}
```

The osc.js Low-Level API
------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readPrimitive" id="apidoc.element.osc.readPrimitive">
        function <span class="apidocSignatureSpan">osc.</span>readPrimitive
        <span class="apidocSignatureSpan">(dv, readerName, numBytes, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readPrimitive = function (dv, readerName, numBytes, offsetState) {
    var val = dv[readerName](offsetState.idx, false);
    offsetState.idx += numBytes;

    return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Reads an OSC int32 (&#x22;i&#x22;) value.
 *
 * @param {DataView} dv a DataView containing the raw bytes
 * @param {Object} offsetState an offsetState object used to store the current offset index into dv
 * @return {Number} the number that was read
 */
osc.readInt32 = function (dv, offsetState) {
    return osc.<span class="apidocCodeKeywordSpan">readPrimitive</span>(dv, &#x22;getInt32&#x22;, 4, offsetState);
};

/**
 * Writes an OSC int32 (&#x22;i&#x22;) value.
 *
 * @param {Number} val the number to write
 * @param {DataView} [dv] a DataView instance to write the number into
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readString" id="apidoc.element.osc.readString">
        function <span class="apidocSignatureSpan">osc.</span>readString
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readString = function (dv, offsetState) {
    var charCodes = [],
        idx = offsetState.idx;

    for (; idx &#x3c; dv.byteLength; idx++) {
        var charCode = dv.getUint8(idx);
        if (charCode !== 0) {
            charCodes.push(charCode);
        } else {
            idx++;
            break;
        }
    }

    // Round to the nearest 4-byte block.
    idx = (idx + 3) &#x26; ~0x03;
    offsetState.idx = idx;

    return String.fromCharCode.apply(null, charCodes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {DataView} dv a DataView instance to read from
 * @param {Object} offsetState the offsetState object that stores the current offset into dv
 * @param {Oobject} [options] read options
 * @return {Array} an array of the OSC arguments that were read
 */
osc.readArguments = function (dv, options, offsetState) {
    var typeTagString = osc.<span class="apidocCodeKeywordSpan">readString</span>(dv, offsetState);
    if (typeTagString.indexOf(&#x22;,&#x22;) !== 0) {
        // Despite what the OSC 1.0 spec says,
        // it just doesn&#x27;t make sense to handle messages without type tags.
        // scsynth appears to read such messages as if they have a single
        // Uint8 argument. sclang throws an error if the type tag is omitted.
        throw new Error(&#x22;A malformed type tag string was found while reading &#x22; +
            &#x22;the arguments of an OSC message. String was: &#x22; +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readTimeTag" id="apidoc.element.osc.readTimeTag">
        function <span class="apidocSignatureSpan">osc.</span>readTimeTag
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readTimeTag = function (dv, offsetState) {
    var secs1900 = osc.readPrimitive(dv, &#x22;getUint32&#x22;, 4, offsetState),
        frac = osc.readPrimitive(dv, &#x22;getUint32&#x22;, 4, offsetState),
        native = (secs1900 === 0 &#x26;&#x26; frac === 1) ? Date.now() : osc.ntpToJSTime(secs1900, frac);

    return {
        raw: [secs1900, frac],
        native: native
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    osc.isValidBundle = function (bundle) {
return bundle.timeTag !== undefined &#x26;&#x26; bundle.packets !== undefined;
    };

    // Unsupported, non-API function.
    osc.readBundleContents = function (dv, options, offsetState, len) {
var timeTag = osc.<span class="apidocCodeKeywordSpan">readTimeTag</span>(dv, offsetState),
    packets = [];

while (offsetState.idx &#x3c; len) {
    var packetSize = osc.readInt32(dv, offsetState),
        packetLen = offsetState.idx + packetSize,
        packet = osc.readPacket(dv, options, offsetState, packetLen);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.readTrue" id="apidoc.element.osc.readTrue">
        function <span class="apidocSignatureSpan">osc.</span>readTrue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readTrue = function () {
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.relay" id="apidoc.element.osc.relay">
        function <span class="apidocSignatureSpan">osc.</span>relay
        <span class="apidocSignatureSpan">(from, to, eventName, sendFnName, transformFn, sendArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">relay = function (from, to, eventName, sendFnName, transformFn, sendArgs) {
    eventName = eventName || &#x22;message&#x22;;
    sendFnName = sendFnName || &#x22;send&#x22;;
    transformFn = transformFn || function () {};
    sendArgs = sendArgs ? [null].concat(sendArgs) : [];

    var listener = function (data) {
        sendArgs[0] = data;
        data = transformFn(data);
        to[sendFnName].apply(to, sendArgs);
    };

    from.on(eventName, listener);

    return {
        eventName: eventName,
        listener: listener
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// Unsupported, non-API function.
osc.relayPorts = function (from, to, o) {
    var eventName = o.raw ? &#x22;raw&#x22; : &#x22;osc&#x22;,
        sendFnName = o.raw ? &#x22;sendRaw&#x22; : &#x22;send&#x22;;

    return osc.<span class="apidocCodeKeywordSpan">relay</span>(from, to, eventName, sendFnName, o.transform);
};

// Unsupported, non-API function.
osc.stopRelaying = function (from, relaySpec) {
    from.removeListener(relaySpec.eventName, relaySpec.listener);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.relayPorts" id="apidoc.element.osc.relayPorts">
        function <span class="apidocSignatureSpan">osc.</span>relayPorts
        <span class="apidocSignatureSpan">(from, to, o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">relayPorts = function (from, to, o) {
    var eventName = o.raw ? &#x22;raw&#x22; : &#x22;osc&#x22;,
        sendFnName = o.raw ? &#x22;sendRaw&#x22; : &#x22;send&#x22;;

    return osc.relay(from, to, eventName, sendFnName, o.transform);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };

    p.listen = function () {
if (this.port1Spec &#x26;&#x26; this.port2Spec) {
    this.close();
}

this.port1Spec = osc.<span class="apidocCodeKeywordSpan">relayPorts</span>(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
// Users are still responsible for closing the underlying ports
// if necessary.
var closeListener = this.close.bind(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.stopRelaying" id="apidoc.element.osc.stopRelaying">
        function <span class="apidocSignatureSpan">osc.</span>stopRelaying
        <span class="apidocSignatureSpan">(from, relaySpec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopRelaying = function (from, relaySpec) {
    from.removeListener(relaySpec.eventName, relaySpec.listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // if necessary.
    var closeListener = this.close.bind(this);
    this.port1.on(&#x22;close&#x22;, closeListener);
    this.port2.on(&#x22;close&#x22;, closeListener);
};

p.close = function () {
    osc.<span class="apidocCodeKeywordSpan">stopRelaying</span>(this.port1, this.port1Spec);
    osc.stopRelaying(this.port2, this.port2Spec);
    this.emit(&#x22;close&#x22;, this.port1, this.port2);
};


// If we&#x27;re in a require-compatible environment, export ourselves.
if (typeof module !== &#x22;undefined&#x22; &#x26;&#x26; module.exports) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.timeTag" id="apidoc.element.osc.timeTag">
        function <span class="apidocSignatureSpan">osc.</span>timeTag
        <span class="apidocSignatureSpan">(secs, now)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeTag = function (secs, now) {
    secs = secs || 0;
    now = now || Date.now();

    var nowSecs = now / 1000,
        nowWhole = Math.floor(nowSecs),
        nowFracs = nowSecs - nowWhole,
        secsWhole = Math.floor(secs),
        secsFracs = secs - secsWhole,
        fracs = nowFracs + secsFracs;

    if (fracs &#x3e; 1) {
        var fracsWhole = Math.floor(fracs),
            fracsFracs = fracs - fracsWhole;

        secsWhole += fracsWhole;
        fracs = fracsFracs;
    }

    var ntpSecs = nowWhole + secsWhole + osc.SECS_70YRS,
        ntpFracs = Math.round(osc.TWO_32 * fracs);

    return {
        raw: [ntpSecs, ntpFracs]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

##### Sending OSC bundles:
```javascript
oscPort.on(&#x22;ready&#x22;, function () {
oscPort.send({
    timeTag: osc.<span class="apidocCodeKeywordSpan">timeTag</span>(60), // Schedules this bundle 60 seconds from now.
    packets: [
        {
            address: &#x22;/carrier/frequency&#x22;,
            args: 440
        },
        {
            address: &#x22;/carrier/amplitude&#x22;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeArgument" id="apidoc.element.osc.writeArgument">
        function <span class="apidocSignatureSpan">osc.</span>writeArgument
        <span class="apidocSignatureSpan">(arg, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArgument = function (arg, dataCollection) {
    if (osc.isArray(arg)) {
        return osc.writeArrayArguments(arg, dataCollection);
    }

    var type = arg.type,
        writer = osc.argumentTypes[type].writer;

    if (writer) {
        var data = osc[writer](arg.value);
        osc.addDataPart(data, dataCollection);
    }

    return arg.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

osc.writeArrayArguments = function (args, dataCollection) {
    var typeTag = &#x22;[&#x22;;

    for (var i = 0; i &#x3c; args.length; i++) {
        var arg = args[i];
        typeTag += osc.<span class="apidocCodeKeywordSpan">writeArgument</span>(arg, dataCollection);
    }

    typeTag += &#x22;]&#x22;;

    return typeTag;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeArguments" id="apidoc.element.osc.writeArguments">
        function <span class="apidocSignatureSpan">osc.</span>writeArguments
        <span class="apidocSignatureSpan">(args, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArguments = function (args, options) {
    var argCollection = osc.collectArguments(args, options);
    return osc.joinParts(argCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeArrayArguments" id="apidoc.element.osc.writeArrayArguments">
        function <span class="apidocSignatureSpan">osc.</span>writeArrayArguments
        <span class="apidocSignatureSpan">(args, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArrayArguments = function (args, dataCollection) {
    var typeTag = &#x22;[&#x22;;

    for (var i = 0; i &#x3c; args.length; i++) {
        var arg = args[i];
        typeTag += osc.writeArgument(arg, dataCollection);
    }

    typeTag += &#x22;]&#x22;;

    return typeTag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
typeTag += &#x22;]&#x22;;

return typeTag;
    };

    osc.writeArgument = function (arg, dataCollection) {
if (osc.isArray(arg)) {
    return osc.<span class="apidocCodeKeywordSpan">writeArrayArguments</span>(arg, dataCollection);
}

var type = arg.type,
    writer = osc.argumentTypes[type].writer;

if (writer) {
    var data = osc[writer](arg.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeBlob" id="apidoc.element.osc.writeBlob">
        function <span class="apidocSignatureSpan">osc.</span>writeBlob
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeBlob = function (data) {
    data = osc.byteArray(data);

    var len = data.byteLength,
        paddedLen = (len + 3) &#x26; ~0x03,
        offset = 4, // Extra 4 bytes is for the size.
        blobLen = paddedLen + offset,
        arr = new Uint8Array(blobLen),
        dv = new DataView(arr.buffer);

    // Write the size.
    osc.writeInt32(len, dv);

    // Since we&#x27;re writing to a real ArrayBuffer,
    // we don&#x27;t need to pad the remaining bytes.
    arr.set(data, offset);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeBundle" id="apidoc.element.osc.writeBundle">
        function <span class="apidocSignatureSpan">osc.</span>writeBundle
        <span class="apidocSignatureSpan">(bundle, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeBundle = function (bundle, options) {
    if (!osc.isValidBundle(bundle)) {
        throw new Error(&#x22;An OSC bundle must contain &#x27;timeTag&#x27; and &#x27;packets&#x27; properties. &#x22; +
            &#x22;Bundle was: &#x22; + JSON.stringify(bundle, null, 2));
    }

    options = options || osc.defaults;
    var bundleCollection = osc.collectBundlePackets(bundle, options);

    return osc.joinParts(bundleCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} [options] write options
 * @return {Uint8Array} an array of bytes containing the message
 */
osc.writePacket = function (packet, options) {
    if (osc.isValidMessage(packet)) {
        return osc.writeMessage(packet, options);
    } else if (osc.isValidBundle(packet)) {
        return osc.<span class="apidocCodeKeywordSpan">writeBundle</span>(packet, options);
    } else {
        throw new Error(&#x22;The specified packet was not recognized as a valid OSC message or bundle.&#x22; +
            &#x22; Packet was: &#x22; + JSON.stringify(packet, null, 2));
    }
};

// Unsupported, non-API.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeChar32" id="apidoc.element.osc.writeChar32">
        function <span class="apidocSignatureSpan">osc.</span>writeChar32
        <span class="apidocSignatureSpan">(str, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeChar32 = function (str, dv, offset) {
    var charCode = str.charCodeAt(0);
    if (charCode === undefined || charCode &#x3c; -1) {
        return undefined;
    }

    return osc.writePrimitive(charCode, dv, &#x22;setUint32&#x22;, 4, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeColor" id="apidoc.element.osc.writeColor">
        function <span class="apidocSignatureSpan">osc.</span>writeColor
        <span class="apidocSignatureSpan">(color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeColor = function (color) {
    var alpha = Math.round(color.a * 255),
        arr = new Uint8Array([color.r, color.g, color.b, alpha]);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeFloat32" id="apidoc.element.osc.writeFloat32">
        function <span class="apidocSignatureSpan">osc.</span>writeFloat32
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFloat32 = function (val, dv, offset) {
    return osc.writePrimitive(val, dv, &#x22;setFloat32&#x22;, 4, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeFloat64" id="apidoc.element.osc.writeFloat64">
        function <span class="apidocSignatureSpan">osc.</span>writeFloat64
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFloat64 = function (val, dv, offset) {
    return osc.writePrimitive(val, dv, &#x22;setFloat64&#x22;, 8, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeInt32" id="apidoc.element.osc.writeInt32">
        function <span class="apidocSignatureSpan">osc.</span>writeInt32
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt32 = function (val, dv, offset) {
    return osc.writePrimitive(val, dv, &#x22;setInt32&#x22;, 4, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        paddedLen = (len + 3) &#x26; ~0x03,
        offset = 4, // Extra 4 bytes is for the size.
        blobLen = paddedLen + offset,
        arr = new Uint8Array(blobLen),
        dv = new DataView(arr.buffer);

    // Write the size.
    osc.<span class="apidocCodeKeywordSpan">writeInt32</span>(len, dv);

    // Since we&#x27;re writing to a real ArrayBuffer,
    // we don&#x27;t need to pad the remaining bytes.
    arr.set(data, offset);

    return arr;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeInt64" id="apidoc.element.osc.writeInt64">
        function <span class="apidocSignatureSpan">osc.</span>writeInt64
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt64 = function (val, dv, offset) {
    var arr = new Uint8Array(8);
    arr.set(osc.writePrimitive(val.high, dv, &#x22;setInt32&#x22;, 4, offset), 0);
    arr.set(osc.writePrimitive(val.low,  dv, &#x22;setInt32&#x22;, 4, offset + 4), 4);
    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeMIDIBytes" id="apidoc.element.osc.writeMIDIBytes">
        function <span class="apidocSignatureSpan">osc.</span>writeMIDIBytes
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeMIDIBytes = function (bytes) {
    bytes = osc.byteArray(bytes);

    var arr = new Uint8Array(4);
    arr.set(bytes);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeMessage" id="apidoc.element.osc.writeMessage">
        function <span class="apidocSignatureSpan">osc.</span>writeMessage
        <span class="apidocSignatureSpan">(msg, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeMessage = function (msg, options) {
    options = options || osc.defaults;

    if (!osc.isValidMessage(msg)) {
        throw new Error(&#x22;An OSC message must contain a valid address. Message was: &#x22; +
            JSON.stringify(msg, null, 2));
    }

    var msgCollection = osc.collectMessageParts(msg, options);
    return osc.joinParts(msgCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Object} a bundle or message object
 * @param {Object} [options] write options
 * @return {Uint8Array} an array of bytes containing the message
 */
osc.writePacket = function (packet, options) {
    if (osc.isValidMessage(packet)) {
        return osc.<span class="apidocCodeKeywordSpan">writeMessage</span>(packet, options);
    } else if (osc.isValidBundle(packet)) {
        return osc.writeBundle(packet, options);
    } else {
        throw new Error(&#x22;The specified packet was not recognized as a valid OSC message or bundle.&#x22; +
            &#x22; Packet was: &#x22; + JSON.stringify(packet, null, 2));
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writePacket" id="apidoc.element.osc.writePacket">
        function <span class="apidocSignatureSpan">osc.</span>writePacket
        <span class="apidocSignatureSpan">(packet, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writePacket = function (packet, options) {
    if (osc.isValidMessage(packet)) {
        return osc.writeMessage(packet, options);
    } else if (osc.isValidBundle(packet)) {
        return osc.writeBundle(packet, options);
    } else {
        throw new Error(&#x22;The specified packet was not recognized as a valid OSC message or bundle.&#x22; +
            &#x22; Packet was: &#x22; + JSON.stringify(packet, null, 2));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &#x3c;code&#x3e;options&#x3c;/code&#x3e;: (optional) An options object, described below; &#x3c;br /&#x3e;
        &#x3c;code&#x3e;offsetState&#x3c;/code&#x3e;: (optional) an offset state object containing an &#x3c;code&#x3e;idx&#x3c;/
code&#x3e; property that specifies the offset index into &#x3c;code&#x3e;data&#x3c;/code&#x3e;; &#x3c;br /&#x3e;
        &#x3c;code&#x3e;length&#x3c;/code&#x3e; the length (in bytes) to read from &#x3c;code&#x3e;data&#x3c;/code&#x3e;
    &#x3c;/td&#x3e;
    &#x3c;td&#x3e;An osc.js message or bundle object&#x3c;/td&#x3e;
&#x3c;/tr&#x3e;
&#x3c;tr&#x3e;
    &#x3c;td&#x3e;&#x3c;code&#x3e;osc.<span class="apidocCodeKeywordSpan">writePacket</span>()&#x3c;/code&#x3e;&#x3c;/td&#x3e;
    &#x3c;td&#x3e;Writes an OSC message or bundle object to a binary array.&#x3c;/td&#x3e;
    &#x3c;td&#x3e;
        &#x3c;code&#x3e;packate&#x3c;/code&#x3e;: An osc.js message or bundle object;&#x3c;br /&#x3e;
        &#x3c;code&#x3e;options&#x3c;/code&#x3e;: (optional) An options object, described below&#x3c;br /&#x3e;
    &#x3c;/td&#x3e;
    &#x3c;td&#x3e;A &#x3c;code&#x3e;Uint8Array&#x3c;/code&#x3e;&#x3c;/td&#x3e;
&#x3c;/tr&#x3e;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writePrimitive" id="apidoc.element.osc.writePrimitive">
        function <span class="apidocSignatureSpan">osc.</span>writePrimitive
        <span class="apidocSignatureSpan">(val, dv, writerName, numBytes, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writePrimitive = function (val, dv, writerName, numBytes, offset) {
    offset = offset === undefined ? 0 : offset;

    var arr;
    if (!dv) {
        arr = new Uint8Array(numBytes);
        dv = new DataView(arr.buffer);
    } else {
        arr = new Uint8Array(dv.buffer);
    }

    dv[writerName](offset, val, false);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Writes an OSC int32 (&#x22;i&#x22;) value.
 *
 * @param {Number} val the number to write
 * @param {DataView} [dv] a DataView instance to write the number into
 * @param {Number} [offset] an offset into dv
 */
osc.writeInt32 = function (val, dv, offset) {
    return osc.<span class="apidocCodeKeywordSpan">writePrimitive</span>(val, dv, &#x22;setInt32&#x22;, 4, offset);
};

/**
 * Reads an OSC int64 (&#x22;h&#x22;) value.
 *
 * @param {DataView} dv a DataView containing the raw bytes
 * @param {Object} offsetState an offsetState object used to store the current offset index into dv
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeString" id="apidoc.element.osc.writeString">
        function <span class="apidocSignatureSpan">osc.</span>writeString
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeString = function (str) {
    var terminated = str + &#x22;\u0000&#x22;,
        len = terminated.length,
        paddedLen = (len + 3) &#x26; ~0x03,
        arr = new Uint8Array(paddedLen);

    for (var i = 0; i &#x3c; terminated.length; i++) {
        var charCode = terminated.charCodeAt(i);
        arr[i] = charCode;
    }

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        currPartIdx = dataCollection.parts.length;

    for (var i = 0; i &#x3c; args.length; i++) {
        var arg = args[i];
        typeTagString += osc.writeArgument(arg, dataCollection);
    }

    var typeData = osc.<span class="apidocCodeKeywordSpan">writeString</span>(typeTagString);
    dataCollection.byteLength += typeData.byteLength;
    dataCollection.parts.splice(currPartIdx, 0, typeData);

    return dataCollection;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.writeTimeTag" id="apidoc.element.osc.writeTimeTag">
        function <span class="apidocSignatureSpan">osc.</span>writeTimeTag
        <span class="apidocSignatureSpan">(timeTag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeTimeTag = function (timeTag) {
    var raw = timeTag.raw ? timeTag.raw : osc.jsToNTPTime(timeTag.native),
        arr = new Uint8Array(8), // Two Unit32s.
        dv = new DataView(arr.buffer);

    osc.writeInt32(raw[0], dv, 0);
    osc.writeInt32(raw[1], dv, 4);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    osc.collectBundlePackets = function (bundle, options, dataCollection) {
        dataCollection = dataCollection || {
byteLength: 0,
parts: []
        };

        osc.addDataPart(osc.writeString(&#x22;#bundle&#x22;), dataCollection);
        osc.addDataPart(osc.<span class="apidocCodeKeywordSpan">writeTimeTag</span>(bundle.timeTag), dataCollection);

        for (var i = 0; i &#x3c; bundle.packets.length; i++) {
var packet = bundle.packets[i],
    collector = packet.address ? osc.collectMessageParts : osc.collectBundlePackets,
    packetCollection = collector(packet, options);

dataCollection.byteLength += packetCollection.byteLength;
...</pre></li>
    </ul>


































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.Port" id="apidoc.module.osc.Port">module osc.Port</a></h1>


    <h2>
        <a href="#apidoc.element.osc.Port.Port" id="apidoc.element.osc.Port.Port">
        function <span class="apidocSignatureSpan">osc.</span>Port
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Port = function (options) {
    this.options = options || {};
    this.on(&#x22;data&#x22;, this.decodeOSC.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.Port.prototype" id="apidoc.module.osc.Port.prototype">module osc.Port.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.Port.prototype.constructor" id="apidoc.element.osc.Port.prototype.constructor">
        function <span class="apidocSignatureSpan">osc.Port.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (options) {
    this.options = options || {};
    this.on(&#x22;data&#x22;, this.decodeOSC.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Port.prototype.decodeOSC" id="apidoc.element.osc.Port.prototype.decodeOSC">
        function <span class="apidocSignatureSpan">osc.Port.prototype.</span>decodeOSC
        <span class="apidocSignatureSpan">(data, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeOSC = function (data, packetInfo) {
    data = osc.byteArray(data);
    this.emit(&#x22;raw&#x22;, data, packetInfo);

    try {
        var packet = osc.readPacket(data, this.options);
        this.emit(&#x22;osc&#x22;, packet, packetInfo);
        osc.firePacketEvents(this, packet, undefined, packetInfo);
    } catch (err) {
        this.emit(&#x22;error&#x22;, err);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Port.prototype.encodeOSC" id="apidoc.element.osc.Port.prototype.encodeOSC">
        function <span class="apidocSignatureSpan">osc.Port.prototype.</span>encodeOSC
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeOSC = function (packet) {
    // TODO gh-39: This is unsafe; we should only access the underlying
    // buffer within the range of its view.
    packet = packet.buffer ? packet.buffer : packet;
    var encoded;

    try {
        encoded = osc.writePacket(packet, this.options);
    } catch (err) {
        this.emit(&#x22;error&#x22;, err);
    }

    return encoded;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

var p = osc.Port.prototype = Object.create(EventEmitter.prototype);
p.constructor = osc.Port;

p.send = function (oscPacket) {
    var args = Array.prototype.slice.call(arguments),
        encoded = this.<span class="apidocCodeKeywordSpan">encodeOSC</span>(oscPacket),
        buf = osc.nativeBuffer(encoded);

    args[0] = buf;
    this.sendRaw.apply(this, args);
};

p.encodeOSC = function (packet) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Port.prototype.send" id="apidoc.element.osc.Port.prototype.send">
        function <span class="apidocSignatureSpan">osc.Port.prototype.</span>send
        <span class="apidocSignatureSpan">(oscPacket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (oscPacket) {
    var args = Array.prototype.slice.call(arguments),
        encoded = this.encodeOSC(oscPacket),
        buf = osc.nativeBuffer(encoded);

    args[0] = buf;
    this.sendRaw.apply(this, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

##### Sending OSC messages:
```javascript
// For most Ports, send() should only be called after the &#x22;ready&#x22; event fires.
oscPort.on(&#x22;ready&#x22;, function () {
    oscPort.<span class="apidocCodeKeywordSpan">send</span>({
        address: &#x22;/carrier/frequency&#x22;,
        args: 440
    });
});
```

##### Sending OSC bundles:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.Relay" id="apidoc.module.osc.Relay">module osc.Relay</a></h1>


    <h2>
        <a href="#apidoc.element.osc.Relay.Relay" id="apidoc.element.osc.Relay.Relay">
        function <span class="apidocSignatureSpan">osc.</span>Relay
        <span class="apidocSignatureSpan">(port1, port2, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Relay = function (port1, port2, options) {
    var o = this.options = options || {};
    o.raw = false;

    this.port1 = port1;
    this.port2 = port2;

    this.listen();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.Relay.prototype" id="apidoc.module.osc.Relay.prototype">module osc.Relay.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.Relay.prototype.close" id="apidoc.element.osc.Relay.prototype.close">
        function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    osc.stopRelaying(this.port1, this.port1Spec);
    osc.stopRelaying(this.port2, this.port2Spec);
    this.emit(&#x22;close&#x22;, this.port1, this.port2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &#x26;&#x26; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Relay.prototype.constructor" id="apidoc.element.osc.Relay.prototype.constructor">
        function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>constructor
        <span class="apidocSignatureSpan">(port1, port2, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (port1, port2, options) {
    var o = this.options = options || {};
    o.raw = false;

    this.port1 = port1;
    this.port2 = port2;

    this.listen();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Relay.prototype.listen" id="apidoc.element.osc.Relay.prototype.listen">
        function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
    if (this.port1Spec &#x26;&#x26; this.port2Spec) {
        this.close();
    }

    this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
    this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

    // Bind port close listeners to ensure that the relay
    // will stop forwarding messages if one of its ports close.
    // Users are still responsible for closing the underlying ports
    // if necessary.
    var closeListener = this.close.bind(this);
    this.port1.on(&#x22;close&#x22;, closeListener);
    this.port2.on(&#x22;close&#x22;, closeListener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var osc = require(&#x22;osc&#x22;),
    http = require(&#x22;http&#x22;),
    WebSocket = require(&#x22;ws&#x22;);

// Create an Express server app
// and serve up a directory of static files.
var app = require(&#x22;express&#x22;).express(),
    server = app.<span class="apidocCodeKeywordSpan">listen</span>(8081);

app.use(&#x22;/&#x22;, express.static(__dirname + &#x22;/static&#x22;));

// Listen for Web Socket requests.
var wss = new WebSocket.Server({
    server: server
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.Relay.prototype.open" id="apidoc.element.osc.Relay.prototype.open">
        function <span class="apidocSignatureSpan">osc.Relay.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
    this.port1.open();
    this.port2.open();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oscPort = new osc.WebSocketPort({
    url: &#x22;ws://localhost:8081&#x22; // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.<span class="apidocCodeKeywordSpan">open</span>();
```

##### Listening for incoming OSC messages:
```javascript
oscPort.on(&#x22;message&#x22;, function (oscMsg) {
    console.log(&#x22;An OSC message just arrived!&#x22;, oscMsg);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.SLIPPort" id="apidoc.module.osc.SLIPPort">module osc.SLIPPort</a></h1>


    <h2>
        <a href="#apidoc.element.osc.SLIPPort.SLIPPort" id="apidoc.element.osc.SLIPPort.SLIPPort">
        function <span class="apidocSignatureSpan">osc.</span>SLIPPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SLIPPort = function (options) {
    var that = this;
    var o = this.options = options || {};
    o.useSLIP = o.useSLIP === undefined ? true : o.useSLIP;

    this.decoder = new slip.Decoder({
        onMessage: this.decodeOSC.bind(this),
        onError: function (err) {
            that.emit(&#x22;error&#x22;, err);
        }
    });

    var decodeHandler = o.useSLIP ? this.decodeSLIPData : this.decodeOSC;
    this.on(&#x22;data&#x22;, decodeHandler.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.SLIPPort.prototype" id="apidoc.module.osc.SLIPPort.prototype">module osc.SLIPPort.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.SLIPPort.prototype.constructor" id="apidoc.element.osc.SLIPPort.prototype.constructor">
        function <span class="apidocSignatureSpan">osc.SLIPPort.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (options) {
    var that = this;
    var o = this.options = options || {};
    o.useSLIP = o.useSLIP === undefined ? true : o.useSLIP;

    this.decoder = new slip.Decoder({
        onMessage: this.decodeOSC.bind(this),
        onError: function (err) {
            that.emit(&#x22;error&#x22;, err);
        }
    });

    var decodeHandler = o.useSLIP ? this.decodeSLIPData : this.decodeOSC;
    this.on(&#x22;data&#x22;, decodeHandler.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SLIPPort.prototype.decodeSLIPData" id="apidoc.element.osc.SLIPPort.prototype.decodeSLIPData">
        function <span class="apidocSignatureSpan">osc.SLIPPort.prototype.</span>decodeSLIPData
        <span class="apidocSignatureSpan">(data, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeSLIPData = function (data, packetInfo) {
    // TODO: Get packetInfo through SLIP decoder.
    this.decoder.decode(data, packetInfo);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SLIPPort.prototype.encodeOSC" id="apidoc.element.osc.SLIPPort.prototype.encodeOSC">
        function <span class="apidocSignatureSpan">osc.SLIPPort.prototype.</span>encodeOSC
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeOSC = function (packet) {
    // TODO gh-39: This is unsafe; we should only access the underlying
    // buffer within the range of its view.
    packet = packet.buffer ? packet.buffer : packet;
    var framed;

    try {
        var encoded = osc.writePacket(packet, this.options);
        framed = slip.encode(encoded);
    } catch (err) {
        this.emit(&#x22;error&#x22;, err);
    }

    return framed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

var p = osc.Port.prototype = Object.create(EventEmitter.prototype);
p.constructor = osc.Port;

p.send = function (oscPacket) {
    var args = Array.prototype.slice.call(arguments),
        encoded = this.<span class="apidocCodeKeywordSpan">encodeOSC</span>(oscPacket),
        buf = osc.nativeBuffer(encoded);

    args[0] = buf;
    this.sendRaw.apply(this, args);
};

p.encodeOSC = function (packet) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.SerialPort" id="apidoc.module.osc.SerialPort">module osc.SerialPort</a></h1>


    <h2>
        <a href="#apidoc.element.osc.SerialPort.SerialPort" id="apidoc.element.osc.SerialPort.SerialPort">
        function <span class="apidocSignatureSpan">osc.</span>SerialPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SerialPort = function (options) {
    this.on(&#x22;open&#x22;, this.listen.bind(this));
    osc.SLIPPort.call(this, options);
    this.options.bitrate = this.options.bitrate || 9600;

    this.serialPort = options.serialPort;
    if (this.serialPort) {
        this.emit(&#x22;open&#x22;, this.serialPort);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
}
```

#### Connecting to the serial port and listening for OSC messages
```javascript
// Instantiate a new OSC Serial Port.
var serialPort = new osc.<span class="apidocCodeKeywordSpan">SerialPort</span>({
    devicePath: &#x22;/dev/cu.usbmodem22131&#x22;
});

// Listen for the message event and map the OSC message to the synth.
serialPort.on(&#x22;message&#x22;, function (oscMsg) {
    console.log(&#x22;An OSC message was received!&#x22;, oscMsg);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.SerialPort.prototype" id="apidoc.module.osc.SerialPort.prototype">module osc.SerialPort.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.close" id="apidoc.element.osc.SerialPort.prototype.close">
        function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    if (this.serialPort) {
        this.serialPort.close();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &#x26;&#x26; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.constructor" id="apidoc.element.osc.SerialPort.prototype.constructor">
        function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (options) {
    this.on(&#x22;open&#x22;, this.listen.bind(this));
    osc.SLIPPort.call(this, options);
    this.options.bitrate = this.options.bitrate || 9600;

    this.serialPort = options.serialPort;
    if (this.serialPort) {
        this.emit(&#x22;open&#x22;, this.serialPort);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.listen" id="apidoc.element.osc.SerialPort.prototype.listen">
        function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
    var that = this;

    this.serialPort.on(&#x22;data&#x22;, function (data) {
        that.emit(&#x22;data&#x22;, data, undefined);
    });

    this.serialPort.on(&#x22;error&#x22;, function (err) {
        that.emit(&#x22;error&#x22;, err);
    });

    this.serialPort.on(&#x22;close&#x22;, function (err) {
        if (err) {
            that.emit(&#x22;error&#x22;, err);
        } else {
            that.emit(&#x22;close&#x22;);
        }
    });

    that.emit(&#x22;ready&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var osc = require(&#x22;osc&#x22;),
    http = require(&#x22;http&#x22;),
    WebSocket = require(&#x22;ws&#x22;);

// Create an Express server app
// and serve up a directory of static files.
var app = require(&#x22;express&#x22;).express(),
    server = app.<span class="apidocCodeKeywordSpan">listen</span>(8081);

app.use(&#x22;/&#x22;, express.static(__dirname + &#x22;/static&#x22;));

// Listen for Web Socket requests.
var wss = new WebSocket.Server({
    server: server
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.open" id="apidoc.element.osc.SerialPort.prototype.open">
        function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
    if (this.serialPort) {
        // If we already have a serial port, close it and open a new one.
        this.once(&#x22;close&#x22;, this.open.bind(this));
        this.close();
        return;
    }

    var that = this;

    this.serialPort = new SerialPort(this.options.devicePath, {
        baudrate: this.options.bitrate,
        autoOpen: false
    });

    this.serialPort.open(function() {
        that.emit(&#x22;open&#x22;, that.serialPort);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oscPort = new osc.WebSocketPort({
    url: &#x22;ws://localhost:8081&#x22; // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.<span class="apidocCodeKeywordSpan">open</span>();
```

##### Listening for incoming OSC messages:
```javascript
oscPort.on(&#x22;message&#x22;, function (oscMsg) {
    console.log(&#x22;An OSC message just arrived!&#x22;, oscMsg);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.SerialPort.prototype.sendRaw" id="apidoc.element.osc.SerialPort.prototype.sendRaw">
        function <span class="apidocSignatureSpan">osc.SerialPort.prototype.</span>sendRaw
        <span class="apidocSignatureSpan">(encoded)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendRaw = function (encoded) {
    if (!this.serialPort || !this.serialPort.isOpen()) {
        osc.fireClosedPortSendError(this);
        return;
    }

    var that = this;
    this.serialPort.write(encoded, function (err) {
        if (err) {
            that.emit(&#x22;error&#x22;, err);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.TCPSocketPort" id="apidoc.module.osc.TCPSocketPort">module osc.TCPSocketPort</a></h1>


    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.TCPSocketPort" id="apidoc.element.osc.TCPSocketPort.TCPSocketPort">
        function <span class="apidocSignatureSpan">osc.</span>TCPSocketPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TCPSocketPort = function (options) {
    osc.SLIPPort.call(this, options);

    var o = this.options;
    o.localAddress = o.localAddress || &#x22;127.0.0.1&#x22;;
    o.localPort = o.localPort !== undefined ? o.localPort : 57121;

    this.on(&#x22;open&#x22;, this.listen.bind(this));
    this.socket = options.socket;

    if (this.socket) {
        this.emit(&#x22;open&#x22;, this.socket);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.TCPSocketPort.prototype" id="apidoc.module.osc.TCPSocketPort.prototype">module osc.TCPSocketPort.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.close" id="apidoc.element.osc.TCPSocketPort.prototype.close">
        function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    this.socket.end();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &#x26;&#x26; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.constructor" id="apidoc.element.osc.TCPSocketPort.prototype.constructor">
        function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (options) {
    osc.SLIPPort.call(this, options);

    var o = this.options;
    o.localAddress = o.localAddress || &#x22;127.0.0.1&#x22;;
    o.localPort = o.localPort !== undefined ? o.localPort : 57121;

    this.on(&#x22;open&#x22;, this.listen.bind(this));
    this.socket = options.socket;

    if (this.socket) {
        this.emit(&#x22;open&#x22;, this.socket);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.listen" id="apidoc.element.osc.TCPSocketPort.prototype.listen">
        function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
    var that = this;
    this.socket.on(&#x22;data&#x22;, function (msg) {
        that.emit(&#x22;data&#x22;, msg, undefined);
    });

    this.socket.on(&#x22;error&#x22;, function (err) {
        that.emit(&#x22;error&#x22;, err);
    });

    this.socket.on(&#x22;close&#x22;, function (err) {
        if (err) {
            that.emit(&#x22;error&#x22;, err);
        } else {
            that.emit(&#x22;close&#x22;);
        }
    });

    this.socket.on(&#x22;connect&#x22;, function () {
        that.emit(&#x22;ready&#x22;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var osc = require(&#x22;osc&#x22;),
    http = require(&#x22;http&#x22;),
    WebSocket = require(&#x22;ws&#x22;);

// Create an Express server app
// and serve up a directory of static files.
var app = require(&#x22;express&#x22;).express(),
    server = app.<span class="apidocCodeKeywordSpan">listen</span>(8081);

app.use(&#x22;/&#x22;, express.static(__dirname + &#x22;/static&#x22;));

// Listen for Web Socket requests.
var wss = new WebSocket.Server({
    server: server
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.open" id="apidoc.element.osc.TCPSocketPort.prototype.open">
        function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>open
        <span class="apidocSignatureSpan">(address, port)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function (address, port) {
    var o = this.options;
    address = address || o.address;
    port = port !== undefined ? port : o.port;

    if (!this.socket) {
        this.socket = net.connect({
            port: port,
            host: address
        });
    } else {
        this.socket.connect(port, address);
    }

    this.emit(&#x22;open&#x22;, this.socket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oscPort = new osc.WebSocketPort({
    url: &#x22;ws://localhost:8081&#x22; // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.<span class="apidocCodeKeywordSpan">open</span>();
```

##### Listening for incoming OSC messages:
```javascript
oscPort.on(&#x22;message&#x22;, function (oscMsg) {
    console.log(&#x22;An OSC message just arrived!&#x22;, oscMsg);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.TCPSocketPort.prototype.sendRaw" id="apidoc.element.osc.TCPSocketPort.prototype.sendRaw">
        function <span class="apidocSignatureSpan">osc.TCPSocketPort.prototype.</span>sendRaw
        <span class="apidocSignatureSpan">(encoded)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendRaw = function (encoded) {
    if (!this.socket) {
        return;
    }

    encoded = new Buffer(encoded);

    try {
        this.socket.write(encoded);
    } catch (err) {
        this.emit(&#x22;error&#x22;, err);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.UDPPort" id="apidoc.module.osc.UDPPort">module osc.UDPPort</a></h1>


    <h2>
        <a href="#apidoc.element.osc.UDPPort.UDPPort" id="apidoc.element.osc.UDPPort.UDPPort">
        function <span class="apidocSignatureSpan">osc.</span>UDPPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UDPPort = function (options) {
    osc.Port.call(this, options);

    this.options.localAddress = this.options.localAddress || &#x22;127.0.0.1&#x22;;
    this.options.localPort = this.options.localPort !== undefined ?
        this.options.localPort : 57121;

    this.options.remoteAddress = this.options.remoteAddress || &#x22;127.0.0.1&#x22;;
    this.options.remotePort = this.options.remotePort !== undefined ?
        this.options.remotePort : 57121;

    this.on(&#x22;open&#x22;, this.listen.bind(this));

    this.socket = options.socket;
    if (this.socket) {
        this.emit(&#x22;open&#x22;, this.socket);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3c;/tr&#x3e;
&#x3c;/table&#x3e;

#### Sample Code

```javascript
// Create an osc.js UDP Port listening on port 57121.
var udpPort = new osc.<span class="apidocCodeKeywordSpan">UDPPort</span>({
localAddress: &#x22;0.0.0.0&#x22;,
localPort: 57121
});

// Listen for incoming OSC bundles.
udpPort.on(&#x22;bundle&#x22;, function (oscBundle, timeTag, info) {
console.log(&#x22;An OSC bundle just arrived for time tag&#x22;, timeTag, &#x22;:&#x22;, oscBundle);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort.setupMulticast" id="apidoc.element.osc.UDPPort.setupMulticast">
        function <span class="apidocSignatureSpan">osc.UDPPort.</span>setupMulticast
        <span class="apidocSignatureSpan">(that)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupMulticast = function (that) {
    if (that.options.multicastTTL !== undefined) {
        that.socket.setMulticastTTL(that.options.multicastTTL);
    }

    if (that.options.multicastMembership) {
        if (typeof that.options.multicastMembership === &#x22;string&#x22;) {
            that.options.multicastMembership = [that.options.multicastMembership];
        }

        that.options.multicastMembership.forEach(function (addr) {
            if (typeof addr === &#x22;string&#x22;) {
              that.socket.addMembership(addr);
            } else {
              that.socket.addMembership(addr.address, addr.interface);
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.UDPPort.prototype" id="apidoc.module.osc.UDPPort.prototype">module osc.UDPPort.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.close" id="apidoc.element.osc.UDPPort.prototype.close">
        function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    if (this.socket) {
        this.socket.close();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &#x26;&#x26; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.constructor" id="apidoc.element.osc.UDPPort.prototype.constructor">
        function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (options) {
    osc.Port.call(this, options);

    this.options.localAddress = this.options.localAddress || &#x22;127.0.0.1&#x22;;
    this.options.localPort = this.options.localPort !== undefined ?
        this.options.localPort : 57121;

    this.options.remoteAddress = this.options.remoteAddress || &#x22;127.0.0.1&#x22;;
    this.options.remotePort = this.options.remotePort !== undefined ?
        this.options.remotePort : 57121;

    this.on(&#x22;open&#x22;, this.listen.bind(this));

    this.socket = options.socket;
    if (this.socket) {
        this.emit(&#x22;open&#x22;, this.socket);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.listen" id="apidoc.element.osc.UDPPort.prototype.listen">
        function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
    if (!this.socket) {
        return;
    }

    var that = this;
    this.socket.on(&#x22;message&#x22;, function (msg, rinfo) {
        that.emit(&#x22;data&#x22;, msg, rinfo);
    });

    this.socket.on(&#x22;error&#x22;, function (error) {
        that.emit(&#x22;error&#x22;, error);
    });

    this.socket.on(&#x22;close&#x22;, function () {
        that.emit(&#x22;close&#x22;);
    });

    that.emit(&#x22;ready&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var osc = require(&#x22;osc&#x22;),
    http = require(&#x22;http&#x22;),
    WebSocket = require(&#x22;ws&#x22;);

// Create an Express server app
// and serve up a directory of static files.
var app = require(&#x22;express&#x22;).express(),
    server = app.<span class="apidocCodeKeywordSpan">listen</span>(8081);

app.use(&#x22;/&#x22;, express.static(__dirname + &#x22;/static&#x22;));

// Listen for Web Socket requests.
var wss = new WebSocket.Server({
    server: server
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.open" id="apidoc.element.osc.UDPPort.prototype.open">
        function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
    var that = this;

    if (this.socket) {
        return;
    }

    this.socket = dgram.createSocket(&#x22;udp4&#x22;);

    function onBound() {
        osc.UDPPort.setupMulticast(that);

        if (that.options.broadcast) {
            that.socket.setBroadcast(that.options.broadcast);
        }

        that.emit(&#x22;open&#x22;, that.socket);
    }

    this.socket.bind(this.options.localPort, this.options.localAddress, onBound);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oscPort = new osc.WebSocketPort({
    url: &#x22;ws://localhost:8081&#x22; // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.<span class="apidocCodeKeywordSpan">open</span>();
```

##### Listening for incoming OSC messages:
```javascript
oscPort.on(&#x22;message&#x22;, function (oscMsg) {
    console.log(&#x22;An OSC message just arrived!&#x22;, oscMsg);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.UDPPort.prototype.sendRaw" id="apidoc.element.osc.UDPPort.prototype.sendRaw">
        function <span class="apidocSignatureSpan">osc.UDPPort.prototype.</span>sendRaw
        <span class="apidocSignatureSpan">(encoded, address, port)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendRaw = function (encoded, address, port) {
    if (!this.socket) {
        osc.fireClosedPortSendError(this);
        return;
    }

    var length = encoded.byteLength !== undefined ? encoded.byteLength : encoded.length,
        that = this;

    address = address || this.options.remoteAddress;
    port = port !== undefined ? port : this.options.remotePort;

    this.socket.send(encoded, 0, length, port, address, function (err) {
        if (err) {
            that.emit(&#x22;error&#x22;, err);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket" id="apidoc.module.osc.WebSocket">module osc.WebSocket</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.WebSocket" id="apidoc.element.osc.WebSocket.WebSocket">
        function <span class="apidocSignatureSpan">osc.</span>WebSocket
        <span class="apidocSignatureSpan">(address, protocols, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocket(address, protocols, options) {
  if (this instanceof WebSocket === false) {
    return new WebSocket(address, protocols, options);
  }

  EventEmitter.call(this);

  if (protocols &#x26;&#x26; !Array.isArray(protocols) &#x26;&#x26; &#x27;object&#x27; === typeof protocols) {
    // accept the &#x22;options&#x22; Object as the 2nd argument
    options = protocols;
    protocols = null;
  }

  if (&#x27;string&#x27; === typeof protocols) {
    protocols = [ protocols ];
  }

  if (!Array.isArray(protocols)) {
    protocols = [];
  }

  this._socket = null;
  this._ultron = null;
  this._closeReceived = false;
  this.bytesReceived = 0;
  this.readyState = null;
  this.supports = {};
  this.extensions = {};
  this._binaryType = &#x27;nodebuffer&#x27;;

  if (Array.isArray(address)) {
    initAsServerClient.apply(this, address.concat(options));
  } else {
    initAsClient.apply(this, [address, protocols, options]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };

    var p = osc.WebSocketPort.prototype = Object.create(osc.Port.prototype);
    p.constructor = osc.WebSocketPort;

    p.open = function () {
if (!this.socket || this.socket.readyState &#x3e; 1) {
    this.socket = new osc.<span class="apidocCodeKeywordSpan">WebSocket</span>(this.options.url);
}

osc.WebSocketPort.setupSocketForBinary(this.socket);

var that = this;
this.socket.onopen = function () {
    that.emit(&#x22;open&#x22;, that.socket);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver" id="apidoc.element.osc.WebSocket.Receiver">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>Receiver
        <span class="apidocSignatureSpan">(extensions, maxPayload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Receiver(extensions, maxPayload) {
  if (this instanceof Receiver === false) {
    throw new TypeError(&#x22;Classes can&#x27;t be function-called&#x22;);
  }
  if(typeof extensions===&#x27;number&#x27;){
    maxPayload=extensions;
    extensions={};
  }


  // memory pool for fragmented messages
  var fragmentedPoolPrevUsed = -1;
  this.fragmentedBufferPool = new BufferPool(1024, function(db, length) {
    return db.used + length;
  }, function(db) {
    return fragmentedPoolPrevUsed = fragmentedPoolPrevUsed &#x3e;= 0 ?
      Math.ceil((fragmentedPoolPrevUsed + db.used) / 2) :
      db.used;
  });

  // memory pool for unfragmented messages
  var unfragmentedPoolPrevUsed = -1;
  this.unfragmentedBufferPool = new BufferPool(1024, function(db, length) {
    return db.used + length;
  }, function(db) {
    return unfragmentedPoolPrevUsed = unfragmentedPoolPrevUsed &#x3e;= 0 ?
      Math.ceil((unfragmentedPoolPrevUsed + db.used) / 2) :
      db.used;
  });
  this.extensions = extensions || {};
  this.maxPayload = maxPayload || 0;
  this.currentPayloadLength = 0;
  this.state = {
    activeFragmentedOperation: null,
    lastFragment: false,
    masked: false,
    opcode: 0,
    fragmentedOperation: false
  };
  this.overflow = [];
  this.headerBuffer = new Buffer(10);
  this.expectOffset = 0;
  this.expectBuffer = null;
  this.expectHandler = null;
  this.currentMessage = [];
  this.currentMessageLength = 0;
  this.messageHandlers = [];
  this.expectHeader(2, this.processPacket);
  this.dead = false;
  this.processing = false;

  this.onerror = function() {};
  this.ontext = function() {};
  this.onbinary = function() {};
  this.onclose = function() {};
  this.onping = function() {};
  this.onpong = function() {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender" id="apidoc.element.osc.WebSocket.Sender">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>Sender
        <span class="apidocSignatureSpan">(socket, extensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Sender(socket, extensions) {
  if (this instanceof Sender === false) {
    throw new TypeError(&#x22;Classes can&#x27;t be function-called&#x22;);
  }

  events.EventEmitter.call(this);

  this._socket = socket;
  this.extensions = extensions || {};
  this.firstFragment = true;
  this.compress = false;
  this.messageHandlers = [];
  this.processing = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Server" id="apidoc.element.osc.WebSocket.Server">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>Server
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketServer(options, callback) {
  if (this instanceof WebSocketServer === false) {
    return new WebSocketServer(options, callback);
  }

  events.EventEmitter.call(this);

  options = new Options({
    host: &#x27;0.0.0.0&#x27;,
    port: null,
    server: null,
    verifyClient: null,
    handleProtocols: null,
    path: null,
    noServer: false,
    disableHixie: false,
    clientTracking: true,
    perMessageDeflate: true,
    maxPayload: 100 * 1024 * 1024
  }).merge(options);

  if (!options.isDefinedAndNonNull(&#x27;port&#x27;) &#x26;&#x26; !options.isDefinedAndNonNull(&#x27;server&#x27;) &#x26;&#x26; !options.value.noServer) {
    throw new TypeError(&#x27;`port` or a `server` must be provided&#x27;);
  }

  var self = this;

  if (options.isDefinedAndNonNull(&#x27;port&#x27;)) {
    this._server = http.createServer(function (req, res) {
      var body = http.STATUS_CODES[426];
      res.writeHead(426, {
        &#x27;Content-Length&#x27;: body.length,
        &#x27;Content-Type&#x27;: &#x27;text/plain&#x27;
      });
      res.end(body);
    });
    this._server.allowHalfOpen = false;
    this._server.listen(options.value.port, options.value.host, callback);
    this._closeServer = function() { if (self._server) self._server.close(); };
  }
  else if (options.value.server) {
    this._server = options.value.server;
    if (options.value.path) {
      // take note of the path, to avoid collisions when multiple websocket servers are
      // listening on the same http server
      if (this._server._webSocketPaths &#x26;&#x26; options.value.server._webSocketPaths[options.value.path]) {
        throw new Error(&#x27;two instances of WebSocketServer cannot listen on the same http server path&#x27;);
      }
      if (typeof this._server._webSocketPaths !== &#x27;object&#x27;) {
        this._server._webSocketPaths = {};
      }
      this._server._webSocketPaths[options.value.path] = 1;
    }
  }
  if (this._server) {
    this._onceServerListening = function() { self.emit(&#x27;listening&#x27;); };
    this._server.once(&#x27;listening&#x27;, this._onceServerListening);
  }

  if (typeof this._server != &#x27;undefined&#x27;) {
    this._onServerError = function(error) { self.emit(&#x27;error&#x27;, error) };
    this._server.on(&#x27;error&#x27;, this._onServerError);
    this._onServerUpgrade = function(req, socket, upgradeHead) {
      //copy upgradeHead to avoid retention of large slab buffers used in node core
      var head = new Buffer(upgradeHead.length);
      upgradeHead.copy(head);

      self.handleUpgrade(req, socket, head, function(client) {
        self.emit(&#x27;connection&#x27;+req.url, client);
        self.emit(&#x27;connection&#x27;, client);
      });
    };
    this._server.on(&#x27;upgrade&#x27;, this._onServerUpgrade);
  }

  this.options = options.value;
  this.path = options.value.path;
  this.clients = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// and serve up a directory of static files.
var app = require(&#x22;express&#x22;).express(),
server = app.listen(8081);

app.use(&#x22;/&#x22;, express.static(__dirname + &#x22;/static&#x22;));

// Listen for Web Socket requests.
var wss = new WebSocket.<span class="apidocCodeKeywordSpan">Server</span>({
server: server
});

// Listen for Web Socket connections.
wss.on(&#x22;connection&#x22;, function (socket) {
var socketPort = new osc.WebSocketPort({
    socket: socket
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.buildHostHeader" id="apidoc.element.osc.WebSocket.buildHostHeader">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>buildHostHeader
        <span class="apidocSignatureSpan">(isSecure, hostname, port)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildHostHeader(isSecure, hostname, port) {
  var headerHost = hostname;
  if (hostname) {
    if ((isSecure &#x26;&#x26; (port != 443)) || (!isSecure &#x26;&#x26; (port != 80))){
      headerHost = headerHost + &#x27;:&#x27; + port;
    }
  }
  return headerHost;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.connect" id="apidoc.element.osc.WebSocket.connect">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>connect
        <span class="apidocSignatureSpan">(address, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function connect(address, fn) {
  var client = new WS(address);

  if (typeof fn === &#x27;function&#x27;) {
    client.on(&#x27;open&#x27;, fn);
  }

  return client;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

p.open = function () {
    var that = this,
        connectionOpts = {
            bitrate: that.options.bitrate
        };

    chrome.serial.<span class="apidocCodeKeywordSpan">connect</span>(this.options.devicePath, connectionOpts, function (info) {
        that.connectionId = info.connectionId;
        that.emit(&#x22;open&#x22;, info);
    });
};

p.listen = function () {
    osc.listenToTransport(this, chrome.serial, &#x22;connectionId&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.createConnection" id="apidoc.element.osc.WebSocket.createConnection">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>createConnection
        <span class="apidocSignatureSpan">(address, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function connect(address, fn) {
  var client = new WS(address);

  if (typeof fn === &#x27;function&#x27;) {
    client.on(&#x27;open&#x27;, fn);
  }

  return client;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.createServer" id="apidoc.element.osc.WebSocket.createServer">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>createServer
        <span class="apidocSignatureSpan">(options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createServer(options, fn) {
  var server = new WS.Server(options);

  if (typeof fn === &#x27;function&#x27;) {
    server.on(&#x27;connection&#x27;, fn);
  }

  return server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.super_" id="apidoc.element.osc.WebSocket.super_">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver" id="apidoc.module.osc.WebSocket.Receiver">module osc.WebSocket.Receiver</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.Receiver" id="apidoc.element.osc.WebSocket.Receiver.Receiver">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>Receiver
        <span class="apidocSignatureSpan">(extensions, maxPayload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Receiver(extensions, maxPayload) {
  if (this instanceof Receiver === false) {
    throw new TypeError(&#x22;Classes can&#x27;t be function-called&#x22;);
  }
  if(typeof extensions===&#x27;number&#x27;){
    maxPayload=extensions;
    extensions={};
  }


  // memory pool for fragmented messages
  var fragmentedPoolPrevUsed = -1;
  this.fragmentedBufferPool = new BufferPool(1024, function(db, length) {
    return db.used + length;
  }, function(db) {
    return fragmentedPoolPrevUsed = fragmentedPoolPrevUsed &#x3e;= 0 ?
      Math.ceil((fragmentedPoolPrevUsed + db.used) / 2) :
      db.used;
  });

  // memory pool for unfragmented messages
  var unfragmentedPoolPrevUsed = -1;
  this.unfragmentedBufferPool = new BufferPool(1024, function(db, length) {
    return db.used + length;
  }, function(db) {
    return unfragmentedPoolPrevUsed = unfragmentedPoolPrevUsed &#x3e;= 0 ?
      Math.ceil((unfragmentedPoolPrevUsed + db.used) / 2) :
      db.used;
  });
  this.extensions = extensions || {};
  this.maxPayload = maxPayload || 0;
  this.currentPayloadLength = 0;
  this.state = {
    activeFragmentedOperation: null,
    lastFragment: false,
    masked: false,
    opcode: 0,
    fragmentedOperation: false
  };
  this.overflow = [];
  this.headerBuffer = new Buffer(10);
  this.expectOffset = 0;
  this.expectBuffer = null;
  this.expectHandler = null;
  this.currentMessage = [];
  this.currentMessageLength = 0;
  this.messageHandlers = [];
  this.expectHeader(2, this.processPacket);
  this.dead = false;
  this.processing = false;

  this.onerror = function() {};
  this.ontext = function() {};
  this.onbinary = function() {};
  this.onclose = function() {};
  this.onping = function() {};
  this.onpong = function() {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Receiver.prototype" id="apidoc.module.osc.WebSocket.Receiver.prototype">module osc.WebSocket.Receiver.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.add" id="apidoc.element.osc.WebSocket.Receiver.prototype.add">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>add
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (data) {
  if (this.dead) return;
  var dataLength = data.length;
  if (dataLength == 0) return;
  if (this.expectBuffer == null) {
    this.overflow.push(data);
    return;
  }
  var toRead = Math.min(dataLength, this.expectBuffer.length - this.expectOffset);
  fastCopy(toRead, data, this.expectBuffer, this.expectOffset);
  this.expectOffset += toRead;
  if (toRead &#x3c; dataLength) {
    this.overflow.push(data.slice(toRead));
  }
  while (this.expectBuffer &#x26;&#x26; this.expectOffset == this.expectBuffer.length) {
    var bufferForHandler = this.expectBuffer;
    this.expectBuffer = null;
    this.expectOffset = 0;
    this.expectHandler.call(this, bufferForHandler);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.allocateFromPool" id="apidoc.element.osc.WebSocket.Receiver.prototype.allocateFromPool">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>allocateFromPool
        <span class="apidocSignatureSpan">(length, isFragmented)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allocateFromPool = function (length, isFragmented) {
  return (isFragmented ? this.fragmentedBufferPool : this.unfragmentedBufferPool).get(length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.applyExtensions" id="apidoc.element.osc.WebSocket.Receiver.prototype.applyExtensions">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>applyExtensions
        <span class="apidocSignatureSpan">(messageBuffer, fin, compressed, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyExtensions = function (messageBuffer, fin, compressed, callback) {
  var self = this;
  if (compressed) {
    this.extensions[PerMessageDeflate.extensionName].decompress(messageBuffer, fin, function(err, buffer) {
      if (self.dead) return;
      if (err) {
        callback(new Error(&#x27;invalid compressed data&#x27;));
        return;
      }
      callback(null, buffer);
    });
  } else {
    callback(null, messageBuffer);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.cleanup" id="apidoc.element.osc.WebSocket.Receiver.prototype.cleanup">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>cleanup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanup = function () {
  this.dead = true;
  this.overflow = null;
  this.headerBuffer = null;
  this.expectBuffer = null;
  this.expectHandler = null;
  this.unfragmentedBufferPool = null;
  this.fragmentedBufferPool = null;
  this.state = null;
  this.currentMessage = null;
  this.onerror = null;
  this.ontext = null;
  this.onbinary = null;
  this.onclose = null;
  this.onping = null;
  this.onpong = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.endPacket" id="apidoc.element.osc.WebSocket.Receiver.prototype.endPacket">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>endPacket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endPacket = function () {
  if (this.dead) return;
  if (!this.state.fragmentedOperation) this.unfragmentedBufferPool.reset(true);
  else if (this.state.lastFragment) this.fragmentedBufferPool.reset(true);
  this.expectOffset = 0;
  this.expectBuffer = null;
  this.expectHandler = null;
  if (this.state.lastFragment &#x26;&#x26; this.state.opcode === this.state.activeFragmentedOperation) {
    // end current fragmented operation
    this.state.activeFragmentedOperation = null;
  }
  this.currentPayloadLength = 0;
  this.state.lastFragment = false;
  this.state.opcode = this.state.activeFragmentedOperation != null ? this.state.activeFragmentedOperation : 0;
  this.state.masked = false;
  this.expectHeader(2, this.processPacket);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.error" id="apidoc.element.osc.WebSocket.Receiver.prototype.error">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>error
        <span class="apidocSignatureSpan">(reason, protocolErrorCode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (reason, protocolErrorCode) {
  if (this.dead) return;
  this.reset();
  if(typeof reason == &#x27;string&#x27;){
    this.onerror(new Error(reason), protocolErrorCode);
  }
  else if(reason.constructor == Error){
    this.onerror(reason, protocolErrorCode);
  }
  else{
    this.onerror(new Error(&#x22;An error occured&#x22;),protocolErrorCode);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.expectData" id="apidoc.element.osc.WebSocket.Receiver.prototype.expectData">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>expectData
        <span class="apidocSignatureSpan">(length, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expectData = function (length, handler) {
  if (length == 0) {
    handler(null);
    return;
  }
  this.expectBuffer = this.allocateFromPool(length, this.state.fragmentedOperation);
  this.expectHandler = handler;
  var toRead = length;
  while (toRead &#x3e; 0 &#x26;&#x26; this.overflow.length &#x3e; 0) {
    var fromOverflow = this.overflow.pop();
    if (toRead &#x3c; fromOverflow.length) this.overflow.push(fromOverflow.slice(toRead));
    var read = Math.min(fromOverflow.length, toRead);
    fastCopy(read, fromOverflow, this.expectBuffer, this.expectOffset);
    this.expectOffset += read;
    toRead -= read;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.expectHeader" id="apidoc.element.osc.WebSocket.Receiver.prototype.expectHeader">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>expectHeader
        <span class="apidocSignatureSpan">(length, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expectHeader = function (length, handler) {
  if (length == 0) {
    handler(null);
    return;
  }
  this.expectBuffer = this.headerBuffer.slice(this.expectOffset, this.expectOffset + length);
  this.expectHandler = handler;
  var toRead = length;
  while (toRead &#x3e; 0 &#x26;&#x26; this.overflow.length &#x3e; 0) {
    var fromOverflow = this.overflow.pop();
    if (toRead &#x3c; fromOverflow.length) this.overflow.push(fromOverflow.slice(toRead));
    var read = Math.min(fromOverflow.length, toRead);
    fastCopy(read, fromOverflow, this.expectBuffer, this.expectOffset);
    this.expectOffset += read;
    toRead -= read;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.flush" id="apidoc.element.osc.WebSocket.Receiver.prototype.flush">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function () {
  if (this.processing || this.dead) return;

  var handler = this.messageHandlers.shift();
  if (!handler) return;

  this.processing = true;
  var self = this;

  handler(function() {
    self.processing = false;
    self.flush();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.maxPayloadExceeded" id="apidoc.element.osc.WebSocket.Receiver.prototype.maxPayloadExceeded">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>maxPayloadExceeded
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxPayloadExceeded = function (length) {
  if (this.maxPayload=== undefined || this.maxPayload === null || this.maxPayload &#x3c; 1) {
    return false;
  }
  var fullLength = this.currentPayloadLength + length;
  if (fullLength &#x3c; this.maxPayload) {
    this.currentPayloadLength = fullLength;
    return false;
  }
  this.error(&#x27;payload cannot exceed &#x27; + this.maxPayload + &#x27; bytes&#x27;, 1009);
  this.messageBuffer=[];
  this.cleanup();

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.processPacket" id="apidoc.element.osc.WebSocket.Receiver.prototype.processPacket">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>processPacket
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processPacket = function (data) {
  if (this.extensions[PerMessageDeflate.extensionName]) {
    if ((data[0] &#x26; 0x30) != 0) {
      this.error(&#x27;reserved fields (2, 3) must be empty&#x27;, 1002);
      return;
    }
  } else {
    if ((data[0] &#x26; 0x70) != 0) {
      this.error(&#x27;reserved fields must be empty&#x27;, 1002);
      return;
    }
  }
  this.state.lastFragment = (data[0] &#x26; 0x80) == 0x80;
  this.state.masked = (data[1] &#x26; 0x80) == 0x80;
  var compressed = (data[0] &#x26; 0x40) == 0x40;
  var opcode = data[0] &#x26; 0xf;
  if (opcode === 0) {
    if (compressed) {
      this.error(&#x27;continuation frame cannot have the Per-message Compressed bits&#x27;, 1002);
      return;
    }
    // continuation frame
    this.state.fragmentedOperation = true;
    this.state.opcode = this.state.activeFragmentedOperation;
    if (!(this.state.opcode == 1 || this.state.opcode == 2)) {
      this.error(&#x27;continuation frame cannot follow current opcode&#x27;, 1002);
      return;
    }
  }
  else {
    if (opcode &#x3c; 3 &#x26;&#x26; this.state.activeFragmentedOperation != null) {
      this.error(&#x27;data frames after the initial data frame must have opcode 0&#x27;, 1002);
      return;
    }
    if (opcode &#x3e;= 8 &#x26;&#x26; compressed) {
      this.error(&#x27;control frames cannot have the Per-message Compressed bits&#x27;, 1002);
      return;
    }
    this.state.compressed = compressed;
    this.state.opcode = opcode;
    if (this.state.lastFragment === false) {
      this.state.fragmentedOperation = true;
      this.state.activeFragmentedOperation = opcode;
    }
    else this.state.fragmentedOperation = false;
  }
  var handler = opcodes[this.state.opcode];
  if (typeof handler == &#x27;undefined&#x27;) this.error(&#x27;no handler for opcode &#x27; + this.state.opcode, 1002);
  else {
    handler.start.call(this, data);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.reset" id="apidoc.element.osc.WebSocket.Receiver.prototype.reset">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
  if (this.dead) return;
  this.state = {
    activeFragmentedOperation: null,
    lastFragment: false,
    masked: false,
    opcode: 0,
    fragmentedOperation: false
  };
  this.fragmentedBufferPool.reset(true);
  this.unfragmentedBufferPool.reset(true);
  this.expectOffset = 0;
  this.expectBuffer = null;
  this.expectHandler = null;
  this.overflow = [];
  this.currentMessage = [];
  this.currentMessageLength = 0;
  this.messageHandlers = [];
  this.currentPayloadLength = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Receiver.prototype.unmask" id="apidoc.element.osc.WebSocket.Receiver.prototype.unmask">
        function <span class="apidocSignatureSpan">osc.WebSocket.Receiver.prototype.</span>unmask
        <span class="apidocSignatureSpan">(mask, buf, binary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmask = function (mask, buf, binary) {
  if (mask != null &#x26;&#x26; buf != null) bufferUtil.unmask(buf, mask);
  if (binary) return buf;
  return buf != null ? buf.toString(&#x27;utf8&#x27;) : &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Sender" id="apidoc.module.osc.WebSocket.Sender">module osc.WebSocket.Sender</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.Sender" id="apidoc.element.osc.WebSocket.Sender.Sender">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>Sender
        <span class="apidocSignatureSpan">(socket, extensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Sender(socket, extensions) {
  if (this instanceof Sender === false) {
    throw new TypeError(&#x22;Classes can&#x27;t be function-called&#x22;);
  }

  events.EventEmitter.call(this);

  this._socket = socket;
  this.extensions = extensions || {};
  this.firstFragment = true;
  this.compress = false;
  this.messageHandlers = [];
  this.processing = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.super_" id="apidoc.element.osc.WebSocket.Sender.super_">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Sender.prototype" id="apidoc.module.osc.WebSocket.Sender.prototype">module osc.WebSocket.Sender.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.applyExtensions" id="apidoc.element.osc.WebSocket.Sender.prototype.applyExtensions">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>applyExtensions
        <span class="apidocSignatureSpan">(data, fin, compress, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyExtensions = function (data, fin, compress, callback) {
  if (compress &#x26;&#x26; data) {
    if ((data.buffer || data) instanceof ArrayBuffer) {
      data = getArrayBuffer(data);
    }
    this.extensions[PerMessageDeflate.extensionName].compress(data, fin, callback);
  } else {
    callback(null, data);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.close" id="apidoc.element.osc.WebSocket.Sender.prototype.close">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>close
        <span class="apidocSignatureSpan">(code, data, mask, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (code, data, mask, cb) {
  if (typeof code !== &#x27;undefined&#x27;) {
    if (typeof code !== &#x27;number&#x27; ||
      !ErrorCodes.isValidErrorCode(code)) throw new Error(&#x27;first argument must be a valid error code number&#x27;);
  }
  code = code || 1000;
  var dataBuffer = new Buffer(2 + (data ? Buffer.byteLength(data) : 0));
  writeUInt16BE.call(dataBuffer, code, 0);
  if (dataBuffer.length &#x3e; 2) dataBuffer.write(data, 2);

  var self = this;
  this.messageHandlers.push(function(callback) {
    self.frameAndSend(0x8, dataBuffer, true, mask);
    callback();
    if (typeof cb == &#x27;function&#x27;) cb();
  });
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &#x26;&#x26; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.flush" id="apidoc.element.osc.WebSocket.Sender.prototype.flush">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function () {
  if (this.processing) return;

  var handler = this.messageHandlers.shift();
  if (!handler) return;

  this.processing = true;

  var self = this;

  handler(function() {
    self.processing = false;
    self.flush();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.frameAndSend" id="apidoc.element.osc.WebSocket.Sender.prototype.frameAndSend">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>frameAndSend
        <span class="apidocSignatureSpan">(opcode, data, finalFragment, maskData, compressed, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">frameAndSend = function (opcode, data, finalFragment, maskData, compressed, cb) {
  var canModifyData = false;

  if (!data) {
    try {
      this._socket.write(new Buffer([opcode | (finalFragment ? 0x80 : 0), 0 | (maskData ? 0x80 : 0)].concat(maskData ? [0, 0, 0,
0] : [])), &#x27;binary&#x27;, cb);
    }
    catch (e) {
      if (typeof cb == &#x27;function&#x27;) cb(e);
      else this.emit(&#x27;error&#x27;, e);
    }
    return;
  }

  if (!Buffer.isBuffer(data)) {
    canModifyData = true;
    if (data &#x26;&#x26; (typeof data.byteLength !== &#x27;undefined&#x27; || typeof data.buffer !== &#x27;undefined&#x27;)) {
      data = getArrayBuffer(data);
    } else {
      //
      // If people want to send a number, this would allocate the number in
      // bytes as memory size instead of storing the number as buffer value. So
      // we need to transform it to string in order to prevent possible
      // vulnerabilities / memory attacks.
      //
      if (typeof data === &#x27;number&#x27;) data = data.toString();

      data = new Buffer(data);
    }
  }

  var dataLength = data.length
    , dataOffset = maskData ? 6 : 2
    , secondByte = dataLength;

  if (dataLength &#x3e;= 65536) {
    dataOffset += 8;
    secondByte = 127;
  }
  else if (dataLength &#x3e; 125) {
    dataOffset += 2;
    secondByte = 126;
  }

  var mergeBuffers = dataLength &#x3c; 32768 || (maskData &#x26;&#x26; !canModifyData);
  var totalLength = mergeBuffers ? dataLength + dataOffset : dataOffset;
  var outputBuffer = new Buffer(totalLength);
  outputBuffer[0] = finalFragment ? opcode | 0x80 : opcode;
  if (compressed) outputBuffer[0] |= 0x40;

  switch (secondByte) {
    case 126:
      writeUInt16BE.call(outputBuffer, dataLength, 2);
      break;
    case 127:
      writeUInt32BE.call(outputBuffer, 0, 2);
      writeUInt32BE.call(outputBuffer, dataLength, 6);
  }

  if (maskData) {
    outputBuffer[1] = secondByte | 0x80;
    var mask = getRandomMask();
    outputBuffer[dataOffset - 4] = mask[0];
    outputBuffer[dataOffset - 3] = mask[1];
    outputBuffer[dataOffset - 2] = mask[2];
    outputBuffer[dataOffset - 1] = mask[3];
    if (mergeBuffers) {
      bufferUtil.mask(data, mask, outputBuffer, dataOffset, dataLength);
      try {
        this._socket.write(outputBuffer, &#x27;binary&#x27;, cb);
      }
      catch (e) {
        if (typeof cb == &#x27;function&#x27;) cb(e);
        else this.emit(&#x27;error&#x27;, e);
      }
    }
    else {
      bufferUtil.mask(data, mask, data, 0, dataLength);
      try {
        this._socket.write(outputBuffer, &#x27;binary&#x27;);
        this._socket.write(data, &#x27;binary&#x27;, cb);
      }
      catch (e) {
        if (typeof cb == &#x27;function&#x27;) cb(e);
        else this.emit(&#x27;error&#x27;, e);
      }
    }
  }
  else {
    outputBuffer[1] = secondByte;
    if (mergeBuffers) {
      data.copy(outputBuffer, dataOffset);
      try {
        this._socket.write(outputBuffer, &#x27;binary&#x27;, cb);
      }
      catch (e) {
        if (typeof cb == &#x27;function&#x27;) cb(e);
        else this.emit(&#x27;error&#x27;, e);
      }
    }
    else {
      try {
        this._socket.write(outputBuffer, &#x27;binary&#x27;);
        this._socket.write(data, &#x27;binary&#x27;, cb);
      }
      catch (e) {
        if (typeof cb == &#x27;function&#x27;) cb(e);
        else this.emit(&#x27;error&#x27;, e);
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.ping" id="apidoc.element.osc.WebSocket.Sender.prototype.ping">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>ping
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ping = function (data, options) {
  var mask = options &#x26;&#x26; options.mask;
  var self = this;
  this.messageHandlers.push(function(callback) {
    self.frameAndSend(0x9, data || &#x27;&#x27;, true, mask);
    callback();
  });
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.pong" id="apidoc.element.osc.WebSocket.Sender.prototype.pong">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>pong
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pong = function (data, options) {
  var mask = options &#x26;&#x26; options.mask;
  var self = this;
  this.messageHandlers.push(function(callback) {
    self.frameAndSend(0xa, data || &#x27;&#x27;, true, mask);
    callback();
  });
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Sender.prototype.send" id="apidoc.element.osc.WebSocket.Sender.prototype.send">
        function <span class="apidocSignatureSpan">osc.WebSocket.Sender.prototype.</span>send
        <span class="apidocSignatureSpan">(data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (data, options, cb) {
  var finalFragment = options &#x26;&#x26; options.fin === false ? false : true;
  var mask = options &#x26;&#x26; options.mask;
  var compress = options &#x26;&#x26; options.compress;
  var opcode = options &#x26;&#x26; options.binary ? 2 : 1;
  if (this.firstFragment === false) {
    opcode = 0;
    compress = false;
  } else {
    this.firstFragment = false;
    this.compress = compress;
  }
  if (finalFragment) this.firstFragment = true

  var compressFragment = this.compress;

  var self = this;
  this.messageHandlers.push(function(callback) {
    self.applyExtensions(data, finalFragment, compressFragment, function(err, data) {
      if (err) {
        if (typeof cb == &#x27;function&#x27;) cb(err);
        else self.emit(&#x27;error&#x27;, err);
        return;
      }
      self.frameAndSend(opcode, data, finalFragment, mask, compress, cb);
      callback();
    });
  });
  this.flush();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

##### Sending OSC messages:
```javascript
// For most Ports, send() should only be called after the &#x22;ready&#x22; event fires.
oscPort.on(&#x22;ready&#x22;, function () {
    oscPort.<span class="apidocCodeKeywordSpan">send</span>({
        address: &#x22;/carrier/frequency&#x22;,
        args: 440
    });
});
```

##### Sending OSC bundles:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Server" id="apidoc.module.osc.WebSocket.Server">module osc.WebSocket.Server</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Server.Server" id="apidoc.element.osc.WebSocket.Server.Server">
        function <span class="apidocSignatureSpan">osc.WebSocket.</span>Server
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketServer(options, callback) {
  if (this instanceof WebSocketServer === false) {
    return new WebSocketServer(options, callback);
  }

  events.EventEmitter.call(this);

  options = new Options({
    host: &#x27;0.0.0.0&#x27;,
    port: null,
    server: null,
    verifyClient: null,
    handleProtocols: null,
    path: null,
    noServer: false,
    disableHixie: false,
    clientTracking: true,
    perMessageDeflate: true,
    maxPayload: 100 * 1024 * 1024
  }).merge(options);

  if (!options.isDefinedAndNonNull(&#x27;port&#x27;) &#x26;&#x26; !options.isDefinedAndNonNull(&#x27;server&#x27;) &#x26;&#x26; !options.value.noServer) {
    throw new TypeError(&#x27;`port` or a `server` must be provided&#x27;);
  }

  var self = this;

  if (options.isDefinedAndNonNull(&#x27;port&#x27;)) {
    this._server = http.createServer(function (req, res) {
      var body = http.STATUS_CODES[426];
      res.writeHead(426, {
        &#x27;Content-Length&#x27;: body.length,
        &#x27;Content-Type&#x27;: &#x27;text/plain&#x27;
      });
      res.end(body);
    });
    this._server.allowHalfOpen = false;
    this._server.listen(options.value.port, options.value.host, callback);
    this._closeServer = function() { if (self._server) self._server.close(); };
  }
  else if (options.value.server) {
    this._server = options.value.server;
    if (options.value.path) {
      // take note of the path, to avoid collisions when multiple websocket servers are
      // listening on the same http server
      if (this._server._webSocketPaths &#x26;&#x26; options.value.server._webSocketPaths[options.value.path]) {
        throw new Error(&#x27;two instances of WebSocketServer cannot listen on the same http server path&#x27;);
      }
      if (typeof this._server._webSocketPaths !== &#x27;object&#x27;) {
        this._server._webSocketPaths = {};
      }
      this._server._webSocketPaths[options.value.path] = 1;
    }
  }
  if (this._server) {
    this._onceServerListening = function() { self.emit(&#x27;listening&#x27;); };
    this._server.once(&#x27;listening&#x27;, this._onceServerListening);
  }

  if (typeof this._server != &#x27;undefined&#x27;) {
    this._onServerError = function(error) { self.emit(&#x27;error&#x27;, error) };
    this._server.on(&#x27;error&#x27;, this._onServerError);
    this._onServerUpgrade = function(req, socket, upgradeHead) {
      //copy upgradeHead to avoid retention of large slab buffers used in node core
      var head = new Buffer(upgradeHead.length);
      upgradeHead.copy(head);

      self.handleUpgrade(req, socket, head, function(client) {
        self.emit(&#x27;connection&#x27;+req.url, client);
        self.emit(&#x27;connection&#x27;, client);
      });
    };
    this._server.on(&#x27;upgrade&#x27;, this._onServerUpgrade);
  }

  this.options = options.value;
  this.path = options.value.path;
  this.clients = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// and serve up a directory of static files.
var app = require(&#x22;express&#x22;).express(),
server = app.listen(8081);

app.use(&#x22;/&#x22;, express.static(__dirname + &#x22;/static&#x22;));

// Listen for Web Socket requests.
var wss = new WebSocket.<span class="apidocCodeKeywordSpan">Server</span>({
server: server
});

// Listen for Web Socket connections.
wss.on(&#x22;connection&#x22;, function (socket) {
var socketPort = new osc.WebSocketPort({
    socket: socket
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Server.super_" id="apidoc.element.osc.WebSocket.Server.super_">
        function <span class="apidocSignatureSpan">osc.WebSocket.Server.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.Server.prototype" id="apidoc.module.osc.WebSocket.Server.prototype">module osc.WebSocket.Server.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.Server.prototype.close" id="apidoc.element.osc.WebSocket.Server.prototype.close">
        function <span class="apidocSignatureSpan">osc.WebSocket.Server.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback) {
  // terminate all associated clients
  var error = null;
  try {
    for (var i = 0, l = this.clients.length; i &#x3c; l; ++i) {
      this.clients[i].terminate();
    }
  }
  catch (e) {
    error = e;
  }

  // remove path descriptor, if any
  if (this.path &#x26;&#x26; this._server._webSocketPaths) {
    delete this._server._webSocketPaths[this.path];
    if (Object.keys(this._server._webSocketPaths).length == 0) {
      delete this._server._webSocketPaths;
    }
  }

  // close the http server if it was internally created
  try {
    if (typeof this._closeServer !== &#x27;undefined&#x27;) {
      this._closeServer();
    }
  }
  finally {
    if (this._server) {
      this._server.removeListener(&#x27;listening&#x27;, this._onceServerListening);
      this._server.removeListener(&#x27;error&#x27;, this._onServerError);
      this._server.removeListener(&#x27;upgrade&#x27;, this._onServerUpgrade);
    }
    delete this._server;
  }
  if(callback)
    callback(error);
  else if(error)
    throw error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &#x26;&#x26; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.Server.prototype.handleUpgrade" id="apidoc.element.osc.WebSocket.Server.prototype.handleUpgrade">
        function <span class="apidocSignatureSpan">osc.WebSocket.Server.prototype.</span>handleUpgrade
        <span class="apidocSignatureSpan">(req, socket, upgradeHead, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleUpgrade = function (req, socket, upgradeHead, cb) {
  // check for wrong path
  if (this.options.path) {
    var u = url.parse(req.url);
    if (u &#x26;&#x26; u.pathname !== this.options.path) return;
  }

  if (typeof req.headers.upgrade === &#x27;undefined&#x27; || req.headers.upgrade.toLowerCase() !== &#x27;websocket&#x27;) {
    abortConnection(socket, 400, &#x27;Bad Request&#x27;);
    return;
  }

  if (req.headers[&#x27;sec-websocket-key1&#x27;]) handleHixieUpgrade.apply(this, arguments);
  else handleHybiUpgrade.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocket.prototype" id="apidoc.module.osc.WebSocket.prototype">module osc.WebSocket.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.addEventListener" id="apidoc.element.osc.WebSocket.prototype.addEventListener">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>addEventListener
        <span class="apidocSignatureSpan">(method, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addEventListener = function (method, listener) {
  var target = this;

  function onMessage (data, flags) {
    if (flags.binary &#x26;&#x26; this.binaryType === &#x27;arraybuffer&#x27;)
        data = new Uint8Array(data).buffer;
    listener.call(target, new MessageEvent(data, !!flags.binary, target));
  }

  function onClose (code, message) {
    listener.call(target, new CloseEvent(code, message, target));
  }

  function onError (event) {
    event.type = &#x27;error&#x27;;
    event.target = target;
    listener.call(target, event);
  }

  function onOpen () {
    listener.call(target, new OpenEvent(target));
  }

  if (typeof listener === &#x27;function&#x27;) {
    if (method === &#x27;message&#x27;) {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onMessage._listener = listener;
      this.on(method, onMessage);
    } else if (method === &#x27;close&#x27;) {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onClose._listener = listener;
      this.on(method, onClose);
    } else if (method === &#x27;error&#x27;) {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onError._listener = listener;
      this.on(method, onError);
    } else if (method === &#x27;open&#x27;) {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onOpen._listener = listener;
      this.on(method, onOpen);
    } else {
      this.on(method, listener);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.close" id="apidoc.element.osc.WebSocket.prototype.close">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>close
        <span class="apidocSignatureSpan">(code, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function close(code, data) {
  if (this.readyState === WebSocket.CLOSED) return;

  if (this.readyState === WebSocket.CONNECTING) {
    this.readyState = WebSocket.CLOSED;
    return;
  }

  if (this.readyState === WebSocket.CLOSING) {
    if (this._closeReceived &#x26;&#x26; this._isServer) {
      this.terminate();
    }
    return;
  }

  var self = this;
  try {
    this.readyState = WebSocket.CLOSING;
    this._closeCode = code;
    this._closeMessage = data;
    var mask = !this._isServer;
    this._sender.close(code, data, mask, function(err) {
      if (err) self.emit(&#x27;error&#x27;, err);

      if (self._closeReceived &#x26;&#x26; self._isServer) {
        self.terminate();
      } else {
        // ensure that the connection is cleaned up even when no response of closing handshake.
        clearTimeout(self._closeTimer);
        self._closeTimer = setTimeout(cleanupWebsocketResources.bind(self, true), closeTimeout);
      }
    });
  } catch (e) {
    this.emit(&#x27;error&#x27;, e);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &#x26;&#x26; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.pause" id="apidoc.element.osc.WebSocket.prototype.pause">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pauser() {
  if (this.readyState !== WebSocket.OPEN) throw new Error(&#x27;not opened&#x27;);

  return this._socket.pause();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.ping" id="apidoc.element.osc.WebSocket.prototype.ping">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>ping
        <span class="apidocSignatureSpan">(data, options, dontFailWhenClosed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ping(data, options, dontFailWhenClosed) {
  if (this.readyState !== WebSocket.OPEN) {
    if (dontFailWhenClosed === true) return;
    throw new Error(&#x27;not opened&#x27;);
  }

  options = options || {};

  if (typeof options.mask === &#x27;undefined&#x27;) options.mask = !this._isServer;

  this._sender.ping(data, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.pong" id="apidoc.element.osc.WebSocket.prototype.pong">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>pong
        <span class="apidocSignatureSpan">(data, options, dontFailWhenClosed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pong = function (data, options, dontFailWhenClosed) {
  if (this.readyState !== WebSocket.OPEN) {
    if (dontFailWhenClosed === true) return;
    throw new Error(&#x27;not opened&#x27;);
  }

  options = options || {};

  if (typeof options.mask === &#x27;undefined&#x27;) options.mask = !this._isServer;

  this._sender.pong(data, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.resume" id="apidoc.element.osc.WebSocket.prototype.resume">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resume() {
  if (this.readyState !== WebSocket.OPEN) throw new Error(&#x27;not opened&#x27;);

  return this._socket.resume();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.send" id="apidoc.element.osc.WebSocket.prototype.send">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>send
        <span class="apidocSignatureSpan">(data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function send(data, options, cb) {
  if (typeof options === &#x27;function&#x27;) {
    cb = options;
    options = {};
  }

  if (this.readyState !== WebSocket.OPEN) {
    if (typeof cb === &#x27;function&#x27;) cb(new Error(&#x27;not opened&#x27;));
    else throw new Error(&#x27;not opened&#x27;);
    return;
  }

  if (!data) data = &#x27;&#x27;;
  if (this._queue) {
    var self = this;
    this._queue.push(function() { self.send(data, options, cb); });
    return;
  }

  options = options || {};
  options.fin = true;

  if (typeof options.binary === &#x27;undefined&#x27;) {
    options.binary = (data instanceof ArrayBuffer || data instanceof Buffer ||
      data instanceof Uint8Array ||
      data instanceof Uint16Array ||
      data instanceof Uint32Array ||
      data instanceof Int8Array ||
      data instanceof Int16Array ||
      data instanceof Int32Array ||
      data instanceof Float32Array ||
      data instanceof Float64Array);
  }

  if (typeof options.mask === &#x27;undefined&#x27;) options.mask = !this._isServer;
  if (typeof options.compress === &#x27;undefined&#x27;) options.compress = true;
  if (!this.extensions[PerMessageDeflate.extensionName]) {
    options.compress = false;
  }

  var readable = typeof stream.Readable === &#x27;function&#x27;
    ? stream.Readable
    : stream.Stream;

  if (data instanceof readable) {
    startQueue(this);
    var self = this;

    sendStream(this, data, options, function send(error) {
      process.nextTick(function tock() {
        executeQueueSends(self);
      });

      if (typeof cb === &#x27;function&#x27;) cb(error);
    });
  } else {
    this._sender.send(data, options, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

##### Sending OSC messages:
```javascript
// For most Ports, send() should only be called after the &#x22;ready&#x22; event fires.
oscPort.on(&#x22;ready&#x22;, function () {
    oscPort.<span class="apidocCodeKeywordSpan">send</span>({
        address: &#x22;/carrier/frequency&#x22;,
        args: 440
    });
});
```

##### Sending OSC bundles:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.stream" id="apidoc.element.osc.WebSocket.prototype.stream">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>stream
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stream(options, cb) {
  if (typeof options === &#x27;function&#x27;) {
    cb = options;
    options = {};
  }

  var self = this;

  if (typeof cb !== &#x27;function&#x27;) throw new Error(&#x27;callback must be provided&#x27;);

  if (this.readyState !== WebSocket.OPEN) {
    if (typeof cb === &#x27;function&#x27;) cb(new Error(&#x27;not opened&#x27;));
    else throw new Error(&#x27;not opened&#x27;);
    return;
  }

  if (this._queue) {
    this._queue.push(function () { self.stream(options, cb); });
    return;
  }

  options = options || {};

  if (typeof options.mask === &#x27;undefined&#x27;) options.mask = !this._isServer;
  if (typeof options.compress === &#x27;undefined&#x27;) options.compress = true;
  if (!this.extensions[PerMessageDeflate.extensionName]) {
    options.compress = false;
  }

  startQueue(this);

  function send(data, final) {
    try {
      if (self.readyState !== WebSocket.OPEN) throw new Error(&#x27;not opened&#x27;);
      options.fin = final === true;
      self._sender.send(data, options);
      if (!final) process.nextTick(cb.bind(null, null, send));
      else executeQueueSends(self);
    } catch (e) {
      if (typeof cb === &#x27;function&#x27;) cb(e);
      else {
        delete self._queue;
        self.emit(&#x27;error&#x27;, e);
      }
    }
  }

  process.nextTick(cb.bind(null, null, send));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocket.prototype.terminate" id="apidoc.element.osc.WebSocket.prototype.terminate">
        function <span class="apidocSignatureSpan">osc.WebSocket.prototype.</span>terminate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function terminate() {
  if (this.readyState === WebSocket.CLOSED) return;

  if (this._socket) {
    this.readyState = WebSocket.CLOSING;

    // End the connection
    try { this._socket.end(); }
    catch (e) {
      // Socket error during end() call, so just destroy it right now
      cleanupWebsocketResources.call(this, true);
      return;
    }

    // Add a timeout to ensure that the connection is completely
    // cleaned up within 30 seconds, even if the clean close procedure
    // fails for whatever reason
    // First cleanup any pre-existing timeout from an earlier &#x22;terminate&#x22; call,
    // if one exists.  Otherwise terminate calls in quick succession will leak timeouts
    // and hold the program open for `closeTimout` time.
    if (this._closeTimer) { clearTimeout(this._closeTimer); }
    this._closeTimer = setTimeout(cleanupWebsocketResources.bind(this, true), closeTimeout);
  } else if (this.readyState === WebSocket.CONNECTING) {
    cleanupWebsocketResources.call(this, true);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocketPort" id="apidoc.module.osc.WebSocketPort">module osc.WebSocketPort</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.WebSocketPort" id="apidoc.element.osc.WebSocketPort.WebSocketPort">
        function <span class="apidocSignatureSpan">osc.</span>WebSocketPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocketPort = function (options) {
    osc.Port.call(this, options);
    this.on(&#x22;open&#x22;, this.listen.bind(this));

    this.socket = options.socket;
    if (this.socket) {
        if (this.socket.readyState === 1) {
            osc.WebSocketPort.setupSocketForBinary(this.socket);
            this.emit(&#x22;open&#x22;, this.socket);
        } else {
            this.open();
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x3c;/head&#x3e;
    &#x3c;body&#x3e;&#x3c;/body&#x3e;
&#x3c;/html&#x3e;
```

##### Creating an OSC Web Socket Port object:
```javascript
var oscPort = new osc.<span class="apidocCodeKeywordSpan">WebSocketPort</span>({
    url: &#x22;ws://localhost:8081&#x22; // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.open();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.setupSocketForBinary" id="apidoc.element.osc.WebSocketPort.setupSocketForBinary">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.</span>setupSocketForBinary
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupSocketForBinary = function (socket) {
    socket.binaryType = osc.isNode ? &#x22;nodebuffer&#x22; : &#x22;arraybuffer&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
osc.WebSocketPort = function (options) {
    osc.Port.call(this, options);
    this.on(&#x22;open&#x22;, this.listen.bind(this));

    this.socket = options.socket;
    if (this.socket) {
        if (this.socket.readyState === 1) {
            osc.WebSocketPort.<span class="apidocCodeKeywordSpan">setupSocketForBinary</span>(this.socket);
            this.emit(&#x22;open&#x22;, this.socket);
        } else {
            this.open();
        }
    }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.WebSocketPort.prototype" id="apidoc.module.osc.WebSocketPort.prototype">module osc.WebSocketPort.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.close" id="apidoc.element.osc.WebSocketPort.prototype.close">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>close
        <span class="apidocSignatureSpan">(code, reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (code, reason) {
    this.socket.close(code, reason);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    p.open = function () {
this.port1.open();
this.port2.open();
    };

    p.listen = function () {
if (this.port1Spec &#x26;&#x26; this.port2Spec) {
    this.<span class="apidocCodeKeywordSpan">close</span>();
}

this.port1Spec = osc.relayPorts(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.constructor" id="apidoc.element.osc.WebSocketPort.prototype.constructor">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (options) {
    osc.Port.call(this, options);
    this.on(&#x22;open&#x22;, this.listen.bind(this));

    this.socket = options.socket;
    if (this.socket) {
        if (this.socket.readyState === 1) {
            osc.WebSocketPort.setupSocketForBinary(this.socket);
            this.emit(&#x22;open&#x22;, this.socket);
        } else {
            this.open();
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.listen" id="apidoc.element.osc.WebSocketPort.prototype.listen">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>listen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function () {
    var that = this;
    this.socket.onmessage = function (e) {
        that.emit(&#x22;data&#x22;, e.data, e);
    };

    this.socket.onerror = function (err) {
        that.emit(&#x22;error&#x22;, err);
    };

    this.socket.onclose = function (e) {
        that.emit(&#x22;close&#x22;, e);
    };

    that.emit(&#x22;ready&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var osc = require(&#x22;osc&#x22;),
    http = require(&#x22;http&#x22;),
    WebSocket = require(&#x22;ws&#x22;);

// Create an Express server app
// and serve up a directory of static files.
var app = require(&#x22;express&#x22;).express(),
    server = app.<span class="apidocCodeKeywordSpan">listen</span>(8081);

app.use(&#x22;/&#x22;, express.static(__dirname + &#x22;/static&#x22;));

// Listen for Web Socket requests.
var wss = new WebSocket.Server({
    server: server
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.open" id="apidoc.element.osc.WebSocketPort.prototype.open">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
    if (!this.socket || this.socket.readyState &#x3e; 1) {
        this.socket = new osc.WebSocket(this.options.url);
    }

    osc.WebSocketPort.setupSocketForBinary(this.socket);

    var that = this;
    this.socket.onopen = function () {
        that.emit(&#x22;open&#x22;, that.socket);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oscPort = new osc.WebSocketPort({
    url: &#x22;ws://localhost:8081&#x22; // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.<span class="apidocCodeKeywordSpan">open</span>();
```

##### Listening for incoming OSC messages:
```javascript
oscPort.on(&#x22;message&#x22;, function (oscMsg) {
    console.log(&#x22;An OSC message just arrived!&#x22;, oscMsg);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.WebSocketPort.prototype.sendRaw" id="apidoc.element.osc.WebSocketPort.prototype.sendRaw">
        function <span class="apidocSignatureSpan">osc.WebSocketPort.prototype.</span>sendRaw
        <span class="apidocSignatureSpan">(encoded)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendRaw = function (encoded) {
    if (!this.socket || this.socket.readyState !== 1) {
        osc.fireClosedPortSendError(this);
        return;
    }

    this.socket.send(encoded);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.osc.osc" id="apidoc.module.osc.osc">module osc.osc</a></h1>










    <h2>
        <a href="#apidoc.element.osc.osc.Port" id="apidoc.element.osc.osc.Port">
        function <span class="apidocSignatureSpan">osc.osc.</span>Port
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Port = function (options) {
    this.options = options || {};
    this.on(&#x22;data&#x22;, this.decodeOSC.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.Relay" id="apidoc.element.osc.osc.Relay">
        function <span class="apidocSignatureSpan">osc.osc.</span>Relay
        <span class="apidocSignatureSpan">(port1, port2, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Relay = function (port1, port2, options) {
    var o = this.options = options || {};
    o.raw = false;

    this.port1 = port1;
    this.port2 = port2;

    this.listen();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.SLIPPort" id="apidoc.element.osc.osc.SLIPPort">
        function <span class="apidocSignatureSpan">osc.osc.</span>SLIPPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SLIPPort = function (options) {
    var that = this;
    var o = this.options = options || {};
    o.useSLIP = o.useSLIP === undefined ? true : o.useSLIP;

    this.decoder = new slip.Decoder({
        onMessage: this.decodeOSC.bind(this),
        onError: function (err) {
            that.emit(&#x22;error&#x22;, err);
        }
    });

    var decodeHandler = o.useSLIP ? this.decodeSLIPData : this.decodeOSC;
    this.on(&#x22;data&#x22;, decodeHandler.bind(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.WebSocket" id="apidoc.element.osc.osc.WebSocket">
        function <span class="apidocSignatureSpan">osc.osc.</span>WebSocket
        <span class="apidocSignatureSpan">(address, protocols, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocket(address, protocols, options) {
  if (this instanceof WebSocket === false) {
    return new WebSocket(address, protocols, options);
  }

  EventEmitter.call(this);

  if (protocols &#x26;&#x26; !Array.isArray(protocols) &#x26;&#x26; &#x27;object&#x27; === typeof protocols) {
    // accept the &#x22;options&#x22; Object as the 2nd argument
    options = protocols;
    protocols = null;
  }

  if (&#x27;string&#x27; === typeof protocols) {
    protocols = [ protocols ];
  }

  if (!Array.isArray(protocols)) {
    protocols = [];
  }

  this._socket = null;
  this._ultron = null;
  this._closeReceived = false;
  this.bytesReceived = 0;
  this.readyState = null;
  this.supports = {};
  this.extensions = {};
  this._binaryType = &#x27;nodebuffer&#x27;;

  if (Array.isArray(address)) {
    initAsServerClient.apply(this, address.concat(options));
  } else {
    initAsClient.apply(this, [address, protocols, options]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };

    var p = osc.WebSocketPort.prototype = Object.create(osc.Port.prototype);
    p.constructor = osc.WebSocketPort;

    p.open = function () {
if (!this.socket || this.socket.readyState &#x3e; 1) {
    this.socket = new osc.<span class="apidocCodeKeywordSpan">WebSocket</span>(this.options.url);
}

osc.WebSocketPort.setupSocketForBinary(this.socket);

var that = this;
this.socket.onopen = function () {
    that.emit(&#x22;open&#x22;, that.socket);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.WebSocketPort" id="apidoc.element.osc.osc.WebSocketPort">
        function <span class="apidocSignatureSpan">osc.osc.</span>WebSocketPort
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">WebSocketPort = function (options) {
    osc.Port.call(this, options);
    this.on(&#x22;open&#x22;, this.listen.bind(this));

    this.socket = options.socket;
    if (this.socket) {
        if (this.socket.readyState === 1) {
            osc.WebSocketPort.setupSocketForBinary(this.socket);
            this.emit(&#x22;open&#x22;, this.socket);
        } else {
            this.open();
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x3c;/head&#x3e;
    &#x3c;body&#x3e;&#x3c;/body&#x3e;
&#x3c;/html&#x3e;
```

##### Creating an OSC Web Socket Port object:
```javascript
var oscPort = new osc.<span class="apidocCodeKeywordSpan">WebSocketPort</span>({
    url: &#x22;ws://localhost:8081&#x22; // URL to your Web Socket server.
});
```

##### Opening the Port:
```javascript
oscPort.open();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.addDataPart" id="apidoc.element.osc.osc.addDataPart">
        function <span class="apidocSignatureSpan">osc.osc.</span>addDataPart
        <span class="apidocSignatureSpan">(dataPart, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addDataPart = function (dataPart, dataCollection) {
    dataCollection.parts.push(dataPart);
    dataCollection.byteLength += dataPart.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    var type = arg.type,
        writer = osc.argumentTypes[type].writer;

    if (writer) {
        var data = osc[writer](arg.value);
        osc.<span class="apidocCodeKeywordSpan">addDataPart</span>(data, dataCollection);
    }

    return arg.type;
};

// Unsupported, non-API function.
osc.collectArguments = function (args, options, dataCollection) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.annotateArguments" id="apidoc.element.osc.osc.annotateArguments">
        function <span class="apidocSignatureSpan">osc.osc.</span>annotateArguments
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">annotateArguments = function (args) {
    var annotated = [];

    for (var i = 0; i &#x3c; args.length; i++) {
        var arg = args[i],
            msgArg;

        if (typeof (arg) === &#x22;object&#x22; &#x26;&#x26; arg.type &#x26;&#x26; arg.value !== undefined) {
            // We&#x27;ve got an explicitly typed argument.
            msgArg = arg;
        } else if (osc.isArray(arg)) {
            // We&#x27;ve got an array of arguments,
            // so they each need to be inferred and expanded.
            msgArg = osc.annotateArguments(arg);
        } else {
            var oscType = osc.inferTypeForArgument(arg);
            msgArg = {
                type: oscType,
                value: arg
            };
        }

        annotated.push(msgArg);
    }

    return annotated;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

dataCollection = dataCollection || {
    byteLength: 0,
    parts: []
};

if (!options.metadata) {
    args = osc.<span class="apidocCodeKeywordSpan">annotateArguments</span>(args);
}

var typeTagString = &#x22;,&#x22;,
    currPartIdx = dataCollection.parts.length;

for (var i = 0; i &#x3c; args.length; i++) {
    var arg = args[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.byteArray" id="apidoc.element.osc.osc.byteArray">
        function <span class="apidocSignatureSpan">osc.osc.</span>byteArray
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">byteArray = function (obj) {
    if (obj instanceof Uint8Array) {
        return obj;
    }

    var buf = obj.buffer ? obj.buffer : obj;

    if (!(buf instanceof ArrayBuffer) &#x26;&#x26; (typeof buf.length === &#x22;undefined&#x22; || typeof buf === &#x22;string&#x22;)) {
        throw new Error(&#x22;Can&#x27;t wrap a non-array-like object as Uint8Array. Object was: &#x22; +
            JSON.stringify(obj, null, 2));
    }


    // TODO gh-39: This is a potentially unsafe algorithm;
    // if we&#x27;re getting anything other than a TypedArrayView (such as a DataView),
    // we really need to determine the range of the view it is viewing.
    return new Uint8Array(buf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    /**
     * Writes a raw collection of bytes to a new ArrayBuffer.
     *
     * @param {Array-like} data a collection of octets
     * @return {ArrayBuffer} a buffer containing the OSC-formatted blob
     */
    osc.writeBlob = function (data) {
data = osc.<span class="apidocCodeKeywordSpan">byteArray</span>(data);

var len = data.byteLength,
    paddedLen = (len + 3) &#x26; ~0x03,
    offset = 4, // Extra 4 bytes is for the size.
    blobLen = paddedLen + offset,
    arr = new Uint8Array(blobLen),
    dv = new DataView(arr.buffer);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.collectArguments" id="apidoc.element.osc.osc.collectArguments">
        function <span class="apidocSignatureSpan">osc.osc.</span>collectArguments
        <span class="apidocSignatureSpan">(args, options, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectArguments = function (args, options, dataCollection) {
    if (!osc.isArray(args)) {
        args = typeof args === &#x22;undefined&#x22; ? [] : [args];
    }

    dataCollection = dataCollection || {
        byteLength: 0,
        parts: []
    };

    if (!options.metadata) {
        args = osc.annotateArguments(args);
    }

    var typeTagString = &#x22;,&#x22;,
        currPartIdx = dataCollection.parts.length;

    for (var i = 0; i &#x3c; args.length; i++) {
        var arg = args[i];
        typeTagString += osc.writeArgument(arg, dataCollection);
    }

    var typeData = osc.writeString(typeTagString);
    dataCollection.byteLength += typeData.byteLength;
    dataCollection.parts.splice(currPartIdx, 0, typeData);

    return dataCollection;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Writes the specified arguments.
 *
 * @param {Array} args an array of arguments
 * @param {Object} options options for writing
 * @return {Uint8Array} a buffer containing the OSC-formatted argument type tag and values
 */
osc.writeArguments = function (args, options) {
    var argCollection = osc.<span class="apidocCodeKeywordSpan">collectArguments</span>(args, options);
    return osc.joinParts(argCollection);
};

// Unsupported, non-API function.
osc.joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.collectBundlePackets" id="apidoc.element.osc.osc.collectBundlePackets">
        function <span class="apidocSignatureSpan">osc.osc.</span>collectBundlePackets
        <span class="apidocSignatureSpan">(bundle, options, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectBundlePackets = function (bundle, options, dataCollection) {
    dataCollection = dataCollection || {
        byteLength: 0,
        parts: []
    };

    osc.addDataPart(osc.writeString(&#x22;#bundle&#x22;), dataCollection);
    osc.addDataPart(osc.writeTimeTag(bundle.timeTag), dataCollection);

    for (var i = 0; i &#x3c; bundle.packets.length; i++) {
        var packet = bundle.packets[i],
            collector = packet.address ? osc.collectMessageParts : osc.collectBundlePackets,
            packetCollection = collector(packet, options);

        dataCollection.byteLength += packetCollection.byteLength;
        osc.addDataPart(osc.writeInt32(packetCollection.byteLength), dataCollection);
        dataCollection.parts = dataCollection.parts.concat(packetCollection.parts);
    }

    return dataCollection;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
osc.writeBundle = function (bundle, options) {
    if (!osc.isValidBundle(bundle)) {
        throw new Error(&#x22;An OSC bundle must contain &#x27;timeTag&#x27; and &#x27;packets&#x27; properties. &#x22; +
            &#x22;Bundle was: &#x22; + JSON.stringify(bundle, null, 2));
    }

    options = options || osc.defaults;
    var bundleCollection = osc.<span class="apidocCodeKeywordSpan">collectBundlePackets</span>(bundle, options);

    return osc.joinParts(bundleCollection);
};

osc.isValidBundle = function (bundle) {
    return bundle.timeTag !== undefined &#x26;&#x26; bundle.packets !== undefined;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.collectMessageParts" id="apidoc.element.osc.osc.collectMessageParts">
        function <span class="apidocSignatureSpan">osc.osc.</span>collectMessageParts
        <span class="apidocSignatureSpan">(msg, options, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collectMessageParts = function (msg, options, dataCollection) {
    dataCollection = dataCollection || {
        byteLength: 0,
        parts: []
    };

    osc.addDataPart(osc.writeString(msg.address), dataCollection);
    return osc.collectArguments(msg.args, options, dataCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    options = options || osc.defaults;

    if (!osc.isValidMessage(msg)) {
        throw new Error(&#x22;An OSC message must contain a valid address. Message was: &#x22; +
            JSON.stringify(msg, null, 2));
    }

    var msgCollection = osc.<span class="apidocCodeKeywordSpan">collectMessageParts</span>(msg, options);
    return osc.joinParts(msgCollection);
};

osc.isValidMessage = function (msg) {
    return msg.address &#x26;&#x26; msg.address.indexOf(&#x22;/&#x22;) === 0;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.copyByteArray" id="apidoc.element.osc.osc.copyByteArray">
        function <span class="apidocSignatureSpan">osc.osc.</span>copyByteArray
        <span class="apidocSignatureSpan">(source, target, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copyByteArray = function (source, target, offset) {
    if (osc.isTypedArrayView(source) &#x26;&#x26; osc.isTypedArrayView(target)) {
        target.set(source, offset);
    } else {
        var start = offset === undefined ? 0 : offset,
            len = Math.min(target.length - offset, source.length);

        for (var i = 0, j = start; i &#x3c; len; i++, j++) {
            target[j] = source[i];
        }
    }

    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
osc.joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
        offset = 0;

    for (var i = 0; i &#x3c; parts.length; i++) {
        var part = parts[i];
        osc.<span class="apidocCodeKeywordSpan">copyByteArray</span>(part, buf, offset);
        offset += part.length;
    }

    return buf;
};

// Unsupported, non-API function.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.dataView" id="apidoc.element.osc.osc.dataView">
        function <span class="apidocSignatureSpan">osc.osc.</span>dataView
        <span class="apidocSignatureSpan">(obj, offset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dataView = function (obj, offset, length) {
    if (obj.buffer) {
        return new DataView(obj.buffer, offset, length);
    }

    if (obj instanceof ArrayBuffer) {
        return new DataView(obj, offset, length);
    }

    return new DataView(new Uint8Array(obj), offset, length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} [options] read options
 * @param {Object} [offsetState] an offsetState object that stores the current offset into dv
 * @return {Object} the OSC message, formatted as a JavaScript object containing &#x22;address&#x22; and &#x22;args&#x22; properties
 */
osc.readMessage = function (data, options, offsetState) {
    options = options || osc.defaults;

    var dv = osc.<span class="apidocCodeKeywordSpan">dataView</span>(data, data.byteOffset, data.byteLength);
    offsetState = offsetState || {
        idx: 0
    };

    var address = osc.readString(dv, offsetState);
    return osc.readMessageContents(address, dv, options, offsetState);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.fireBundleEvents" id="apidoc.element.osc.osc.fireBundleEvents">
        function <span class="apidocSignatureSpan">osc.osc.</span>fireBundleEvents
        <span class="apidocSignatureSpan">(port, bundle, timeTag, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fireBundleEvents = function (port, bundle, timeTag, packetInfo) {
    port.emit(&#x22;bundle&#x22;, bundle, timeTag, packetInfo);
    for (var i = 0; i &#x3c; bundle.packets.length; i++) {
        var packet = bundle.packets[i];
        osc.firePacketEvents(port, packet, bundle.timeTag, packetInfo);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x22;use strict&#x22;;

// Unsupported, non-API function.
osc.firePacketEvents = function (port, packet, timeTag, packetInfo) {
    if (packet.address) {
        port.emit(&#x22;message&#x22;, packet, timeTag, packetInfo);
    } else {
        osc.<span class="apidocCodeKeywordSpan">fireBundleEvents</span>(port, packet, timeTag, packetInfo);
    }
};

// Unsupported, non-API function.
osc.fireBundleEvents = function (port, bundle, timeTag, packetInfo) {
    port.emit(&#x22;bundle&#x22;, bundle, timeTag, packetInfo);
    for (var i = 0; i &#x3c; bundle.packets.length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.fireClosedPortSendError" id="apidoc.element.osc.osc.fireClosedPortSendError">
        function <span class="apidocSignatureSpan">osc.osc.</span>fireClosedPortSendError
        <span class="apidocSignatureSpan">(port, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fireClosedPortSendError = function (port, msg) {
    msg = msg || &#x22;Can&#x27;t send packets on a closed osc.Port object. Please open (or reopen) this Port by calling open().&#x22;;

    port.emit(&#x22;error&#x22;, msg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    p.listen = function () {
osc.listenToTransport(this, chrome.serial, &#x22;connectionId&#x22;);
    };

    p.sendRaw = function (encoded) {
if (!this.connectionId) {
    osc.<span class="apidocCodeKeywordSpan">fireClosedPortSendError</span>(this);
    return;
}

var that = this;

// TODO gh-39: This is unsafe; we should only access the underlying
// buffer within the range of its view.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.firePacketEvents" id="apidoc.element.osc.osc.firePacketEvents">
        function <span class="apidocSignatureSpan">osc.osc.</span>firePacketEvents
        <span class="apidocSignatureSpan">(port, packet, timeTag, packetInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">firePacketEvents = function (port, packet, timeTag, packetInfo) {
    if (packet.address) {
        port.emit(&#x22;message&#x22;, packet, timeTag, packetInfo);
    } else {
        osc.fireBundleEvents(port, packet, timeTag, packetInfo);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };

    // Unsupported, non-API function.
    osc.fireBundleEvents = function (port, bundle, timeTag, packetInfo) {
port.emit(&#x22;bundle&#x22;, bundle, timeTag, packetInfo);
for (var i = 0; i &#x3c; bundle.packets.length; i++) {
    var packet = bundle.packets[i];
    osc.<span class="apidocCodeKeywordSpan">firePacketEvents</span>(port, packet, bundle.timeTag, packetInfo);
}
    };

    osc.fireClosedPortSendError = function (port, msg) {
msg = msg || &#x22;Can&#x27;t send packets on a closed osc.Port object. Please open (or reopen) this Port by calling open().&#x22
;;

port.emit(&#x22;error&#x22;, msg);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.inferTypeForArgument" id="apidoc.element.osc.osc.inferTypeForArgument">
        function <span class="apidocSignatureSpan">osc.osc.</span>inferTypeForArgument
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inferTypeForArgument = function (arg) {
    var type = typeof arg;

    // TODO: This is freaking hideous.
    switch (type) {
        case &#x22;boolean&#x22;:
            return arg ? &#x22;T&#x22; : &#x22;F&#x22;;
        case &#x22;string&#x22;:
            return &#x22;s&#x22;;
        case &#x22;number&#x22;:
            return &#x22;f&#x22;;
        case &#x22;undefined&#x22;:
            return &#x22;N&#x22;;
        case &#x22;object&#x22;:
            if (arg === null) {
                return &#x22;N&#x22;;
            } else if (arg instanceof Uint8Array ||
                arg instanceof ArrayBuffer) {
                return &#x22;b&#x22;;
            } else if (typeof arg.high === &#x22;number&#x22; &#x26;&#x26; typeof arg.low === &#x22;number&#x22;) {
                return &#x22;h&#x22;;
            }
            break;
    }

    throw new Error(&#x22;Can&#x27;t infer OSC argument type for value: &#x22; +
        JSON.stringify(arg, null, 2));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // We&#x27;ve got an explicitly typed argument.
    msgArg = arg;
} else if (osc.isArray(arg)) {
    // We&#x27;ve got an array of arguments,
    // so they each need to be inferred and expanded.
    msgArg = osc.annotateArguments(arg);
} else {
    var oscType = osc.<span class="apidocCodeKeywordSpan">inferTypeForArgument</span>(arg);
    msgArg = {
        type: oscType,
        value: arg
    };
}

annotated.push(msgArg);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.isArray" id="apidoc.element.osc.osc.isArray">
        function <span class="apidocSignatureSpan">osc.osc.</span>isArray
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (obj) {
    return obj &#x26;&#x26; Object.prototype.toString.call(obj) === &#x22;[object Array]&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

typeTag += &#x22;]&#x22;;

return typeTag;
    };

    osc.writeArgument = function (arg, dataCollection) {
if (osc.<span class="apidocCodeKeywordSpan">isArray</span>(arg)) {
    return osc.writeArrayArguments(arg, dataCollection);
}

var type = arg.type,
    writer = osc.argumentTypes[type].writer;

if (writer) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.isBuffer" id="apidoc.element.osc.osc.isBuffer">
        function <span class="apidocSignatureSpan">osc.osc.</span>isBuffer
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBuffer = function (obj) {
    return osc.isBufferEnv &#x26;&#x26; obj instanceof Buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Array-like or Array-wrapping} obj an array-like or array-wrapping object
 * @returns {Buffer|Uint8Array} a buffer object
 */
// Unsupported, non-API function.
osc.nativeBuffer = function (obj) {
    if (osc.isBufferEnv) {
        return osc.<span class="apidocCodeKeywordSpan">isBuffer</span>(obj) ? obj :
            new Buffer(obj.buffer ? obj : new Uint8Array(obj));
    }

    return osc.isTypedArrayView(obj) ? obj : new Uint8Array(obj);
};

// Unsupported, non-API function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.isTypedArrayView" id="apidoc.element.osc.osc.isTypedArrayView">
        function <span class="apidocSignatureSpan">osc.osc.</span>isTypedArrayView
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isTypedArrayView = function (obj) {
    return obj.buffer &#x26;&#x26; obj.buffer instanceof ArrayBuffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Unsupported, non-API function.
osc.nativeBuffer = function (obj) {
    if (osc.isBufferEnv) {
        return osc.isBuffer(obj) ? obj :
            new Buffer(obj.buffer ? obj : new Uint8Array(obj));
    }

    return osc.<span class="apidocCodeKeywordSpan">isTypedArrayView</span>(obj) ? obj : new Uint8Array(obj);
};

// Unsupported, non-API function
osc.copyByteArray = function (source, target, offset) {
    if (osc.isTypedArrayView(source) &#x26;&#x26; osc.isTypedArrayView(target)) {
        target.set(source, offset);
    } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.isValidBundle" id="apidoc.element.osc.osc.isValidBundle">
        function <span class="apidocSignatureSpan">osc.osc.</span>isValidBundle
        <span class="apidocSignatureSpan">(bundle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidBundle = function (bundle) {
    return bundle.timeTag !== undefined &#x26;&#x26; bundle.packets !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * Writes an OSC bundle.
     *
     * @param {Object} a bundle object containing &#x22;timeTag&#x22; and &#x22;packets&#x22; properties
     * @param {object} [options] write options
     * @return {Uint8Array} an array of bytes containing the message
     */
    osc.writeBundle = function (bundle, options) {
if (!osc.<span class="apidocCodeKeywordSpan">isValidBundle</span>(bundle)) {
    throw new Error(&#x22;An OSC bundle must contain &#x27;timeTag&#x27; and &#x27;packets&#x27; properties. &#x22; +
        &#x22;Bundle was: &#x22; + JSON.stringify(bundle, null, 2));
}

options = options || osc.defaults;
var bundleCollection = osc.collectBundlePackets(bundle, options);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.isValidMessage" id="apidoc.element.osc.osc.isValidMessage">
        function <span class="apidocSignatureSpan">osc.osc.</span>isValidMessage
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidMessage = function (msg) {
    return msg.address &#x26;&#x26; msg.address.indexOf(&#x22;/&#x22;) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} msg a message object containing &#x22;address&#x22; and &#x22;args&#x22; properties
 * @param {Object} [options] write options
 * @return {Uint8Array} an array of bytes containing the OSC message
 */
osc.writeMessage = function (msg, options) {
    options = options || osc.defaults;

    if (!osc.<span class="apidocCodeKeywordSpan">isValidMessage</span>(msg)) {
        throw new Error(&#x22;An OSC message must contain a valid address. Message was: &#x22; +
            JSON.stringify(msg, null, 2));
    }

    var msgCollection = osc.collectMessageParts(msg, options);
    return osc.joinParts(msgCollection);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.joinParts" id="apidoc.element.osc.osc.joinParts">
        function <span class="apidocSignatureSpan">osc.osc.</span>joinParts
        <span class="apidocSignatureSpan">(dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
        offset = 0;

    for (var i = 0; i &#x3c; parts.length; i++) {
        var part = parts[i];
        osc.copyByteArray(part, buf, offset);
        offset += part.length;
    }

    return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Array} args an array of arguments
 * @param {Object} options options for writing
 * @return {Uint8Array} a buffer containing the OSC-formatted argument type tag and values
 */
osc.writeArguments = function (args, options) {
    var argCollection = osc.collectArguments(args, options);
    return osc.<span class="apidocCodeKeywordSpan">joinParts</span>(argCollection);
};

// Unsupported, non-API function.
osc.joinParts = function (dataCollection) {
    var buf = new Uint8Array(dataCollection.byteLength),
        parts = dataCollection.parts,
        offset = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.jsToNTPTime" id="apidoc.element.osc.osc.jsToNTPTime">
        function <span class="apidocSignatureSpan">osc.osc.</span>jsToNTPTime
        <span class="apidocSignatureSpan">(jsTime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsToNTPTime = function (jsTime) {
    var secs = jsTime / 1000,
        secsWhole = Math.floor(secs),
        secsFrac = secs - secsWhole,
        ntpSecs = secsWhole + osc.SECS_70YRS,
        ntpFracs = Math.round(osc.TWO_32 * secsFrac);

    return [ntpSecs, ntpFracs];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * values. The first represents the number of seconds since January 1, 1900; the second, fractions of a second.
     * &#x22;Native&#x22; JavaScript timestamps are specified as a Number representing milliseconds since January 1, 1970.
     *
     * @param {Object} timeTag time tag object containing either a native JS timestamp (in ms) or a NTP timestamp pair
     * @return {Uint8Array} raw bytes for the written time tag
     */
    osc.writeTimeTag = function (timeTag) {
var raw = timeTag.raw ? timeTag.raw : osc.<span class="apidocCodeKeywordSpan">jsToNTPTime</span>(timeTag.native),
    arr = new Uint8Array(8), // Two Unit32s.
    dv = new DataView(arr.buffer);

osc.writeInt32(raw[0], dv, 0);
osc.writeInt32(raw[1], dv, 4);

return arr;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.nativeBuffer" id="apidoc.element.osc.osc.nativeBuffer">
        function <span class="apidocSignatureSpan">osc.osc.</span>nativeBuffer
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nativeBuffer = function (obj) {
    if (osc.isBufferEnv) {
        return osc.isBuffer(obj) ? obj :
            new Buffer(obj.buffer ? obj : new Uint8Array(obj));
    }

    return osc.isTypedArrayView(obj) ? obj : new Uint8Array(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var p = osc.Port.prototype = Object.create(EventEmitter.prototype);
p.constructor = osc.Port;

p.send = function (oscPacket) {
    var args = Array.prototype.slice.call(arguments),
        encoded = this.encodeOSC(oscPacket),
        buf = osc.<span class="apidocCodeKeywordSpan">nativeBuffer</span>(encoded);

    args[0] = buf;
    this.sendRaw.apply(this, args);
};

p.encodeOSC = function (packet) {
    // TODO gh-39: This is unsafe; we should only access the underlying
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.ntpToJSTime" id="apidoc.element.osc.osc.ntpToJSTime">
        function <span class="apidocSignatureSpan">osc.osc.</span>ntpToJSTime
        <span class="apidocSignatureSpan">(secs1900, frac)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ntpToJSTime = function (secs1900, frac) {
    var secs1970 = secs1900 - osc.SECS_70YRS,
        decimals = frac / osc.TWO_32,
        msTime = (secs1970 + decimals) * 1000;

    return msTime;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {DataView} dv the DataView instance to read from
 * @param {Object} offsetState an offset state object containing the current index into dv
 * @param {Object} a time tag object containing both the raw NTP as well as the converted native (i.e. JS/UNIX) time
 */
osc.readTimeTag = function (dv, offsetState) {
    var secs1900 = osc.readPrimitive(dv, &#x22;getUint32&#x22;, 4, offsetState),
        frac = osc.readPrimitive(dv, &#x22;getUint32&#x22;, 4, offsetState),
        native = (secs1900 === 0 &#x26;&#x26; frac === 1) ? Date.now() : osc.<span class="apidocCodeKeywordSpan">ntpToJSTime</span
>(secs1900, frac);

    return {
        raw: [secs1900, frac],
        native: native
    };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readArgument" id="apidoc.element.osc.osc.readArgument">
        function <span class="apidocSignatureSpan">osc.osc.</span>readArgument
        <span class="apidocSignatureSpan">(argType, typeTagString, dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArgument = function (argType, typeTagString, dv, options, offsetState) {
    var typeSpec = osc.argumentTypes[argType];
    if (!typeSpec) {
        throw new Error(&#x22;&#x27;&#x22; + argType + &#x22;&#x27; is not a valid OSC type tag. Type tag string was: &#x22; + typeTagString);
    }

    var argReader = typeSpec.reader,
        arg = osc[argReader](dv, offsetState);

    if (options.metadata) {
        arg = {
            type: argType,
            value: arg
        };
    }

    return arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                &#x22;without a matching close array tag (&#x27;[]&#x27;). Type tag was: &#x22; + typeTagString);
        }

        var typesInArray = fromArrayOpen.slice(0, endArrayIdx);
        arg = osc.readArgumentsIntoArray([], typesInArray, typeTagString, dv, options, offsetState);
        i += endArrayIdx + 2;
    } else {
        arg = osc.<span class="apidocCodeKeywordSpan">readArgument</span>(argType, typeTagString, dv, options, offsetState);
        i++;
    }

    arr.push(arg);
}

return arr;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readArguments" id="apidoc.element.osc.osc.readArguments">
        function <span class="apidocSignatureSpan">osc.osc.</span>readArguments
        <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArguments = function (dv, options, offsetState) {
    var typeTagString = osc.readString(dv, offsetState);
    if (typeTagString.indexOf(&#x22;,&#x22;) !== 0) {
        // Despite what the OSC 1.0 spec says,
        // it just doesn&#x27;t make sense to handle messages without type tags.
        // scsynth appears to read such messages as if they have a single
        // Uint8 argument. sclang throws an error if the type tag is omitted.
        throw new Error(&#x22;A malformed type tag string was found while reading &#x22; +
            &#x22;the arguments of an OSC message. String was: &#x22; +
            typeTagString, &#x22; at offset: &#x22; + offsetState.idx);
    }

    var argTypes = typeTagString.substring(1).split(&#x22;&#x22;),
        args = [];

    osc.readArgumentsIntoArray(args, argTypes, typeTagString, dv, options, offsetState);

    return args;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Unsupported, non-API function.
osc.readMessageContents = function (address, dv, options, offsetState) {
    if (address.indexOf(&#x22;/&#x22;) !== 0) {
        throw new Error(&#x22;A malformed OSC address was found while reading &#x22; +
            &#x22;an OSC message. String was: &#x22; + address);
    }

    var args = osc.<span class="apidocCodeKeywordSpan">readArguments</span>(dv, options, offsetState);

    return {
        address: address,
        args: args.length === 1 &#x26;&#x26; options.unpackSingleArgs ? args[0] : args
    };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readArgumentsIntoArray" id="apidoc.element.osc.osc.readArgumentsIntoArray">
        function <span class="apidocSignatureSpan">osc.osc.</span>readArgumentsIntoArray
        <span class="apidocSignatureSpan">(arr, argTypes, typeTagString, dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readArgumentsIntoArray = function (arr, argTypes, typeTagString, dv, options, offsetState) {
    var i = 0;

    while (i &#x3c; argTypes.length) {
        var argType = argTypes[i],
            arg;

        if (argType === &#x22;[&#x22;) {
            var fromArrayOpen = argTypes.slice(i + 1),
                endArrayIdx = fromArrayOpen.indexOf(&#x22;]&#x22;);

            if (endArrayIdx &#x3c; 0) {
                throw new Error(&#x22;Invalid argument type tag: an open array type tag (&#x27;[&#x27;) was found &#x22; +
                    &#x22;without a matching close array tag (&#x27;[]&#x27;). Type tag was: &#x22; + typeTagString);
            }

            var typesInArray = fromArrayOpen.slice(0, endArrayIdx);
            arg = osc.readArgumentsIntoArray([], typesInArray, typeTagString, dv, options, offsetState);
            i += endArrayIdx + 2;
        } else {
            arg = osc.readArgument(argType, typeTagString, dv, options, offsetState);
            i++;
        }

        arr.push(arg);
    }

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            &#x22;the arguments of an OSC message. String was: &#x22; +
            typeTagString, &#x22; at offset: &#x22; + offsetState.idx);
    }

    var argTypes = typeTagString.substring(1).split(&#x22;&#x22;),
        args = [];

    osc.<span class="apidocCodeKeywordSpan">readArgumentsIntoArray</span>(args, argTypes, typeTagString, dv, options, offsetState
);

    return args;
};

// Unsupported, non-API function.
osc.readArgument = function (argType, typeTagString, dv, options, offsetState) {
    var typeSpec = osc.argumentTypes[argType];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readBlob" id="apidoc.element.osc.osc.readBlob">
        function <span class="apidocSignatureSpan">osc.osc.</span>readBlob
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBlob = function (dv, offsetState) {
    var len = osc.readInt32(dv, offsetState),
        paddedLen = (len + 3) &#x26; ~0x03,
        blob = new Uint8Array(dv.buffer, offsetState.idx, len);

    offsetState.idx += paddedLen;

    return blob;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readBundle" id="apidoc.element.osc.osc.readBundle">
        function <span class="apidocSignatureSpan">osc.osc.</span>readBundle
        <span class="apidocSignatureSpan">(dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBundle = function (dv, options, offsetState) {
    return osc.readPacket(dv, options, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readBundleContents" id="apidoc.element.osc.osc.readBundleContents">
        function <span class="apidocSignatureSpan">osc.osc.</span>readBundleContents
        <span class="apidocSignatureSpan">(dv, options, offsetState, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBundleContents = function (dv, options, offsetState, len) {
    var timeTag = osc.readTimeTag(dv, offsetState),
        packets = [];

    while (offsetState.idx &#x3c; len) {
        var packetSize = osc.readInt32(dv, offsetState),
            packetLen = offsetState.idx + packetSize,
            packet = osc.readPacket(dv, options, offsetState, packetLen);

        packets.push(packet);
    }

    return {
        timeTag: timeTag,
        packets: packets
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        idx: 0
    };

    var header = osc.readString(dv, offsetState),
        firstChar = header[0];

    if (firstChar === &#x22;#&#x22;) {
        return osc.<span class="apidocCodeKeywordSpan">readBundleContents</span>(dv, options, offsetState, len);
    } else if (firstChar === &#x22;/&#x22;) {
        return osc.readMessageContents(header, dv, options, offsetState);
    }

    throw new Error(&#x22;The header of an OSC packet didn&#x27;t contain an OSC address or a #bundle string.&#x22; +
        &#x22; Header was: &#x22; + header);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readChar32" id="apidoc.element.osc.osc.readChar32">
        function <span class="apidocSignatureSpan">osc.osc.</span>readChar32
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readChar32 = function (dv, offsetState) {
    var charCode = osc.readPrimitive(dv, &#x22;getUint32&#x22;, 4, offsetState);
    return String.fromCharCode(charCode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readColor" id="apidoc.element.osc.osc.readColor">
        function <span class="apidocSignatureSpan">osc.osc.</span>readColor
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readColor = function (dv, offsetState) {
    var bytes = new Uint8Array(dv.buffer, offsetState.idx, 4),
        alpha = bytes[3] / 255;

    offsetState.idx += 4;

    return {
        r: bytes[0],
        g: bytes[1],
        b: bytes[2],
        a: alpha
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readFalse" id="apidoc.element.osc.osc.readFalse">
        function <span class="apidocSignatureSpan">osc.osc.</span>readFalse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFalse = function () {
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readFloat32" id="apidoc.element.osc.osc.readFloat32">
        function <span class="apidocSignatureSpan">osc.osc.</span>readFloat32
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFloat32 = function (dv, offsetState) {
    return osc.readPrimitive(dv, &#x22;getFloat32&#x22;, 4, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readFloat64" id="apidoc.element.osc.osc.readFloat64">
        function <span class="apidocSignatureSpan">osc.osc.</span>readFloat64
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFloat64 = function (dv, offsetState) {
    return osc.readPrimitive(dv, &#x22;getFloat64&#x22;, 8, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readImpulse" id="apidoc.element.osc.osc.readImpulse">
        function <span class="apidocSignatureSpan">osc.osc.</span>readImpulse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readImpulse = function () {
    return 1.0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readInt32" id="apidoc.element.osc.osc.readInt32">
        function <span class="apidocSignatureSpan">osc.osc.</span>readInt32
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt32 = function (dv, offsetState) {
    return osc.readPrimitive(dv, &#x22;getInt32&#x22;, 4, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Reads an OSC blob (&#x22;b&#x22;) (i.e. a Uint8Array).
 *
 * @param {DataView} dv a DataView instance to read from
 * @param {Object} offsetState an offsetState object used to store the current offset index into dv
 * @return {Uint8Array} the data that was read
 */
osc.readBlob = function (dv, offsetState) {
    var len = osc.<span class="apidocCodeKeywordSpan">readInt32</span>(dv, offsetState),
        paddedLen = (len + 3) &#x26; ~0x03,
        blob = new Uint8Array(dv.buffer, offsetState.idx, len);

    offsetState.idx += paddedLen;

    return blob;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readInt64" id="apidoc.element.osc.osc.readInt64">
        function <span class="apidocSignatureSpan">osc.osc.</span>readInt64
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt64 = function (dv, offsetState) {
    var high = osc.readPrimitive(dv, &#x22;getInt32&#x22;, 4, offsetState),
        low = osc.readPrimitive(dv, &#x22;getInt32&#x22;, 4, offsetState);

    if (Long) {
        return new Long(low, high);
    } else {
        return {
            high: high,
            low: low,
            unsigned: false
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readMIDIBytes" id="apidoc.element.osc.osc.readMIDIBytes">
        function <span class="apidocSignatureSpan">osc.osc.</span>readMIDIBytes
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readMIDIBytes = function (dv, offsetState) {
    var midi = new Uint8Array(dv.buffer, offsetState.idx, 4);
    offsetState.idx += 4;

    return midi;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readMessage" id="apidoc.element.osc.osc.readMessage">
        function <span class="apidocSignatureSpan">osc.osc.</span>readMessage
        <span class="apidocSignatureSpan">(data, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readMessage = function (data, options, offsetState) {
    options = options || osc.defaults;

    var dv = osc.dataView(data, data.byteOffset, data.byteLength);
    offsetState = offsetState || {
        idx: 0
    };

    var address = osc.readString(dv, offsetState);
    return osc.readMessageContents(address, dv, options, offsetState);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readMessageContents" id="apidoc.element.osc.osc.readMessageContents">
        function <span class="apidocSignatureSpan">osc.osc.</span>readMessageContents
        <span class="apidocSignatureSpan">(address, dv, options, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readMessageContents = function (address, dv, options, offsetState) {
    if (address.indexOf(&#x22;/&#x22;) !== 0) {
        throw new Error(&#x22;A malformed OSC address was found while reading &#x22; +
            &#x22;an OSC message. String was: &#x22; + address);
    }

    var args = osc.readArguments(dv, options, offsetState);

    return {
        address: address,
        args: args.length === 1 &#x26;&#x26; options.unpackSingleArgs ? args[0] : args
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    var dv = osc.dataView(data, data.byteOffset, data.byteLength);
    offsetState = offsetState || {
        idx: 0
    };

    var address = osc.readString(dv, offsetState);
    return osc.<span class="apidocCodeKeywordSpan">readMessageContents</span>(address, dv, options, offsetState);
};

// Unsupported, non-API function.
osc.readMessageContents = function (address, dv, options, offsetState) {
    if (address.indexOf(&#x22;/&#x22;) !== 0) {
        throw new Error(&#x22;A malformed OSC address was found while reading &#x22; +
            &#x22;an OSC message. String was: &#x22; + address);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readNull" id="apidoc.element.osc.osc.readNull">
        function <span class="apidocSignatureSpan">osc.osc.</span>readNull
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readNull = function () {
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readPacket" id="apidoc.element.osc.osc.readPacket">
        function <span class="apidocSignatureSpan">osc.osc.</span>readPacket
        <span class="apidocSignatureSpan">(data, options, offsetState, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readPacket = function (data, options, offsetState, len) {
    var dv = osc.dataView(data, data.byteOffset, data.byteLength);

    len = len === undefined ? dv.byteLength : len;
    offsetState = offsetState || {
        idx: 0
    };

    var header = osc.readString(dv, offsetState),
        firstChar = header[0];

    if (firstChar === &#x22;#&#x22;) {
        return osc.readBundleContents(dv, options, offsetState, len);
    } else if (firstChar === &#x22;/&#x22;) {
        return osc.readMessageContents(header, dv, options, offsetState);
    }

    throw new Error(&#x22;The header of an OSC packet didn&#x27;t contain an OSC address or a #bundle string.&#x22; +
        &#x22; Header was: &#x22; + header);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
they should be caught and handled using
&#x3c;code&#x3e;try&#x3c;/code&#x3e;/&#x3c;code&#x3e;catch&#x3c;/code&#x3e;.

```javascript
var msg;

try {
    msg = osc.<span class="apidocCodeKeywordSpan">readPacket</span>(rawPacket);
} catch (error) {
    console.log(&#x22;An error occurred: &#x22;, error.message);
}
```

The osc.js Low-Level API
------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readPrimitive" id="apidoc.element.osc.osc.readPrimitive">
        function <span class="apidocSignatureSpan">osc.osc.</span>readPrimitive
        <span class="apidocSignatureSpan">(dv, readerName, numBytes, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readPrimitive = function (dv, readerName, numBytes, offsetState) {
    var val = dv[readerName](offsetState.idx, false);
    offsetState.idx += numBytes;

    return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Reads an OSC int32 (&#x22;i&#x22;) value.
 *
 * @param {DataView} dv a DataView containing the raw bytes
 * @param {Object} offsetState an offsetState object used to store the current offset index into dv
 * @return {Number} the number that was read
 */
osc.readInt32 = function (dv, offsetState) {
    return osc.<span class="apidocCodeKeywordSpan">readPrimitive</span>(dv, &#x22;getInt32&#x22;, 4, offsetState);
};

/**
 * Writes an OSC int32 (&#x22;i&#x22;) value.
 *
 * @param {Number} val the number to write
 * @param {DataView} [dv] a DataView instance to write the number into
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readString" id="apidoc.element.osc.osc.readString">
        function <span class="apidocSignatureSpan">osc.osc.</span>readString
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readString = function (dv, offsetState) {
    var charCodes = [],
        idx = offsetState.idx;

    for (; idx &#x3c; dv.byteLength; idx++) {
        var charCode = dv.getUint8(idx);
        if (charCode !== 0) {
            charCodes.push(charCode);
        } else {
            idx++;
            break;
        }
    }

    // Round to the nearest 4-byte block.
    idx = (idx + 3) &#x26; ~0x03;
    offsetState.idx = idx;

    return String.fromCharCode.apply(null, charCodes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {DataView} dv a DataView instance to read from
 * @param {Object} offsetState the offsetState object that stores the current offset into dv
 * @param {Oobject} [options] read options
 * @return {Array} an array of the OSC arguments that were read
 */
osc.readArguments = function (dv, options, offsetState) {
    var typeTagString = osc.<span class="apidocCodeKeywordSpan">readString</span>(dv, offsetState);
    if (typeTagString.indexOf(&#x22;,&#x22;) !== 0) {
        // Despite what the OSC 1.0 spec says,
        // it just doesn&#x27;t make sense to handle messages without type tags.
        // scsynth appears to read such messages as if they have a single
        // Uint8 argument. sclang throws an error if the type tag is omitted.
        throw new Error(&#x22;A malformed type tag string was found while reading &#x22; +
            &#x22;the arguments of an OSC message. String was: &#x22; +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readTimeTag" id="apidoc.element.osc.osc.readTimeTag">
        function <span class="apidocSignatureSpan">osc.osc.</span>readTimeTag
        <span class="apidocSignatureSpan">(dv, offsetState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readTimeTag = function (dv, offsetState) {
    var secs1900 = osc.readPrimitive(dv, &#x22;getUint32&#x22;, 4, offsetState),
        frac = osc.readPrimitive(dv, &#x22;getUint32&#x22;, 4, offsetState),
        native = (secs1900 === 0 &#x26;&#x26; frac === 1) ? Date.now() : osc.ntpToJSTime(secs1900, frac);

    return {
        raw: [secs1900, frac],
        native: native
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    osc.isValidBundle = function (bundle) {
return bundle.timeTag !== undefined &#x26;&#x26; bundle.packets !== undefined;
    };

    // Unsupported, non-API function.
    osc.readBundleContents = function (dv, options, offsetState, len) {
var timeTag = osc.<span class="apidocCodeKeywordSpan">readTimeTag</span>(dv, offsetState),
    packets = [];

while (offsetState.idx &#x3c; len) {
    var packetSize = osc.readInt32(dv, offsetState),
        packetLen = offsetState.idx + packetSize,
        packet = osc.readPacket(dv, options, offsetState, packetLen);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.readTrue" id="apidoc.element.osc.osc.readTrue">
        function <span class="apidocSignatureSpan">osc.osc.</span>readTrue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readTrue = function () {
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.relay" id="apidoc.element.osc.osc.relay">
        function <span class="apidocSignatureSpan">osc.osc.</span>relay
        <span class="apidocSignatureSpan">(from, to, eventName, sendFnName, transformFn, sendArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">relay = function (from, to, eventName, sendFnName, transformFn, sendArgs) {
    eventName = eventName || &#x22;message&#x22;;
    sendFnName = sendFnName || &#x22;send&#x22;;
    transformFn = transformFn || function () {};
    sendArgs = sendArgs ? [null].concat(sendArgs) : [];

    var listener = function (data) {
        sendArgs[0] = data;
        data = transformFn(data);
        to[sendFnName].apply(to, sendArgs);
    };

    from.on(eventName, listener);

    return {
        eventName: eventName,
        listener: listener
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// Unsupported, non-API function.
osc.relayPorts = function (from, to, o) {
    var eventName = o.raw ? &#x22;raw&#x22; : &#x22;osc&#x22;,
        sendFnName = o.raw ? &#x22;sendRaw&#x22; : &#x22;send&#x22;;

    return osc.<span class="apidocCodeKeywordSpan">relay</span>(from, to, eventName, sendFnName, o.transform);
};

// Unsupported, non-API function.
osc.stopRelaying = function (from, relaySpec) {
    from.removeListener(relaySpec.eventName, relaySpec.listener);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.relayPorts" id="apidoc.element.osc.osc.relayPorts">
        function <span class="apidocSignatureSpan">osc.osc.</span>relayPorts
        <span class="apidocSignatureSpan">(from, to, o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">relayPorts = function (from, to, o) {
    var eventName = o.raw ? &#x22;raw&#x22; : &#x22;osc&#x22;,
        sendFnName = o.raw ? &#x22;sendRaw&#x22; : &#x22;send&#x22;;

    return osc.relay(from, to, eventName, sendFnName, o.transform);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };

    p.listen = function () {
if (this.port1Spec &#x26;&#x26; this.port2Spec) {
    this.close();
}

this.port1Spec = osc.<span class="apidocCodeKeywordSpan">relayPorts</span>(this.port1, this.port2, this.options);
this.port2Spec = osc.relayPorts(this.port2, this.port1, this.options);

// Bind port close listeners to ensure that the relay
// will stop forwarding messages if one of its ports close.
// Users are still responsible for closing the underlying ports
// if necessary.
var closeListener = this.close.bind(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.stopRelaying" id="apidoc.element.osc.osc.stopRelaying">
        function <span class="apidocSignatureSpan">osc.osc.</span>stopRelaying
        <span class="apidocSignatureSpan">(from, relaySpec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopRelaying = function (from, relaySpec) {
    from.removeListener(relaySpec.eventName, relaySpec.listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // if necessary.
    var closeListener = this.close.bind(this);
    this.port1.on(&#x22;close&#x22;, closeListener);
    this.port2.on(&#x22;close&#x22;, closeListener);
};

p.close = function () {
    osc.<span class="apidocCodeKeywordSpan">stopRelaying</span>(this.port1, this.port1Spec);
    osc.stopRelaying(this.port2, this.port2Spec);
    this.emit(&#x22;close&#x22;, this.port1, this.port2);
};


// If we&#x27;re in a require-compatible environment, export ourselves.
if (typeof module !== &#x22;undefined&#x22; &#x26;&#x26; module.exports) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.timeTag" id="apidoc.element.osc.osc.timeTag">
        function <span class="apidocSignatureSpan">osc.osc.</span>timeTag
        <span class="apidocSignatureSpan">(secs, now)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeTag = function (secs, now) {
    secs = secs || 0;
    now = now || Date.now();

    var nowSecs = now / 1000,
        nowWhole = Math.floor(nowSecs),
        nowFracs = nowSecs - nowWhole,
        secsWhole = Math.floor(secs),
        secsFracs = secs - secsWhole,
        fracs = nowFracs + secsFracs;

    if (fracs &#x3e; 1) {
        var fracsWhole = Math.floor(fracs),
            fracsFracs = fracs - fracsWhole;

        secsWhole += fracsWhole;
        fracs = fracsFracs;
    }

    var ntpSecs = nowWhole + secsWhole + osc.SECS_70YRS,
        ntpFracs = Math.round(osc.TWO_32 * fracs);

    return {
        raw: [ntpSecs, ntpFracs]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

##### Sending OSC bundles:
```javascript
oscPort.on(&#x22;ready&#x22;, function () {
oscPort.send({
    timeTag: osc.<span class="apidocCodeKeywordSpan">timeTag</span>(60), // Schedules this bundle 60 seconds from now.
    packets: [
        {
            address: &#x22;/carrier/frequency&#x22;,
            args: 440
        },
        {
            address: &#x22;/carrier/amplitude&#x22;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writeArgument" id="apidoc.element.osc.osc.writeArgument">
        function <span class="apidocSignatureSpan">osc.osc.</span>writeArgument
        <span class="apidocSignatureSpan">(arg, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArgument = function (arg, dataCollection) {
    if (osc.isArray(arg)) {
        return osc.writeArrayArguments(arg, dataCollection);
    }

    var type = arg.type,
        writer = osc.argumentTypes[type].writer;

    if (writer) {
        var data = osc[writer](arg.value);
        osc.addDataPart(data, dataCollection);
    }

    return arg.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

osc.writeArrayArguments = function (args, dataCollection) {
    var typeTag = &#x22;[&#x22;;

    for (var i = 0; i &#x3c; args.length; i++) {
        var arg = args[i];
        typeTag += osc.<span class="apidocCodeKeywordSpan">writeArgument</span>(arg, dataCollection);
    }

    typeTag += &#x22;]&#x22;;

    return typeTag;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writeArguments" id="apidoc.element.osc.osc.writeArguments">
        function <span class="apidocSignatureSpan">osc.osc.</span>writeArguments
        <span class="apidocSignatureSpan">(args, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArguments = function (args, options) {
    var argCollection = osc.collectArguments(args, options);
    return osc.joinParts(argCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writeArrayArguments" id="apidoc.element.osc.osc.writeArrayArguments">
        function <span class="apidocSignatureSpan">osc.osc.</span>writeArrayArguments
        <span class="apidocSignatureSpan">(args, dataCollection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeArrayArguments = function (args, dataCollection) {
    var typeTag = &#x22;[&#x22;;

    for (var i = 0; i &#x3c; args.length; i++) {
        var arg = args[i];
        typeTag += osc.writeArgument(arg, dataCollection);
    }

    typeTag += &#x22;]&#x22;;

    return typeTag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
typeTag += &#x22;]&#x22;;

return typeTag;
    };

    osc.writeArgument = function (arg, dataCollection) {
if (osc.isArray(arg)) {
    return osc.<span class="apidocCodeKeywordSpan">writeArrayArguments</span>(arg, dataCollection);
}

var type = arg.type,
    writer = osc.argumentTypes[type].writer;

if (writer) {
    var data = osc[writer](arg.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writeBlob" id="apidoc.element.osc.osc.writeBlob">
        function <span class="apidocSignatureSpan">osc.osc.</span>writeBlob
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeBlob = function (data) {
    data = osc.byteArray(data);

    var len = data.byteLength,
        paddedLen = (len + 3) &#x26; ~0x03,
        offset = 4, // Extra 4 bytes is for the size.
        blobLen = paddedLen + offset,
        arr = new Uint8Array(blobLen),
        dv = new DataView(arr.buffer);

    // Write the size.
    osc.writeInt32(len, dv);

    // Since we&#x27;re writing to a real ArrayBuffer,
    // we don&#x27;t need to pad the remaining bytes.
    arr.set(data, offset);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writeBundle" id="apidoc.element.osc.osc.writeBundle">
        function <span class="apidocSignatureSpan">osc.osc.</span>writeBundle
        <span class="apidocSignatureSpan">(bundle, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeBundle = function (bundle, options) {
    if (!osc.isValidBundle(bundle)) {
        throw new Error(&#x22;An OSC bundle must contain &#x27;timeTag&#x27; and &#x27;packets&#x27; properties. &#x22; +
            &#x22;Bundle was: &#x22; + JSON.stringify(bundle, null, 2));
    }

    options = options || osc.defaults;
    var bundleCollection = osc.collectBundlePackets(bundle, options);

    return osc.joinParts(bundleCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Object} [options] write options
 * @return {Uint8Array} an array of bytes containing the message
 */
osc.writePacket = function (packet, options) {
    if (osc.isValidMessage(packet)) {
        return osc.writeMessage(packet, options);
    } else if (osc.isValidBundle(packet)) {
        return osc.<span class="apidocCodeKeywordSpan">writeBundle</span>(packet, options);
    } else {
        throw new Error(&#x22;The specified packet was not recognized as a valid OSC message or bundle.&#x22; +
            &#x22; Packet was: &#x22; + JSON.stringify(packet, null, 2));
    }
};

// Unsupported, non-API.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writeChar32" id="apidoc.element.osc.osc.writeChar32">
        function <span class="apidocSignatureSpan">osc.osc.</span>writeChar32
        <span class="apidocSignatureSpan">(str, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeChar32 = function (str, dv, offset) {
    var charCode = str.charCodeAt(0);
    if (charCode === undefined || charCode &#x3c; -1) {
        return undefined;
    }

    return osc.writePrimitive(charCode, dv, &#x22;setUint32&#x22;, 4, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writeColor" id="apidoc.element.osc.osc.writeColor">
        function <span class="apidocSignatureSpan">osc.osc.</span>writeColor
        <span class="apidocSignatureSpan">(color)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeColor = function (color) {
    var alpha = Math.round(color.a * 255),
        arr = new Uint8Array([color.r, color.g, color.b, alpha]);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writeFloat32" id="apidoc.element.osc.osc.writeFloat32">
        function <span class="apidocSignatureSpan">osc.osc.</span>writeFloat32
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFloat32 = function (val, dv, offset) {
    return osc.writePrimitive(val, dv, &#x22;setFloat32&#x22;, 4, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writeFloat64" id="apidoc.element.osc.osc.writeFloat64">
        function <span class="apidocSignatureSpan">osc.osc.</span>writeFloat64
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFloat64 = function (val, dv, offset) {
    return osc.writePrimitive(val, dv, &#x22;setFloat64&#x22;, 8, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writeInt32" id="apidoc.element.osc.osc.writeInt32">
        function <span class="apidocSignatureSpan">osc.osc.</span>writeInt32
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt32 = function (val, dv, offset) {
    return osc.writePrimitive(val, dv, &#x22;setInt32&#x22;, 4, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        paddedLen = (len + 3) &#x26; ~0x03,
        offset = 4, // Extra 4 bytes is for the size.
        blobLen = paddedLen + offset,
        arr = new Uint8Array(blobLen),
        dv = new DataView(arr.buffer);

    // Write the size.
    osc.<span class="apidocCodeKeywordSpan">writeInt32</span>(len, dv);

    // Since we&#x27;re writing to a real ArrayBuffer,
    // we don&#x27;t need to pad the remaining bytes.
    arr.set(data, offset);

    return arr;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writeInt64" id="apidoc.element.osc.osc.writeInt64">
        function <span class="apidocSignatureSpan">osc.osc.</span>writeInt64
        <span class="apidocSignatureSpan">(val, dv, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt64 = function (val, dv, offset) {
    var arr = new Uint8Array(8);
    arr.set(osc.writePrimitive(val.high, dv, &#x22;setInt32&#x22;, 4, offset), 0);
    arr.set(osc.writePrimitive(val.low,  dv, &#x22;setInt32&#x22;, 4, offset + 4), 4);
    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writeMIDIBytes" id="apidoc.element.osc.osc.writeMIDIBytes">
        function <span class="apidocSignatureSpan">osc.osc.</span>writeMIDIBytes
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeMIDIBytes = function (bytes) {
    bytes = osc.byteArray(bytes);

    var arr = new Uint8Array(4);
    arr.set(bytes);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writeMessage" id="apidoc.element.osc.osc.writeMessage">
        function <span class="apidocSignatureSpan">osc.osc.</span>writeMessage
        <span class="apidocSignatureSpan">(msg, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeMessage = function (msg, options) {
    options = options || osc.defaults;

    if (!osc.isValidMessage(msg)) {
        throw new Error(&#x22;An OSC message must contain a valid address. Message was: &#x22; +
            JSON.stringify(msg, null, 2));
    }

    var msgCollection = osc.collectMessageParts(msg, options);
    return osc.joinParts(msgCollection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Object} a bundle or message object
 * @param {Object} [options] write options
 * @return {Uint8Array} an array of bytes containing the message
 */
osc.writePacket = function (packet, options) {
    if (osc.isValidMessage(packet)) {
        return osc.<span class="apidocCodeKeywordSpan">writeMessage</span>(packet, options);
    } else if (osc.isValidBundle(packet)) {
        return osc.writeBundle(packet, options);
    } else {
        throw new Error(&#x22;The specified packet was not recognized as a valid OSC message or bundle.&#x22; +
            &#x22; Packet was: &#x22; + JSON.stringify(packet, null, 2));
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writePacket" id="apidoc.element.osc.osc.writePacket">
        function <span class="apidocSignatureSpan">osc.osc.</span>writePacket
        <span class="apidocSignatureSpan">(packet, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writePacket = function (packet, options) {
    if (osc.isValidMessage(packet)) {
        return osc.writeMessage(packet, options);
    } else if (osc.isValidBundle(packet)) {
        return osc.writeBundle(packet, options);
    } else {
        throw new Error(&#x22;The specified packet was not recognized as a valid OSC message or bundle.&#x22; +
            &#x22; Packet was: &#x22; + JSON.stringify(packet, null, 2));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &#x3c;code&#x3e;options&#x3c;/code&#x3e;: (optional) An options object, described below; &#x3c;br /&#x3e;
        &#x3c;code&#x3e;offsetState&#x3c;/code&#x3e;: (optional) an offset state object containing an &#x3c;code&#x3e;idx&#x3c;/
code&#x3e; property that specifies the offset index into &#x3c;code&#x3e;data&#x3c;/code&#x3e;; &#x3c;br /&#x3e;
        &#x3c;code&#x3e;length&#x3c;/code&#x3e; the length (in bytes) to read from &#x3c;code&#x3e;data&#x3c;/code&#x3e;
    &#x3c;/td&#x3e;
    &#x3c;td&#x3e;An osc.js message or bundle object&#x3c;/td&#x3e;
&#x3c;/tr&#x3e;
&#x3c;tr&#x3e;
    &#x3c;td&#x3e;&#x3c;code&#x3e;osc.<span class="apidocCodeKeywordSpan">writePacket</span>()&#x3c;/code&#x3e;&#x3c;/td&#x3e;
    &#x3c;td&#x3e;Writes an OSC message or bundle object to a binary array.&#x3c;/td&#x3e;
    &#x3c;td&#x3e;
        &#x3c;code&#x3e;packate&#x3c;/code&#x3e;: An osc.js message or bundle object;&#x3c;br /&#x3e;
        &#x3c;code&#x3e;options&#x3c;/code&#x3e;: (optional) An options object, described below&#x3c;br /&#x3e;
    &#x3c;/td&#x3e;
    &#x3c;td&#x3e;A &#x3c;code&#x3e;Uint8Array&#x3c;/code&#x3e;&#x3c;/td&#x3e;
&#x3c;/tr&#x3e;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writePrimitive" id="apidoc.element.osc.osc.writePrimitive">
        function <span class="apidocSignatureSpan">osc.osc.</span>writePrimitive
        <span class="apidocSignatureSpan">(val, dv, writerName, numBytes, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writePrimitive = function (val, dv, writerName, numBytes, offset) {
    offset = offset === undefined ? 0 : offset;

    var arr;
    if (!dv) {
        arr = new Uint8Array(numBytes);
        dv = new DataView(arr.buffer);
    } else {
        arr = new Uint8Array(dv.buffer);
    }

    dv[writerName](offset, val, false);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Writes an OSC int32 (&#x22;i&#x22;) value.
 *
 * @param {Number} val the number to write
 * @param {DataView} [dv] a DataView instance to write the number into
 * @param {Number} [offset] an offset into dv
 */
osc.writeInt32 = function (val, dv, offset) {
    return osc.<span class="apidocCodeKeywordSpan">writePrimitive</span>(val, dv, &#x22;setInt32&#x22;, 4, offset);
};

/**
 * Reads an OSC int64 (&#x22;h&#x22;) value.
 *
 * @param {DataView} dv a DataView containing the raw bytes
 * @param {Object} offsetState an offsetState object used to store the current offset index into dv
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writeString" id="apidoc.element.osc.osc.writeString">
        function <span class="apidocSignatureSpan">osc.osc.</span>writeString
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeString = function (str) {
    var terminated = str + &#x22;\u0000&#x22;,
        len = terminated.length,
        paddedLen = (len + 3) &#x26; ~0x03,
        arr = new Uint8Array(paddedLen);

    for (var i = 0; i &#x3c; terminated.length; i++) {
        var charCode = terminated.charCodeAt(i);
        arr[i] = charCode;
    }

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        currPartIdx = dataCollection.parts.length;

    for (var i = 0; i &#x3c; args.length; i++) {
        var arg = args[i];
        typeTagString += osc.writeArgument(arg, dataCollection);
    }

    var typeData = osc.<span class="apidocCodeKeywordSpan">writeString</span>(typeTagString);
    dataCollection.byteLength += typeData.byteLength;
    dataCollection.parts.splice(currPartIdx, 0, typeData);

    return dataCollection;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.osc.osc.writeTimeTag" id="apidoc.element.osc.osc.writeTimeTag">
        function <span class="apidocSignatureSpan">osc.osc.</span>writeTimeTag
        <span class="apidocSignatureSpan">(timeTag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeTimeTag = function (timeTag) {
    var raw = timeTag.raw ? timeTag.raw : osc.jsToNTPTime(timeTag.native),
        arr = new Uint8Array(8), // Two Unit32s.
        dv = new DataView(arr.buffer);

    osc.writeInt32(raw[0], dv, 0);
    osc.writeInt32(raw[1], dv, 4);

    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    osc.collectBundlePackets = function (bundle, options, dataCollection) {
        dataCollection = dataCollection || {
byteLength: 0,
parts: []
        };

        osc.addDataPart(osc.writeString(&#x22;#bundle&#x22;), dataCollection);
        osc.addDataPart(osc.<span class="apidocCodeKeywordSpan">writeTimeTag</span>(bundle.timeTag), dataCollection);

        for (var i = 0; i &#x3c; bundle.packets.length; i++) {
var packet = bundle.packets[i],
    collector = packet.address ? osc.collectMessageParts : osc.collectBundlePackets,
    packetCollection = collector(packet, options);

dataCollection.byteLength += packetCollection.byteLength;
...</pre></li>
    </ul>










</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
